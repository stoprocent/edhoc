{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-09-12T01:04:22.445669+00:00",
  "repo": "lake-wg/edhoc",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "v-02",
      "description": "",
      "color": "f9d0c4"
    },
    {
      "name": "LAKE interim jan 2021",
      "description": "",
      "color": "fef2c0"
    },
    {
      "name": "v-05",
      "description": "",
      "color": "d93f0b"
    },
    {
      "name": "Close?",
      "description": "",
      "color": "E33AA3"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU2NTIzNjcyMDg=",
      "title": "Self-contained specification",
      "url": "https://github.com/lake-wg/edhoc/issues/1",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Comment by Martin Disch in \r\nhttps://mailarchive.ietf.org/arch/msg/lake/KmAQm0KmDGEBnvQm3ZGwGiLu3LE/\r\n\r\n\"The draft does a good job of pointing to the right places in RFC 8152, but I still ended up trying to\r\nunderstand another ~100 page document just to implement the few constructs I actually needed.\"\r\n\r\nShould we provide more details about COSE constructs, e.g. in appendix A.2?\r\n",
      "createdAt": "2020-07-07T14:23:51Z",
      "updatedAt": "2021-07-19T13:13:37Z",
      "closedAt": "2021-07-19T13:13:37Z",
      "comments": [
        {
          "author": "martindisch",
          "authorAssociation": "NONE",
          "body": "(pasting my response from the mailing list here for completeness)\r\n\r\nThanks for following up on this. Yes, in my opinion expanding on the COSE constructs would be helpful. But I also sympathize with not wanting to duplicate what is already defined in another RFC (and possibly getting it wrong, as Carsten points out). Considering that there are quite a few implementers already and besides mine you have only received one other similar comment, maybe this isn't an issue for a meaningful majority.\r\n\r\nIn any case, the draft has made great strides already in terms of accessibility and is in a good state now, so I don't see improvements in this area as an absolute necessity.",
          "createdAt": "2020-07-07T16:06:59Z",
          "updatedAt": "2020-07-07T16:06:59Z"
        },
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The two COSE constructs that are used in EHDOC, `COSE_Encrypt0` and `COSE_Sign1` are fairly simple. They don't use the recursive `COSE_Recipient` structure or embed `COSE_Keys`. I think it is possible to add some additional clarifications on the structure of the COSE messages in the EHDOC draft without having to copy too much text from RFC 8152.",
          "createdAt": "2020-11-11T10:29:09Z",
          "updatedAt": "2020-11-11T10:29:09Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU2NTI0NjEzODQ=",
      "title": "Ciphersuites requiring multiple SHA ",
      "url": "https://github.com/lake-wg/edhoc/issues/2",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Comment by Rene Struik:\r\nhttps://mailarchive.ietf.org/arch/msg/lake/KGiw6uY5u5J9ANcwbnsaRvqWh1s/\r\n\r\n\"why enforcing both SHA512 and SHA256 at the same time\"\r\n\r\nEd25519 specifies SHA512. Ciphersuite 0 and 1 additionally requires SHA256.\r\n\r\nProposed solution: Require only SHA512 in ciphersuite 0 and 1.",
      "createdAt": "2020-07-07T16:32:47Z",
      "updatedAt": "2021-01-26T05:26:45Z",
      "closedAt": "2021-01-26T05:26:44Z",
      "comments": [
        {
          "author": "ms-s",
          "authorAssociation": "NONE",
          "body": "A couple of references to look at while fixing this issue: \r\nhttps://tools.ietf.org/html/draft-ietf-lwig-curve-representations-11\r\nand \r\nhttps://tools.ietf.org/html/draft-ietf-6lo-ap-nd-23#section-8.2",
          "createdAt": "2020-07-31T11:49:22Z",
          "updatedAt": "2020-07-31T11:49:22Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "https://tools.ietf.org/html/draft-ietf-lwig-curve-representations-11 may not solve the issue with SHA-512 but should be mentioned in the security considerations, together with relevant NIST terminology.",
          "createdAt": "2020-10-16T12:22:57Z",
          "updatedAt": "2020-10-16T12:22:57Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Discuss at IETF 109. When changed, test vectors needs to be updated.\r\n",
          "createdAt": "2020-10-30T13:18:27Z",
          "updatedAt": "2020-10-30T13:18:27Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Cipher suite 0 and 1 when used with Static Diffie Hellman keys does not require SHA-512. So we should not change this to SHA-512",
          "createdAt": "2020-11-03T08:33:21Z",
          "updatedAt": "2020-11-03T08:33:21Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "So, to have a cipher suite with a single SHA (avoid implementing multiple), signature and static DH algorithms need to use the same, which requires a new specification of one or the other?\r\n\r\nSee also #21.\r\n\r\n",
          "createdAt": "2020-11-05T09:49:53Z",
          "updatedAt": "2020-11-05T10:14:13Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "More background. Hash functions are used in several places in EDHOC:\r\n- Transcript Hash\r\n- Key-Derivation Function (KDF)\r\n- Signature algorithm\r\n- Credential identifiers (ID_CRED_R and ID_CRED_I)\r\nAdditionally, a hash function is used by the application, e.g., in the OSCORE KDF.\r\n\r\nA solution involving only SHA-512 in cipher suites with Ed25519 would require more memory to handle larger digests. Note that it also increases the length of x5t identifiers to 256 bit instead of 64.",
          "createdAt": "2020-11-05T18:27:43Z",
          "updatedAt": "2020-11-05T18:27:43Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Based on the points in the comment above, I concur it is good to have (also) SHA-256 involved in the cipher suites.",
          "createdAt": "2020-11-10T07:20:33Z",
          "updatedAt": "2020-11-10T07:20:33Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "I agree on keeping SHA-256",
          "createdAt": "2020-11-10T12:38:51Z",
          "updatedAt": "2020-11-10T12:38:51Z"
        },
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also agree on keeping SHA-256. Since I prefer to switch to Ed25519 with SHA-256 (https://github.com/lake-wg/edhoc/issues/22#issuecomment-724843802), this would also solve the issue of using multiple SHA primitives in a single ciphersuite.",
          "createdAt": "2020-11-10T17:25:02Z",
          "updatedAt": "2020-11-10T17:25:02Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue has been overtaken by events.  SHA-256-only implementations are supported as of 70088cc.\r\n\r\n\r\n",
          "createdAt": "2021-01-26T05:26:44Z",
          "updatedAt": "2021-01-26T05:26:44Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2NTMzNjQwODg=",
      "title": "Replace PSK ECDHE ",
      "url": "https://github.com/lake-wg/edhoc/issues/3",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "According to the requirements\r\n  \"an AKE which is\r\n   extensible but does not include PSK ECDHE would be conformant with\r\n   the requirements for the initial scope. \"\r\n(https://tools.ietf.org/html/draft-ietf-lake-reqs-04#section-2.2.1)\r\n\r\nIn the absence of PSK ECHDE, another PSK based procedure providing forward security is needed, as introduced here:\r\nhttps://mailarchive.ietf.org/arch/msg/lake/-Fx-NVLrZohQ7p8Wy8VNpsDC_-M/\r\n\r\nAn alternative/complement is to include a procedure in OSCORE:\r\nhttps://mailarchive.ietf.org/arch/msg/lake/5DAmN2c7cOXCUej-4XRHxa18MIQ/",
      "createdAt": "2020-07-08T14:53:22Z",
      "updatedAt": "2021-01-26T05:19:07Z",
      "closedAt": "2021-01-26T05:19:07Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on feedback during IETF 108 it seems clear that we need to first describe the problem better before stating what properties the procedure replacing PSK ECDHE should have. Things to consider, in addition to the mail content in thread referenced above, include (but not limited to):\r\n\r\n- application \"session\" resumption\r\n- key rotation between or within application \"session\"\r\n- key rotation before exceeding usage limits (taking into account the commonly used AES-CCM truncated to 64 bits, https://tools.ietf.org/html/draft-wood-cfrg-aead-limits)\r\n- forward and/or backward security\r\n- performance, in particular number and size of messages (if any)\r\n",
          "createdAt": "2020-08-01T08:10:46Z",
          "updatedAt": "2020-08-01T08:10:46Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I assign to myself to restart the discussion on the LAKE mailing list.",
          "createdAt": "2020-08-02T14:21:31Z",
          "updatedAt": "2020-08-02T14:21:42Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Covered by the separate issues: #20 #24 #25 ",
          "createdAt": "2020-11-06T13:24:03Z",
          "updatedAt": "2021-01-26T05:19:00Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2NzA2NTk4MTc=",
      "title": "User stories",
      "url": "https://github.com/lake-wg/edhoc/issues/4",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "v-02"
      ],
      "body": "Extracted from  https://arxiv.org/abs/2007.11427\r\nhttps://www.ietf.org/proceedings/108/slides/slides-108-lake-tamarin-study-of-edhoc-00\r\n\r\n\"exploring user-stories or use-cases would help identify which trade-offs to make\" ",
      "createdAt": "2020-08-01T08:30:27Z",
      "updatedAt": "2020-11-02T14:42:47Z",
      "closedAt": "2020-11-02T14:42:47Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by new section 1.2.",
          "createdAt": "2020-11-02T14:42:47Z",
          "updatedAt": "2020-11-02T14:42:47Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU2NzA2NjgwNTc=",
      "title": "Clarify assumptions regarding use of TEE",
      "url": "https://github.com/lake-wg/edhoc/issues/5",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Extracted from https://arxiv.org/abs/2007.11427\r\nhttps://www.ietf.org/proceedings/108/slides/slides-108-lake-tamarin-study-of-edhoc-00\r\n\r\nOPTLS takes advantage of the use of TEE, relevant for STAT-based methods.\r\n\r\n\r\n",
      "createdAt": "2020-08-01T08:42:16Z",
      "updatedAt": "2021-02-21T10:08:18Z",
      "closedAt": "2021-02-21T10:08:18Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This doesn't have to be TEE required or not required. The protocol could offer some security properties for non-TEE implementations, but provide better properties with certain use of TEE.",
          "createdAt": "2020-08-01T08:46:46Z",
          "updatedAt": "2020-08-01T08:46:46Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Recent update provide recommendation to store as much as possible and to provide as many operations as possible in TEE.",
          "createdAt": "2020-11-02T19:51:05Z",
          "updatedAt": "2020-11-02T19:51:05Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri @pbtgit @TimothyClaeys & others - more input about TEE would be useful:\r\nHow much state can be stored in TEE of microcontrollers you are familiar with? \r\nWhat protocol components can we assume to implement in the TEE? \r\nAny expected change in the future?\r\n\r\n",
          "createdAt": "2020-11-11T09:47:57Z",
          "updatedAt": "2020-11-12T07:23:46Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "My limited experience of TEE is ARM TZ on ARM V8 and there the execution state can be  stored (protected with using device unique keys) to NV to allow power save of SDRAM.\r\n\r\nI am not aware of exactly how this is differs on micro controllers since  ARM V8-M.\r\nBut it seems like mbedTLS is used by several projects including TF-M which is \u201cTrusted FW for ARM V8-M\u201d.\r\n\r\n",
          "createdAt": "2020-11-12T08:57:57Z",
          "updatedAt": "2020-11-12T15:12:58Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "To save state in the secure world RAM of a Cortex M23/33 is not a problem at all. On those microcontrollers, the total available RAM can be divided between the secure and non-secure worlds. In our work we save all intermediate secret results of the computations (the state) in the secure world, which was a few hundred bytes. \r\n@gselander, @emanjon: Can you post a link to the  OPTLS with TEE document?",
          "createdAt": "2020-11-12T11:57:37Z",
          "updatedAt": "2020-11-12T11:57:37Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri The formulation of this issue is based on the comment from formal verification work referenced a the top. The OPTLS paper is here: \r\n\r\nhttps://eprint.iacr.org/2015/978.pdf\r\n\r\nBut this paper does not formulate properties in terms of TEE. As I understand the reasoning, there is a long term private key ('s'), potentially in security storage/execution, and an ephemeral private keys ('x') which may not be in secure storage/execution. By construction these keys are used together to derive the session key. Hence neither compromise of long-term key only nor ephemeral secret only reveals the session key.",
          "createdAt": "2020-11-12T15:11:37Z",
          "updatedAt": "2020-11-12T15:11:37Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "Are we talking about the static DH key authentication modes, or authentication with signatures, or both?",
          "createdAt": "2020-11-12T15:35:57Z",
          "updatedAt": "2020-11-12T15:35:57Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The comment was specifically about static DH based authentication. The general distinction between long term and ephemeral of course still applies to signature based AKE, but I'm not aware of an analogue in properties of derived keys.",
          "createdAt": "2020-11-13T10:50:45Z",
          "updatedAt": "2020-11-13T10:50:45Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "While the original comment was specifically about static DH based authentication. I don\u2019t think there is anything specific with static DH at all. The question is what parts we can expect to be implemented in a TEE. Key storage? Crypto operations like ECDH, SIGN, HMAC? The whole EDHOC protocol? EDHOC and OCSORE?\r\n",
          "createdAt": "2020-11-13T11:38:16Z",
          "updatedAt": "2020-11-13T11:59:12Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Trimmed the email header and trailer from the previous comment (which I don't disagree with - I responded specifically in the context OPTLS).",
          "createdAt": "2020-11-13T12:01:57Z",
          "updatedAt": "2020-11-13T12:01:57Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "The idea of a TEE is to put as little as possible code in the TEE in order to minimize the chance that exploitable vulnerabilities are introduced in it. \r\n\r\n\" The question is what parts we can expect to be implemented in a TEE?\"\r\nI will say it depends on the specific application/IoT device how much benefit is drawn (or must be drowned) through using the TEE. For some huge applications, it may be OK to put the complete OSCORE and EDHOC implementation in the TEE. For others however which have to be highly secure, it is better to put only the crypto operations and the keys in TEE.\r\n\r\n In our paper (still not published. When it gets published I will put a reference here) we are considering the latter case. Here is the subsection about sensitive assets:\r\n \r\n \"Sensitive Assets. By analyzing the EDHOC specifica-\r\ntion we identified the following key material as sensitive: 1)\r\nthe long term authentication keys, i.e. secret signature keys\r\nor secret static DH keys, 2) the public authentication key of\r\nthe other party when RPK is used and the root public key of\r\nthe CA when certificates are used, 3) intermediate EDHOC\r\nkeys and 4) the result of the EDHOC protocol. An attacker\r\nhaving access to one of those keys may: 1) impersonate the\r\ndevice by leaking its long term authentication keys, 2) fool\r\nthe device that its talking to a legit peer by changing the\r\npeer\u2019s public key or the root public key of the CA and 3) com-\r\npromise the security of EDHOC by leaking or manipulating\r\nits intermediate keys or the end result of the protocol.\r\nAlso sensitive are all cryptographic routines using the\r\nkeys. If these routines are manipulated, they may leak the\r\nkeys or allow the EDHOC protocol to succeed although the\r\ncommunication peer is not authentic.\"\r\n \r\n \r\n I think letting the ephemeral secret key outside the TEE is not a good idea because in this way an attacker outside the TEE may calculate the derived key. ",
          "createdAt": "2020-11-13T12:21:39Z",
          "updatedAt": "2020-11-13T12:22:42Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "I agree with above. It may be possible to put EDHOC/OSCORE in a TEE but as pointed out above the sensitive assets are the keys.\r\nThe concern of protecting EDHOC/OSCORE code can be addressed using some form of \"secure boot\", memory protection etc.",
          "createdAt": "2020-11-13T13:53:05Z",
          "updatedAt": "2020-11-13T13:53:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated the security considerations based on the discussion here. Removed that EDHOC is optimally implemented in TEE and added \"secure boot\".\r\n\r\nNote that Key compromise is described in one part of sec con and TEE in another.\r\n\r\nI think this can be closed\r\n",
          "createdAt": "2021-02-21T10:08:18Z",
          "updatedAt": "2021-02-21T10:08:18Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2NzA2Nzg1Mzg=",
      "title": "Clarify properties inferred from other crypto",
      "url": "https://github.com/lake-wg/edhoc/issues/6",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Extracted from https://arxiv.org/abs/2007.11427\r\nhttps://www.ietf.org/proceedings/108/slides/slides-108-lake-tamarin-study-of-edhoc-00\r\n\r\n\"Unclear if there is an *exact* mapping to Noise, so proofs of those does not necessarily automatically carry over.\"\r\n\r\nSimilar, if relevant, for OPTLS.\r\n\r\nUpdate security claims accordingly. In particular, the section on security properties in the security considerations is not making clear what methods the properties apply to.\r\n",
      "createdAt": "2020-08-01T08:57:30Z",
      "updatedAt": "2021-02-21T10:14:30Z",
      "closedAt": "2021-02-21T10:14:30Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The security consideration has been updated several times since 2007. In particular is has been updated to clearly refer to method when something only is true for a specific method.\r\n\r\nThe is not a direct mapping to OPTLS, the might be a mapping to Noise, but this has not been anylysed and is not used. The is strict mapping to SIGMA for the signature case, at least when a subject name is used.\r\n\r\nI close this now. It can be reopened if there are more concrete and recent things that need to be updated.",
          "createdAt": "2021-02-21T10:14:29Z",
          "updatedAt": "2021-02-21T10:14:29Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2NzA2ODcyODg=",
      "title": "Different properties of different methods",
      "url": "https://github.com/lake-wg/edhoc/issues/7",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "v-02"
      ],
      "body": "Freely extracted from https://arxiv.org/abs/2007.11427\r\nhttps://www.ietf.org/proceedings/108/slides/slides-108-lake-tamarin-study-of-edhoc-00\r\n\r\nDo we need\r\n\"homogeneity among the EDHOC methods when it comes to what security properties they provide\"?\r\n\r\nExample 1. All methods support (implicit) mutual authentication. Methods 0 and 1 support injective agreement (i.e. additional key confirmation of the responder). \r\n\r\nExample 2. Not all methods support non-repudation\r\n",
      "createdAt": "2020-08-01T09:10:07Z",
      "updatedAt": "2020-11-02T19:24:13Z",
      "closedAt": "2020-11-02T19:24:13Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Assuming we allow that different methods to have different properties, how do we handle the differences?\r\n\r\n* Is it sufficient to state that all methods has at least certain properties?\r\n\r\n* Describe additional properties in security considerations?\r\n\r\n* Require or recommend different applications of different methods? \r\n\r\n",
          "createdAt": "2020-08-01T09:14:33Z",
          "updatedAt": "2020-08-01T09:14:33Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft should state when key confirmation is achieved and that the parties can save the session state for future use.\r\n",
          "createdAt": "2020-10-16T12:08:35Z",
          "updatedAt": "2020-10-16T12:08:35Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that as described in the security considerations, none of the methods provide non-repudiation in a useful way. As the singature is over a MAC, non-repudiation requires that long-term storage of the ephemeral key which would remove PFS.",
          "createdAt": "2020-11-02T19:21:59Z",
          "updatedAt": "2020-11-02T19:21:59Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Recent commits add information on the implicit key authentication and explicit key confirmation, giving advise on when the parties get explicit key confirmation which should be assured before the session key is stored long-term.\r\n",
          "createdAt": "2020-11-02T19:24:13Z",
          "updatedAt": "2020-11-02T19:24:13Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2NzA2OTQ5NzQ=",
      "title": "Verification of intended peer",
      "url": "https://github.com/lake-wg/edhoc/issues/8",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "gselander"
      ],
      "labels": [
        "Close?"
      ],
      "body": "Extracted from https://arxiv.org/abs/2007.11427\r\nhttps://www.ietf.org/proceedings/108/slides/slides-108-lake-tamarin-study-of-edhoc-00\r\n\r\n\"Section 3.2 of the specification states that a parties are required to be configured with a policy restricting the set of peers an they are allowed to run EDHOC with.\"\r\n\r\n\"the initiator is not required to verify that the ID CRED R received in message 2 is the same as the one the application intended when initiating the EDHOC run\"\r\n\r\n\"the initiator [need] to match ID CRED R to the intended identity provided by the application\"\r\n\r\n\"the application must be able to instruct EDHOC to not accept the same identity in the next attempt\"\r\n",
      "createdAt": "2020-08-01T09:20:53Z",
      "updatedAt": "2021-09-10T13:48:25Z",
      "closedAt": "2021-09-10T13:48:25Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "When raw public keys are used in EDHOC, EDHOC allows the parties to agree on an optional \u201csubject name\u201d that are included in the MAC/Signature (i.e. not sent on the wire). We would like more input from  people deploying contrained IoT devices and what their operational requirements on identity are. Do they see the public key itself as the identity? Is a subject name available in many or all cases?\r\n\r\nShould the \u201csubject name\u201d in raw public keys be recommended or even mandatory?\r\n",
          "createdAt": "2020-11-06T06:56:31Z",
          "updatedAt": "2020-11-06T06:56:31Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "At least for [rd.link](https://tools.ietf.org/html/draft-amsuess-t2trg-rdlink-01) purposes (which is admittedly just an independent draft right now), an RPK can be a standalone thing to verify, and adding any further identifier (like an EUI-64 picked by the identifying party) that'd needed to be known would just weigh down discovery needlessly. Sure, a subject identifier can be derived from the known RPK, but then what's the value of it. (That is saying nothing against having an agreed-on subject, of course.)",
          "createdAt": "2020-11-16T06:31:36Z",
          "updatedAt": "2020-11-16T06:31:36Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this? There has been quite a lot of work in this area, so the dicussion here seems a bit outdated. If anything remains, it might be better to open a new focused issue.",
          "createdAt": "2021-08-26T16:47:18Z",
          "updatedAt": "2021-08-26T16:47:18Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree. This issue has been considered in more than one way:\r\n\r\nIn 3.5.3: \r\n\"The EDHOC implementation or the application must enforce information\r\n   about the intended endpoint, and in particular whether it is a\r\n   specific identity or a set of identities.\"\r\n\r\nIn 3.5.2:\r\n\"To prevent misbinding attacks in systems where an attacker can\r\n   register public keys without proving knowledge of the private key,\r\n   SIGMA [SIGMA] enforces a MAC to be calculated over the \"identity\".\r\n   EDHOC follows SIGMA by calculating a MAC over the whole credential,\r\n   which in case of a X.509 or C509 certificate includes the \"subject\"\r\n   and \"subjectAltName\" fields, and in the case of CWT or UCCS includes\r\n   the \"sub\" claim, see Section 3.5.3. \"\r\n\r\nIf there are other aspects where verification of intended peer is missing we can open a new issue.\r\n\r\nI close this now.\r\n",
          "createdAt": "2021-09-10T13:48:18Z",
          "updatedAt": "2021-09-10T13:48:18Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU2NzA3MDczMzE=",
      "title": "Caching rejected cipher suites",
      "url": "https://github.com/lake-wg/edhoc/issues/9",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "v-02"
      ],
      "body": "Extracted from https://arxiv.org/abs/2007.11427\r\nhttps://www.ietf.org/proceedings/108/slides/slides-108-lake-tamarin-study-of-edhoc-00\r\n\r\n\"the specification does not describe for how long the initator should remember a rejected cipher suite for a given party. \"\r\n\r\n",
      "createdAt": "2020-08-01T09:38:47Z",
      "updatedAt": "2020-11-02T17:44:14Z",
      "closedAt": "2020-11-02T17:44:14Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU2NzA3MTEyMzE=",
      "title": "Injective agreement issue (was: G_IY in session key material)",
      "url": "https://github.com/lake-wg/edhoc/issues/10",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Extracted from https://arxiv.org/abs/2007.11427\r\nhttps://www.ietf.org/proceedings/108/slides/slides-108-lake-tamarin-study-of-edhoc-00\r\n\r\n\"While we show bidirectional injective agreement on G_X and G_Y for all methods, initiators cannot obtain injective agreement on G_IY when using the STAT method themselves. \"\r\n\r\nThis is a special case of issue #7. ",
      "createdAt": "2020-08-01T09:44:40Z",
      "updatedAt": "2021-04-22T08:39:13Z",
      "closedAt": "2021-04-22T08:39:13Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Key confirmation is obtained with the following OSCORE exchange. An optional fourth EDHOC message is an alternative, see #18.",
          "createdAt": "2020-10-16T11:57:31Z",
          "updatedAt": "2020-11-06T07:04:57Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "More background:\r\nWhile the lack of \u201cinjective agreement\u201d is specific to the static Diffie-Hellman, the lack of explicit key confirmation for the Initiator exists also for the modes when I authenticates with a signature.\r\n\r\ndraft-ietf-lake-edhoc-02 adds text illustrating that while R gets explicit key agreement after verifying message_3, I does not get explicit key agreement until I has verified an OSCORE message from R. The recommendation is to wait with storing the keying material long-term until key confirmation has been assured.",
          "createdAt": "2020-11-06T07:07:23Z",
          "updatedAt": "2020-11-06T07:07:23Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Key confirmation addressed in -06 and earlier versions.",
          "createdAt": "2021-04-22T08:39:13Z",
          "updatedAt": "2021-04-22T08:39:13Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU2NzA3MjAyODI=",
      "title": "Agreement of method",
      "url": "https://github.com/lake-wg/edhoc/issues/11",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 3 of -00 says \"The Initiator and the Responder need to have agreed on a single method to be used for EDHOC.\"\r\n\r\nIs this enough for expected deployments of EDHOC. If not, is an attacker blocking one method to force the use of a second method acceptable or is negotiation/verification of the selected method needed?",
      "createdAt": "2020-08-01T09:57:58Z",
      "updatedAt": "2021-02-21T07:01:15Z",
      "closedAt": "2021-02-21T07:01:14Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "In version -01 this is more appropriately described as:\r\n\r\n\"The Initiator decides on the method parameter, see {{method-types}}. The Responder either accepts or rejects.\"\r\n\r\nThis scheme makes sense for the potentially common setting that the Initiator is a constrained device/device behind constrained network, and the Responder is less constrained.",
          "createdAt": "2020-10-20T06:07:59Z",
          "updatedAt": "2020-10-20T06:07:59Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "This looks good.",
          "createdAt": "2020-11-10T07:24:10Z",
          "updatedAt": "2020-11-10T07:24:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This can be closed now",
          "createdAt": "2021-02-21T07:01:14Z",
          "updatedAt": "2021-02-21T07:01:14Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU2ODgwMTk5NDQ=",
      "title": "Old notation U and V",
      "url": "https://github.com/lake-wg/edhoc/issues/12",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "v-02"
      ],
      "body": "4.2.3 \r\n\"If V does not support the selected cipher suite\"\r\n\r\n7.1 \r\n\"Repudiation: In EDHOC authenticated with signature keys, Party U could theoretically prove that Party V performed a run of the protocol by presenting the private ephemeral key, and vice versa.\"",
      "createdAt": "2020-08-28T11:50:20Z",
      "updatedAt": "2020-10-20T05:23:04Z",
      "closedAt": "2020-10-20T05:23:04Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU2ODgxMDAwMTg=",
      "title": "Clarify encoding in Appendix B",
      "url": "https://github.com/lake-wg/edhoc/issues/13",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "gselander"
      ],
      "labels": [
        "v-02"
      ],
      "body": "Timothy Claeys suggested changes (on page 47):\r\n\r\nOLD\r\nID_CRED_x = { 34 : COSE_CertHash }, for x = I or R, and since the\r\nSHA-2 256-bit Hash truncated to 64-bits is used (value -15):\r\n\r\nNEW\r\nID_CRED_x = { 34 : COSE_CertHash }, for x = I or R. The digest in \r\nCOSE_CertHash is computed by CBOR decoding CRED_R, hashing the certificate \r\nbytes with SHA-2 256-bit and truncating the digest to 64-bits (value -15).\r\n\r\n---\r\n\r\nOLD\r\nCRED_R is the certificate encoded as a byte string:\r\n\r\nNEW\r\nCRED_R is the certificate encoded as a CBOR bstr:\r\n\r\n",
      "createdAt": "2020-08-28T14:05:15Z",
      "updatedAt": "2020-10-20T08:19:00Z",
      "closedAt": "2020-10-20T08:19:00Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm . . . need to trim the text in the first change a bit more, taking into account the preceding sentence.\r\n\r\nOLD\r\n\"And because 'x5t' has value certificate are used, ID_CRED_R is the following:\r\n\r\nID_CRED_x = { 34 : COSE_CertHash }, for x = I or R, and since the SHA-2 256-bit Hash truncated to 64-bits is used (value -15):\"\r\n\r\nPerhaps \r\n\r\nNEW\r\n\"And because 'x5t' is used, ID_CRED_R = { 34 : COSE_CertHash }.\r\n\r\nThe digest in COSE_CertHash is computed by CBOR decoding CRED_R, hashing the certificate\r\nbytes with SHA-2 256-bit and truncating the digest to 64-bits (value -15).\"\r\n\r\n\r\n",
          "createdAt": "2020-10-20T05:17:58Z",
          "updatedAt": "2020-10-20T05:17:58Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@fpalombini: Should we update the appendix directly, or the test vector code?",
          "createdAt": "2020-10-20T05:18:36Z",
          "updatedAt": "2020-10-20T05:18:36Z"
        },
        {
          "author": "fpalombini",
          "authorAssociation": "COLLABORATOR",
          "body": "The test vector code only includes the data, all the text around is added manually, so we can only change that.",
          "createdAt": "2020-10-20T07:56:21Z",
          "updatedAt": "2020-10-20T07:56:21Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU3MzQ2NDg2NzM=",
      "title": "Specify key exchange as KEM?",
      "url": "https://github.com/lake-wg/edhoc/issues/17",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "All new PQC algorithms from NIST is expected to be specified as Key Encapsulation Methods (KEM). Might be a good idea to specify the key exchange in EDHOC so that is is prepared to be used with future KEMs\r\n\r\nInitiator: Generate ephemeral public key PK and send to R\r\nResponder: Use PK use it to encapsulate. Send ciphertext to I\r\nInitiator: Decapsulate\r\n\r\nECDHE can quite easily be specified as a KEM. CFRG HPKE does exactly this.",
      "createdAt": "2020-11-02T16:32:16Z",
      "updatedAt": "2021-01-26T05:15:57Z",
      "closedAt": "2021-01-26T05:15:56Z",
      "comments": [
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "Having a PQC/future safe version framework seems interesting - can this be achieved without extra messages or overhead?",
          "createdAt": "2020-11-13T15:11:07Z",
          "updatedAt": "2020-11-13T15:11:07Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, It can be achieved without extra messages or overhead.\r\n\r\nEDHOC can be specified using the CFRG HPKE functions (using the exact definitions would change implementations):\r\n\t( skX, pkX ) = GenerateKeyPair()\t\t( skX, pkX ) = GenerateKeyPair()\r\n\t( shared_secret, enc ) = Encap( pk ), \t\t( shared_secret, enc ) = AuthEncap(pkR, skS )\r\n\tshared_secret = Decap( enc, sk ), \t\tshared_secret = AuthDecap( skR, pkS )\r\n\r\nECDHE can quite easily be specified as a KEM. CFRG HPKE does exactly this. \r\n\t(sk, pk) = (x, gx)\t(shared_secret, enc) = (gxy, gy)\r\n\r\nSuch a reformulation would very likely work for PQC KEMs when signature authentication. However it seems moore uncertain that future PQC KEMs will they adhere to the CFRG HPKE AuthEncap, AuthDecap interfaces (which would be needed in the static DH authentication). PQC algorithms might require additional precautions when keys are used more than once. In AuthEncap() both pkR, skS would be used more than once.\r\n\r\nIf we are pretty certain the change allow future PQC KEMs can be used, I think the change to KEM is worth doing. If we are uncertain future PQC KEMs will adhere to the interface, the change to KEM might just be confusin to people used to ECDHE.\r\n\r\n\r\n\r\n",
          "createdAt": "2020-11-14T09:30:03Z",
          "updatedAt": "2020-11-14T09:30:03Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "Is the \"EDHOC KEM\" or the CRFG Hybrid function being discussed in COSE?",
          "createdAt": "2020-11-17T07:46:06Z",
          "updatedAt": "2020-11-17T07:46:06Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@pbtgit There was a comment at the IETF 109 WG meeting that any impact on the use of COSE needs to be considered. Was this your concern? We should bring up this for discussion again at the December 18 interim.",
          "createdAt": "2020-12-02T12:58:27Z",
          "updatedAt": "2020-12-02T12:58:27Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "@gselander My comment was more a about potential re-use of COSE definitions/constructions than an actual concern. ",
          "createdAt": "2020-12-02T13:07:13Z",
          "updatedAt": "2020-12-02T13:07:13Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "We tried this in #38, discussed at the interim Dec. 2020 and agreed not to do it.",
          "createdAt": "2021-01-26T05:15:56Z",
          "updatedAt": "2021-01-26T05:15:56Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU3MzQ3NDk1NTY=",
      "title": "Optional message_4 for key confirmation",
      "url": "https://github.com/lake-wg/edhoc/issues/18",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "LAKE interim jan 2021"
      ],
      "body": "The Initiator does not get explicit key confirmation until the Initiator has received a MAC calculated with a key derived from PRK_4x3m and TH_4. One way to get explicit key confirmation is that R sends a OSCORE request or response to I.\r\n\r\nShould EDHOC specify an optional message_4 with the sole purpose to give I explicit key confirmation (Suggestion from Karl Norrman which did a formal verification of EDHOC). The fourth message could be very short and simple\r\n\r\n   message_4 = (\r\n     ? C_I : bstr_identifier,\r\n     CIPHERTEXT_4\r\n   )\r\n\r\nwhere CIPHERTEXT_4 is only a MAC, i.e. length of plaintext == 0\r\n",
      "createdAt": "2020-11-02T19:06:17Z",
      "updatedAt": "2021-04-22T08:40:30Z",
      "closedAt": "2021-04-22T08:40:30Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The Initiator can still send OSCORE messages directly after message_3 has been sent. \r\n\r\nNote that a fourth message might have other benefits than purely cryptographic as discussed previously on the list, e.g., to avoid issues where message_3 is lost or delayed due to unreliable transport. \r\n \r\nAlso note it is proposed that message_3 may as an option be sent in an OSCORE request, see draft-palombini-core-oscore-edhoc\r\n",
          "createdAt": "2020-11-06T07:17:00Z",
          "updatedAt": "2020-11-06T07:17:00Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I think it's good to define Message 4. If defined, I suppose optionality is about sending it, while it has to be supported and understood as for the other messages.\r\n\r\nI agree this has the advantages beyond security mentioned above.\r\n\r\nSince it's optional, one can wonder for how long the Initiator should possibly wait for it before giving up, and possibly start sending application data anyway if it does not care of key confirmation before doing that.\r\n\r\nHow about this kind of signaling?\r\n\r\n1) In Message 2, the Responder can signal that it will send Message 4 later on, as a heads up to the Initiator.\r\n\r\n2) In Message 3, the Initiator can:\r\n\r\n2a) Explicitly request for Message 4 to be sent, if its sending was not anticipated with the signaling in Message 2 (see above); or\r\n\r\n2b) If an upcoming Message 4 was signaled in Message 2 (see above), explicitly tell the Responder to not send Message 4, as not caring to achieve key confirmation before sending application data.",
          "createdAt": "2020-11-10T07:26:18Z",
          "updatedAt": "2020-11-10T07:32:45Z"
        },
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am also in favor of defining a `message 4` which can optionally be requested by the Initiator. \r\n\r\nI don't know if it is useful to provide the ability to the Responder to notify the Initiator in `message 2` that it will send a `message 4`. I am unsure about the advantage of letting the Responder decide to send a` message 4` if the Initiator didn't specifically request it.\r\n\r\nPersonally, I think it makes more sense to append the option to `message 1`, next to the other negotiation parameters, but there might be advantages to attaching the request to `message 3` that I don't know.\r\n\r\n",
          "createdAt": "2020-11-11T12:06:35Z",
          "updatedAt": "2020-11-11T12:07:47Z"
        },
        {
          "author": "eduingles",
          "authorAssociation": "NONE",
          "body": "I don't have strong opposition to adding an optional message 4, but I do not see it necessary. \r\n\r\nSince this WG is looking for an authentication protocol with OSCORE, I opt for solutions such as [draft-palombini-core-oscore-edhoc](https://tools.ietf.org/html/draft-palombini-core-oscore-edhoc-01) instead of including more messages.\r\n\r\nI do not see any practical scenario where that fourth message is really necessary and it is not solved by the following OSCORE message. If there is, I'd love to see it.\r\n\r\nOn the other hand, adding the fourth message implies adding complexity to the process, increasing the packet size and increasing the interaction time. This increases the chances of an error and the need to repeat the authentication process. Therefore, I prefer to avoid giving the option.\r\n\r\nNevertheless, it is interesting to analyze the cost of adding an additional message in networks such as LoRaWAN where an error can be a huge punishment.\r\n\r\nHaving said that, I understand that we are talking about something optional but giving that option could lead to it being widely used in scenarios where it is not necessary and decrease the performance of the protocol.",
          "createdAt": "2020-11-12T12:50:18Z",
          "updatedAt": "2020-11-12T12:50:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Sending message_3 in OSCORE as specified in draft-palombini-core-oscore-edhoc and requiring a response seems to solve all problems for use cases when The EDHOC Initiator is the OSCORE Client.\r\n\r\nWhat about cases when the EDHOC Initiator is the OSCORE Server? ",
          "createdAt": "2020-11-13T17:20:03Z",
          "updatedAt": "2020-11-13T17:20:03Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The case with OSCORE Server being EDHOC Initiator seems less problematic. No actions takes place before the first OSCORE request arrives to the server, and the OSCORE processing hands over the plain text message for CoAP processing only after having verified the MAC and thereby obtained key confirmation.",
          "createdAt": "2020-11-14T10:20:44Z",
          "updatedAt": "2020-11-14T10:20:44Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the problem is not OSCORE processing before the Initiator has gotten \"delivery receipt for message_3  / key confirmation\". The Initiator can e.g. start sending as many OSCORE request as it wants without knowing for sure that the Responder has received and accepted message_3.\r\n\r\nThe only problem as I see it is the the Initator has sent message_3 and then does not receive any OSCORE from the Responder. How long does the Initiator store the keying material? If the Initiator is only a CoAP server it cannot send a OSCORE request to the Responder.",
          "createdAt": "2020-11-14T10:28:46Z",
          "updatedAt": "2020-11-14T10:32:53Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I have not seen any objection to specify message_4 in response to message_3 so we should do that. We should make it optional to implement so it does not add complexity when not needed. \r\n\r\nAttempted processing description:\r\n* It is optional for the Initiator to request key confirmation\r\n* If the Responder receives the signal for key confirmation and supports then it is RECOMMENDED to respond with a message containing a MAC derived from the key\r\nNOTE: If the Initiator requests key confirmation and does not receive a response, the Responder need to be prepared that the Initiator may discontinue the protocol or discard the keys. \r\n\r\nWe need to define the signal for key confirmation, most likely in message_3, whose integrity can be immediately verified.",
          "createdAt": "2021-01-21T08:59:00Z",
          "updatedAt": "2021-01-21T13:36:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I have now added specification of an optional to support message_4 to master. The EDHOC message_4 should be seen as replacement for an protected application leyer message from R to I. The intention is that it is only used when no  protected application leyer messages are sent from R to I.\r\n\r\nAt the last interim it was discussed to signal the need for key confirmation in message_1 or message_3. But when starting to implement this I wonder if that is the right thing to do. message_4 is only needed in some rare cases where no applicaiton data is sent or when application data is only sent in the I to R direction.\r\n\r\nAs this message_4 is a rare case it might be easier to just mandate key confirmation. Key confirmation is achieved by all deployments that send application data from R to I. Might be easier to mandate message_4 for the rare cases when no application data is sent from R to I. Then nothing changes in current implementations.\r\n\r\nAre there any uses cases that do not need key confirmation. I would say no, and even if there is I do not think they are common enough to introduce signaling in message_1 or 3",
          "createdAt": "2021-01-23T11:03:12Z",
          "updatedAt": "2021-01-23T11:03:12Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with the proposal. But how does the Responder know at reception of message_3 that it will later send an application message to the initiator? In case the responder is CoAP server, it requires a request to provide key confirmation in the response, and it does not a priori know if it will recieve a request with protected application data. With draft-palombini-core-oscore-edhoc it will, but this is optional to use. ",
          "createdAt": "2021-01-25T08:58:24Z",
          "updatedAt": "2021-01-25T08:58:45Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we need to define transport of auxiliary data in message_4? This would  only result in rename MAC_4 -> CIPHERTEXT_4, and add AD_4 to plaintext.\r\n",
          "createdAt": "2021-01-25T09:41:28Z",
          "updatedAt": "2021-03-04T06:35:16Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "The Responder would probably have to follow an application policy to decide if it has to send Message_4 or not.\r\n\r\nHowever, strictly while processing Message_3, the Responder may not really know why it is running EDHOC, i.e. for what exact applications. This means that a Responder running multiple applications that rely on EDHOC would need to have a single common policy covering all of them, as to whether to send Message_4 or not.\r\n\r\nAn alternative would be to decide based on the particular identity keys used while running EDHOC. Then different applications (requiring key-confirmation or not) can be associated to different identity keys, and taking a decision about sending Message_4 becomes easy. The price to pay is having multiple identity keys, although just two might suffice.",
          "createdAt": "2021-01-28T15:44:50Z",
          "updatedAt": "2021-01-28T15:44:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "No unified view from the discussion at Hackathon. \r\n\r\nExample of comments:\r\n* An explicit signal is useful\r\n* Handle out of band, e.g. using applicability statement and transport layer messages.",
          "createdAt": "2021-03-02T15:39:32Z",
          "updatedAt": "2021-03-02T15:39:32Z"
        },
        {
          "author": "highlunder",
          "authorAssociation": "NONE",
          "body": "I'm late to the discussion, so maybe I'm missing something. To me, having a well defined option for AD_4-data seems useful for all cases where AD_3-data is used in message3 to piggy-back a request where the initiator expects a reply with content.\r\n\r\nIf not, how are those scenarios meant to be handled?",
          "createdAt": "2021-03-04T08:59:52Z",
          "updatedAt": "2021-03-04T08:59:52Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Included in -06 and earlier versions.",
          "createdAt": "2021-04-22T08:40:30Z",
          "updatedAt": "2021-04-22T08:40:30Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU3MzUwOTk2ODE=",
      "title": "Support of SHAKE and KMAC",
      "url": "https://github.com/lake-wg/edhoc/issues/19",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The COSE WG is working on adding SHAKE128 and SHAKE256 to COSE and there is ongoing work to define the use of KMAC128 the KMAC256 as KDFs.\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-cose-hash-algs\r\nhttps://tools.ietf.org/html/draft-schaad-cose-more-algs\r\n\r\nThere has been interest in the IETF IoT community to use these algorithms. As currently specified, EDHOC supports SHAKE, but would run SHAKE in HMAC mode, which is inefficient. \r\n\r\nShould EDHOC should be updated to use a KMAC KDF together with SHAKE? I.e KMAC128 instead of HMAC-SHAKE128 for Extract and Expand.",
      "createdAt": "2020-11-03T07:52:00Z",
      "updatedAt": "2021-01-23T10:54:17Z",
      "closedAt": "2021-01-23T10:54:17Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "As I understand this, this is an aspect of future-proofing, where the cipher suite would contain one more item, the extract-and-expand-scheme, with currently two potential values: either HMAC or KMAC.",
          "createdAt": "2020-11-05T18:40:26Z",
          "updatedAt": "2020-11-05T18:40:26Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "No strong opinion but it seems to make sense to go for the more efficient combination with KMAC. ",
          "createdAt": "2020-11-10T13:04:17Z",
          "updatedAt": "2020-11-10T13:04:17Z"
        },
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I seems like the current hardware acceleration for hashing in constrained devices is limited to SHA-2 implementations [1][2]. I also think it is preferable to go for the more efficient KMAC extension, unless a software implementation of KMAC-SHAKE128 would require substantially more flash than HMAC-SHAKE128.\r\n\r\n1: [https://infocenter.nordicsemi.com/index.jsp?topic=%2Fps_nrf52840%2Fkeyfeatures_html5.html](https://infocenter.nordicsemi.com/index.jsp?topic=%2Fps_nrf52840%2Fkeyfeatures_html5.html)\r\n2: [https://www.ti.com/lit/ug/swru319c/swru319c.pdf?ts=1605020127382](https://www.ti.com/lit/ug/swru319c/swru319c.pdf?ts=1605020127382)",
          "createdAt": "2020-11-10T16:22:37Z",
          "updatedAt": "2020-11-16T05:44:35Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "KMAC is basically SHAKE so if an implementation has SHAKE, they more or less have KMAC. KMAC is a thin shim layer.",
          "createdAt": "2020-11-27T09:40:21Z",
          "updatedAt": "2020-11-27T09:40:21Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The agreed KMAC change is now added to Master.\r\n\r\nThe change to the specification is quite small. EDHOC is now defined in terms of Extract and Expand instead of HKDF-Extract and HKDF-Expand. When SHA-2 is used then HKDF-Extract/HKDF-Expand is used. When SHAKE is used then KMAC is used.\r\n\r\nThe change does not affect current implementations. \r\n\r\nBTW the title of this issue is misleading. SHAKE is supported like all COSE algorithms. We are not planning to define a cipher suite at this moment but SHAKE can be used with private cipher suites.",
          "createdAt": "2020-11-27T09:44:26Z",
          "updatedAt": "2020-11-27T09:44:26Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "When SHAKE is used (currently this can only be done with a private cipher suite) then KMAC is used. This behavior is specified in -03 and has been discussed at the two last interims",
          "createdAt": "2021-01-23T10:54:17Z",
          "updatedAt": "2021-01-23T10:54:17Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3MzUwOTk5ODU=",
      "title": "Rekeying of AEAD algorithms",
      "url": "https://github.com/lake-wg/edhoc/issues/20",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The TLS WG have analyzed, discussed, and specified bounds for distinguishing and forgery attacks on various AEAD algorithms in TLS. The distinguishing attack lets an attacker destringing the ciphertext from a random string and the forgery attack lets an attacks forge a single message (typically consisting of a random looking string). CFRG is now planning to publish a document with formulas to calculate AEAD limits. The limits chosen by TLS are stricter that any earlier protocol or specification. This is fine if rekeying is easy.\r\n\r\nIt would be good if the IETF IoT community discussed which probability is acceptable for the IoT protocols in IETF. \r\n\r\nEDHOC does not use the same key more than once, but the exported session key might be used for a long period in e.g. OSCORE. The most efficient solution may be to rekey in the application security protocol. E.g. if OSCORE would frequently derive a new Sender/Recipient Key from the Master Key, this would effectively mitigate distinguishing attacks. See e.g. \"key_derivation_rate\" in SRTP (RFC 3711). This is not currently part of OSCORE but could quite easily be added in a backward compatible way.\r\n\r\nWhat is the acceptable probability for IoT? How do we do this rekeying for OSCORE? Do we need to do anything in EDHOC at all?",
      "createdAt": "2020-11-03T07:52:37Z",
      "updatedAt": "2021-04-22T08:36:52Z",
      "closedAt": "2021-04-22T08:36:52Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "OSCORE sequence numbers allow synchronized rekeying at regular intervals. The \"key_derivation_rate\" needs to be known, either alg-dependent or set by the application, but there could be a default value, e.g., corresponding to AES_128_CCM_8. \r\n ",
          "createdAt": "2020-11-06T06:35:22Z",
          "updatedAt": "2020-11-06T06:35:22Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "How many usable messages are we talking about?\r\n\r\nAfter skimming DTLS1.3, it sounds to me that it's about 2^23 messages. If that's the order of magnitude we're talking about, I'd practically do nothing at all but flag a security context as exhausted at reaching 2^23 rather than reading 2^40 with a per-algorithm limit, or just the worst-case limit for the supported algorithm. Any mechanism that's added would need to justify how it amortizes the additional code size in firmware updates over running an EDHOC continuation run every 2^23 messages.\r\n\r\nIf, of course, the sequence number space is limited to something to less than 2^14, something might need to be done.\r\n\r\n[edit: And frankly I'd be glad to fit my sender sequence numbers and replay window low water mark in uint32_t ;-) ]",
          "createdAt": "2020-11-09T15:28:30Z",
          "updatedAt": "2020-11-09T15:29:39Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, 2^23 is the number we have seen for DTLS 1.3 and which can serve as a first estimate also for OSCORE. (The setting is slightly different though, related to \"what is the acceptable probability for IoT?\" which is likely going in one direction, and the use of AAD with the AEAD, which goes in the opposite direction.)\r\n\r\nDid I understand the comment right, that another asymmetric EDHOC run after ~ 2^20 messages is not an issue?\r\n\r\nAbout \"additional code size in firmware updates\": The mechanism we are talking about could be a derivation of a new master secret every  \"key_derivation_rate\" message. That would probably not have a huge impact in OSCORE code size. But it would be an update to OSCORE.\r\n\r\nEdit: Here is an example of addition to OSCORE:\r\nhttps://mailarchive.ietf.org/arch/msg/lake/5DAmN2c7cOXCUej-4XRHxa18MIQ/\r\n",
          "createdAt": "2020-11-09T15:52:40Z",
          "updatedAt": "2020-11-10T14:42:04Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "At least not in terms of energy consumption. Even if an EDHOC exchange has 1000x the energy cost of a regular message, that's still only 0.1% in total change. (Admittedly that number is out of thin air, looking for better ones).\r\n\r\nIt may be an issue for devices that previously would have gotten away with being sure to never run out of sequence numbers but now can, though :-/",
          "createdAt": "2020-11-09T16:08:47Z",
          "updatedAt": "2020-11-09T16:08:47Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Overall, this sounds like something better to do in OSCORE.",
          "createdAt": "2020-11-10T07:23:48Z",
          "updatedAt": "2020-11-10T07:23:48Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in CoRE. No comment on the key-update function so far, make a new issue if necessary.",
          "createdAt": "2021-04-22T08:36:52Z",
          "updatedAt": "2021-04-22T08:36:52Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3MzUxMDM5Njc=",
      "title": "Use of SHA-512 in constrained IoT.",
      "url": "https://github.com/lake-wg/edhoc/issues/21",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "SHA-512 is not supported on many IoT devices and the question is if it ever will. Currently SHA-256 have wide support and is often HW accelerated. Adding also SHA-512 requires more code storage. If SHA-256 gets replaces it would likely be with SHAKE128 or some future XOF emerging from the NIST lightweight standardization protect (e.g. Gimli).\r\n\r\nEd25519 is currently only specified with SHA-512. While there are benefits of having a single algorithm, CFRG should maybe have taken IoT more into consideration. Specifying Ed25519 with another hash algorithm is technically easy, but would mean even less implementations.\r\n\r\nIt has been suggested that draft-ietf-lwig-curve-representations-05 and W-25519 from Draft NIST SP 800-186 would solve this problem. As far as we know, they only helps with implementing X25519 and Ed25519 on devices which only has acceleration of Weierstrass curves. They do not affect the hash function in any way. We plan to add references to draft-ietf-lwig-curve-representations-05 and W-25519 with the text that they may help with HW acceleration.\r\n\r\nIs the use of SHA-512 in Ed25519 a problem?",
      "createdAt": "2020-11-03T08:00:23Z",
      "updatedAt": "2021-01-26T05:30:20Z",
      "closedAt": "2021-01-26T05:30:20Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Ed25519 has several benefits, including performance, which makes it very well suited for a constrained setting, but supporting multiple hash functions is an issue. The bundling of Ed25519 and SHA-512 makes the threshold for changing to Ed25519 high. Bundling Ed25519 with another even less common secure hash function does not make this easier.\r\n\r\nEither we accept that constrained devices for a long time to come (also considering life time of the device) will not be able to make use of the widely accepted upcoming signature algorithm, or we need to make the transition easier. \r\n\r\nIt has been discussed before, but perhaps we have now better arguments for the case of Ed25519 with SHA-256? Although it is far from ideal to specify multiple variants, the difference between Ed25519/SHA-512 and Ed25519/SHA-256 is very small. The implementation effort for extending support from the first to the second is small, and the change is only needed in those servers that communicates with constrained devices. Supporting the two SHA algorithms is no issue on the non-constrained side.\r\n\r\nShall we propose to CFRG to specify Ed25519 with SHA-256?\r\nWould Ed25519 with SHA-256 be deployed by IoT industry?\r\n\r\n\r\n ",
          "createdAt": "2020-11-05T09:21:46Z",
          "updatedAt": "2020-11-05T18:30:13Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Copying from Ilari's recent email to LWIG/COSE:\r\n\r\n\"And some notes about making version of Ed25519 that uses SHA-256:\r\n\r\n- The Ed25519 subkey derivation needs to be split into two hashes\r\n  instead of running once and splitting the result. The input fits into\r\n  one block anyway, so it will still be fast. For example,\r\n  a=SHA256(0|k_priv) and seed=SHA256(1|k_priv).\r\n- It is not trivially possible to replace the inner hash SHA512(seed|M)\r\n  with SHA256(seed|M). However, it turns out that the order in fact\r\n  does allow this replacement.\r\n- If one wants noisy signatures, one way is to replace SHA256(seed|M)\r\n  with SHA256(seed|M)^noise. The noise must be independent of the\r\n  private key and seed, but otherwise bad noise (including completely\r\n  broken one) will not cause immediate catastrophic failure.\r\n- If one wants randomized signatures, due to the same reasons as why\r\n  the inner hash may be replaced, it is recommended to generate more\r\n  randomness than 256 bits, and then use SHA256 to squash it to 256\r\n  bits. This hedges against not-quite-ideal random number generators\r\n  that would otherwise cause catastrophic failure. However, it will\r\n  not prevent broken random number generator from causing immediate\r\n  catastrophic failure.\r\n- The outer hash SHA512(R|A|M) can trivially be replaced by\r\n  SHA256(R|A|M).\"\r\n\r\nThe mail also has some details about qDSA:\r\nhttps://mailarchive.ietf.org/arch/msg/cose/3WATdZGKvprM7qCZ_axVccvfYzU/\r\n",
          "createdAt": "2020-11-09T20:17:49Z",
          "updatedAt": "2020-11-09T20:17:49Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "It would be good to have metrics comparing SHA-512 in terms of code size, message size and computations:\r\nTo my knowledge SHA-512 can be accelerated using NEON extension of ARM. Message size is still highly relevant though. \r\n",
          "createdAt": "2020-11-10T13:18:54Z",
          "updatedAt": "2020-11-10T13:18:54Z"
        },
        {
          "author": "eduingles",
          "authorAssociation": "NONE",
          "body": "My concern is with the constrained devices that are close to the minimum requirements for running EDHOC. I would not switch to SHA-512 at this time without the support of the manufacturers. Using alternatives that are not HW accelerated I believe would considerably reduce the use of EDHOC on those devices. Even nrf52840 does not support SHA-512 by hardware either although it supports Ed25519 (https://infocenter.nordicsemi.com/pdf/nRF52840_PS_v1.1.pdf). Therefore, I am in favour of keeping SHA-256 if this implies that the devices can take advantage of the hardware modules and avoid doing it by software.\r\n\r\nOn the other hand, in line with #22 , I would pose the same question. What kind of devices should be supported in EDHOC?",
          "createdAt": "2020-11-12T12:52:39Z",
          "updatedAt": "2020-11-12T12:52:39Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-256-only implementations are supported as of 70088cc.",
          "createdAt": "2021-01-26T05:30:20Z",
          "updatedAt": "2021-01-26T05:30:20Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU3MzY4Mjg5NjY=",
      "title": "Mandatory to implement cipher suite",
      "url": "https://github.com/lake-wg/edhoc/issues/22",
      "state": "OPEN",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Considering the potential long deployment times for these device it seemed prudent to require a cipher suite based on Curve25519 (cipher suite no. 0).\r\n\r\nEdDSA (and to a smaller degree X25519) does not have as many IoT implementations as ES256 and P-256, but draft-ietf-lwig-curve-representations-05 and W-25519 is suggested to provide a work-around for implementing X25519 and Ed25519 on devices which only has acceleration of Weierstrass curves.\r\n\r\nStill remain the issues with SHA-512 (see #21) and with supporting multiple SHA algorithms (#2).\r\n\r\nOptions:\r\n\r\n1. Change MTI cipher suite to one based on ECDSA, e.g., no. 2. This has negative consequences on performance and security, which will remain for long time.\r\n\r\n2. Keep MTI cipher suite 0. This may mean accept that some devices will not implement MTI cipher suite. This is beyond the control of the specification and has a number of issues.\r\n\r\n3. Define a MTI cipher suite using Curve25519 which has the potential to be widely implemented, e.g., based on a TBD Ed25519 with SHA-256 (see #21). This requires a specification, but would be possible to implement with legacy Weierstrass curve computations and hash algorithm.\r\n\r\n\r\n",
      "createdAt": "2020-11-05T10:55:22Z",
      "updatedAt": "2021-07-16T08:27:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I tend to prefer Option 2 as to what is MTI. The uncertainty on deploying Option 3 might be even larger than for Option 2.\r\n\r\nThe Group OSCORE document [1] also indicates Ed25519 as MTI. The outcome of this discussion will likely affect Group OSCORE, as better to have the same MTI signature algorithm of EDHOC. Thinking of devices that use EDHOC and OSCORE on one hand, and Group OSCORE on the other hand, having a single signature algorithm implemented would be clearly preferable if not unavoidable.\r\n\r\nJust for information, see the nRF52840 DK [2] equipped with the CryptoCell CC310 accelerator [3] and providing HW acceleration for Ed25519.\r\n\r\n\r\n[1] https://datatracker.ietf.org/doc/draft-ietf-core-oscore-groupcomm/\r\n\r\n[2] https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/nRF52840-DK-product-brief.pdf?la=en&hash=5D78D8104D4FC04D539BDBACFBB5150F34487447\r\n\r\n[3] https://infocenter.nordicsemi.com/index.jsp?topic=%2Fps_nrf9160%2Fcryptocell.html",
          "createdAt": "2020-11-10T07:22:47Z",
          "updatedAt": "2020-11-10T07:22:47Z"
        },
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to prefer option 3. I think option 1 is not preferable because of the long term impact it would have. \r\n\r\nConcerning the deployment issues of option 3, one aspect we can consider is that upcoming devices (like the nRF52840) will have all the hardware building blocks to fully accelerate Ed25519 with SHA256. The ARM cryptocell has hardware acceleration for SHA-2, but only up to 256 [1]. I am not aware of old or new constrained devices with hardware acceleration for SHA-512.\r\n\r\n1: [https://developer.arm.com/ip-products/security-ip/cryptocell-300-family](https://developer.arm.com/ip-products/security-ip/cryptocell-300-family) ",
          "createdAt": "2020-11-10T17:16:23Z",
          "updatedAt": "2020-11-10T17:18:06Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "The documentation of the cryptocell (eg. [in the nrf52840 docs](https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcomp_matrix_nrf52840%2FCOMP%2Fnrf52840%2FnRF52840_doc_ref_design_files_overview.html)) is confusing to me. It states that it has acceleration for SHA up to 256, and that it supports Ed25519 (and the document it cites for it is the original Ed25519 one that puts SHA-512 in the example).\r\n\r\nHas anyone outside the hardware builders specified Ed25519 with SHA-256 anywhere so far? If so, option 3 might be a lot faster in that it could be as simple as allocating COSE identifiers for that specified algorithm combination, but it'd at least need a specification.\r\n\r\n---\r\n\r\nFrom the point of view of implementing this in anything but the most constrained devices, going with 3 would make things a bit harder: Support for Ed25519 as in [RFC8032](https://tools.ietf.org/html/rfc8032) is widely available, but for the 256 version not so, and even if right now someone would produce a published RFC about Ed25519-SHA256 *and* people like the OpenSSL maintainers started adding it, it'd still take considerable time to be available on widespread systems. Having an existing specification out there, even if it's as short as an application note, may help getting a head start there as it could justify starting work on the additions in the widespread libraries.",
          "createdAt": "2020-11-10T17:33:36Z",
          "updatedAt": "2020-11-10T17:33:36Z"
        },
        {
          "author": "eduingles",
          "authorAssociation": "NONE",
          "body": "I am aware of the security issues and would like to support option 2. However, I must go for option 1. Forcing cipher suites with Ed25519 would make it difficult to use EDHOC on Cortex M3 like devices. For example, Openmote B and Zolertia Firefly with the CC2538 microchip can run P-256 in hardware while the studies of Ed25519 on Cortex M3 devices mention issues in its execution. \r\n\r\nI consider that denying the use of P-256 establishes an important red line that would leave many devices out. Also, the arguments here should be consistent with issue #21 on SHA-512. And since it would mark the future of the protocol, I would raise a question. Will EDHOC be an IoT protocol designed for constrained devices with P-256 or EDHOC will be for not so constrained devices?",
          "createdAt": "2020-11-12T12:44:39Z",
          "updatedAt": "2020-11-12T12:44:39Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "First of all, it is acknowledged that it may be an issue to support Ed25519 and this the reason why we have the discussion about whether the MTI algorithms really should be mandatory to implement in the most constrained settings, which definitely are the target for EDHOC.\r\n\r\nSecond, one reason for ECC based on Curve25519 is superior performance, which should be good news for constrained IoT, once available.\r\n\r\nThird, if Curve25519 based crypto is not available then those devices will have to settle for P-256, or for mapping Curve25519 to Weierstrass coordinates (draft-ietf-lwig-curve-representations). The specification needs to provide guidance here. But we don't want to prevent encourage the move to what is expected to be better and more performant algorithms.\r\n\r\n@eduingles Could you please provide a reference to issues of using Ed25519 you mention? Assuming Ed25519 is specified with SHA-256 (option 3), does that help or what additional/remaining issues do you see? Thanks!\r\n",
          "createdAt": "2020-11-13T11:11:58Z",
          "updatedAt": "2020-11-13T11:57:21Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "If it turns out that both the specified curves have flaws that implementors may consider insurmountable for their deployments, and that option 3 is harder than just putting an entry in the registry pointing to whoever already specified it,\r\n\r\nwould it be an option to, rather than making one MTI, state that there are currently no suitable algorithms to make MTI, and instead it is recommended that implementations provide both 1 and 2 if they can (otherwise, either of them) until a universally suitable curve is specified (which is then invited to update this document to make it MTI)?",
          "createdAt": "2020-11-13T14:01:19Z",
          "updatedAt": "2020-11-13T14:01:19Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Implement proposal discussed in latest interim meeting. ",
          "createdAt": "2021-01-21T09:00:04Z",
          "updatedAt": "2021-01-21T09:00:04Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I reopened this issue following the discussion of MTI cipher suite at the LAKE interim Jan 2021. \r\n\r\nRecap: Following the discussion above and at the LAKE interim Dec 2020 (minutes:\r\nhttps://datatracker.ietf.org/meeting/interim-2020-lake-04/materials/minutes-interim-2020-lake-04-202012181600-00)\r\nwe formulated the following recommendation in EDHOC-04:\r\n\r\n\"To enable as much interoperability as we can\r\n  reasonably achieve, less constrained devices SHOULD implement\r\n  both cipher suite 0 (AES-CCM-16-64-128, SHA-256, X25519, \r\n  EdDSA, Ed25519, AES-CCM-16-64-128, SHA-256) \r\n  and cipher suite 2 (AES-CCM-16-64-128, SHA-256, P-256, \r\n  ES256, P-256, AES-CCM-16-64-128, SHA-256).\r\n  Constrained endpoints SHOULD implement cipher suite 0 or cipher\r\n  suite 2.\"\r\n\r\nPlease consider the arguments leading up to this formulation when proposing a change.",
          "createdAt": "2021-02-02T10:43:44Z",
          "updatedAt": "2021-02-02T10:43:44Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would like to understand better the pitfalls of Option 1:\r\n\r\n> This has negative consequences on performance and security, which will remain for long time.\r\n\r\nPerformanse-wise, the indicators we care about are:\r\na) processing time\r\nb) code footprint\r\nc) messaage overhead\r\n\r\nIn terms of (a), a software implementation of Ed25519 seems to be favored over ECDSA. From John's slides at [1], I gather that bad number of ECDSA have been due to unoptimized implementations of P-256 and that on some platforms ECDSA and Ed25519 have \"equal performance\". More importantly, the state-of-the-art constrained devices have dominantly ECDSA hardware accelerators. If we are to optimize for the constrained side, as we usually do, this indicator favors ECDSA. Since we are talking about hardware, this is expected to remain for at least the next 5-10 years, considering what is already deployed. \r\n\r\nIn terms of (b), an implementation of EdDSA requires SHA-512, in addition to SHA-256 that is needed by EDHOC, so two hash functions. Again, constrained devices have dominantly SHA-256 acceleration, without clear plans on adding SHA-512 to the mix. Code footprint favors ECDSA.\r\n\r\nIn terms of (c), there is no difference.\r\n\r\nMy conclusion from (a), (b) and (c) is that the argument on the negative impact of ECDSA on performance in constrained devices does not hold and that ECDSA is in fact favored performance-wise.\r\n\r\nSecurity-wise, Ed25519 is favored. There have been speculations on the possible backdoors in the NIST P-256 curve. As far as I am aware, these are still considered speculations. The problem are the attacks on the signature algorithm, ECDSA. A notable example is Minerva [1], an implementation attack. What are the other attacks on ECDSA we should take into consideration? Do these attacks affect the hardware-accelerated implementations in constrained devices we are targeting?\r\n\r\n[1] https://datatracker.ietf.org/meeting/interim-2020-lake-04/materials/slides-interim-2020-lake-04-sessa-edhoc-issues-after-03-00 (slide 15)\r\n[2] https://minerva.crocs.fi.muni.cz",
          "createdAt": "2021-02-26T10:59:54Z",
          "updatedAt": "2021-03-02T11:23:56Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "People may have missed that @emanjon provided input to this issue in \r\nhttps://mailarchive.ietf.org/arch/msg/lake/75nRaD6czYG6RqLT06Qe8C_lsaM/\r\n\r\n@malishav:  Would you like to comment on this input, either here or on the mailing list? \r\nCan we narrow down the remaining concerns?",
          "createdAt": "2021-07-15T19:52:35Z",
          "updatedAt": "2021-07-15T19:52:35Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gselander I think that @emanjon 's mail summarizes nicely the data points that we should take into account to make a decision. From that email, I concurred with his suggestion to delay the decision on this as late as possible, when other issues are closed. Should we have the consensus call at the IETF 111 meeting?",
          "createdAt": "2021-07-16T08:27:42Z",
          "updatedAt": "2021-07-16T08:27:42Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3Mzc1MjAxNDM=",
      "title": "Agreement/negotiation of parameters/options",
      "url": "https://github.com/lake-wg/edhoc/issues/23",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "EDHOC has parameters/options that are set in different ways. Agreeing beforehand reduces flexibility. Negotiation might increase message sizes and roundtrips. Letting each party chose parameters in the protocol run allows an on-path attacker to block parameters that can be seen from the message size, and may affect availability as the parties may not support the same COSE options. \r\n \r\nParameters agreed beforehand:\r\n- Method (see #11)\r\n- Transport and Correlation\r\n- Use and format of AD_1, AD_2, AD_3\r\n \r\n(If a parameter not agreed beforehand is received the protocol can be discontinued, see #11 )\r\n\r\nParameters negotiated/verified:\r\n- Cipher suite\r\n \r\nChosen by each party (no current requirement and agreement beforehand):\r\n- Raw public key OR certificate: CRED_R and CRED_I\r\n- Type of credential identifier: ID_CRED_R and ID_CRED_I\r\n\r\nShould agreement/negotiation of any of the parameters be changed?\r\n",
      "createdAt": "2020-11-06T06:52:16Z",
      "updatedAt": "2021-02-21T10:32:16Z",
      "closedAt": "2021-02-21T10:32:16Z",
      "comments": [
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "This current way looks good.",
          "createdAt": "2020-11-10T07:24:00Z",
          "updatedAt": "2020-11-10T07:24:00Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "COLLABORATOR",
          "body": "My suggestion is to add an appendix with some explanatory/example applicability text that collects all the things that need to be agreed beforehand.\r\n",
          "createdAt": "2020-11-16T05:19:09Z",
          "updatedAt": "2020-11-16T05:19:09Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "There seems to be WG consensus for the high level approach. An appendix has been added that summarized the informaiton. Any further comments on the specific content of the appendix should be filed as a new issue or PR.",
          "createdAt": "2021-02-21T10:32:16Z",
          "updatedAt": "2021-02-21T10:32:16Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU3Mzc1NTA4ODc=",
      "title": "Forward and backward secrecy",
      "url": "https://github.com/lake-wg/edhoc/issues/24",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The currently best practice for IPsec is to do a new ECDHE every few hours or after a certain amount of data has been sent. Constrained IoT are not expected to run ECDHE every few hours, but can probably do better that today when many IoT deployments today use the same session key for 10 years. Perhaps every month or every year?\r\n\r\nFrequent ECDHE achieves:\r\n* An attacker having compromised R or I needs to be active to get the session key.\r\n* An attacker gaining a session key can only use it for a limited period of time forward and backward in time.\r\n\r\nIs rerunning EDHOC efficient enough?\r\n\r\nSuggestion by Karthik on the list to PSK-FS by exchanging nonces without DHE and then hash with sequence numbers / previous state. This can likely be done much more efficient with an update to OSCORE, and should be considered in the context of #20.\r\n\r\nIs there a need for an \"intermediate\" protocol component that provides both forward and backward secrecy but is more lightweight than the 3-pass PSK-ECDHE which was removed?\r\n\r\n",
      "createdAt": "2020-11-06T07:52:30Z",
      "updatedAt": "2021-04-22T08:42:07Z",
      "closedAt": "2021-04-22T08:42:07Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "In light of #20 we discussed running OSCORE B.2 during the hackathon. If it were to be used, it'd be good to have it more formalized, and include analysis of when it can run tacked on existing exchanges (possibly like B.1.2 can run without added roundtrips when the requested resource is safe).\r\n\r\nThe points there about amortization may be less applicable here as we're talking about time limits and not message limits. Still, it'd be good to get a sense for the orders of magnitude we're aiming for here. If this is done every other month and needs a single round-trip of 200 byte each in EDHOC, and firmware is updated once a year, then any mechanism added needs to fit within 2\\*200\\*6~=2KB to be worth it.\r\n\r\n[edit: Markdown is lacking automatic math mode]\r\n\r\n[edit2: Maybe that comment missed the point; hackathon discussion just running]",
          "createdAt": "2020-11-09T15:54:10Z",
          "updatedAt": "2020-11-09T16:38:02Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "It may help what kind of intermediate protocol component we're talking about here. My impression is that protocols that are static only come to LAKE to do the asymmetrical work, which is what gets them PFS. What would an intermediate protocol be other than LAKE with some preshared stuff?",
          "createdAt": "2020-11-09T17:20:04Z",
          "updatedAt": "2020-11-09T17:20:04Z"
        },
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "I am also very interested in the balance of Appendix B.2 vs re-running EDHOC.",
          "createdAt": "2020-11-10T13:14:01Z",
          "updatedAt": "2020-11-10T13:14:01Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@chrysn @pbtgit \r\nAs I see it the main question is how often it is needed to rekey for obtaining backward secrecy, i.e. secrecy of future sessions in the event of a temporary compromise enabling the use long term secrets. \r\n\r\n(The currently defined EDHOC methods or an addition to OSCORE (#20) can provide forward secrecy -- Appendix B.2 does not. The currently defined EDHOC methods or an additional CoAP Echo provides freshness.)\r\n\r\nFor backward secrecy a DH exchange is necessary, and appropriate use of the shared secret. This could potentially be a symmetric key authenticated two pass DH exchange with message sizes comparable to static DH, but computationally more lightweight.\r\n\r\n\r\nEdit: Ratcheting is one example, see \r\nhttps://www.signal.org/blog/advanced-ratcheting/",
          "createdAt": "2020-11-10T16:31:45Z",
          "updatedAt": "2020-11-11T07:58:13Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "* Discussed at LAKE interim Dec. 2020.\r\n* Minutes: \"Working assumption is either do full EDHOC exchange, or hash-based forward secrecy which requires no asymmetric operations. No formal ratcheting.\" \r\n* https://datatracker.ietf.org/doc/minutes-interim-2020-lake-04-202012181600/\r\n* Version -03 and later defines an EDHOC-Rekey-...-FS() interface.",
          "createdAt": "2021-01-26T20:54:50Z",
          "updatedAt": "2021-01-26T20:54:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Working assumption seems to hold. No additional issues has been raised.",
          "createdAt": "2021-04-22T08:42:07Z",
          "updatedAt": "2021-04-22T08:42:07Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU3Mzc1NTM4NTg=",
      "title": "Need for resumption procedure?",
      "url": "https://github.com/lake-wg/edhoc/issues/25",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resumption lets endpoints close connections and only store a small amount of state. Resumption can then be performed more efficiently than a full initial handshake, which is very useful on the web. IoT devices typically have a few long connections and the work of doing a resumption may be heavier that keeping the connection open. \r\n\r\nResumption provides other benefits like re-keying and a new authentication which guarantees that messages are fresh. However, those things can be achieved much more efficiently with re-keying inside OSCORE (see #20) and the use of the CoAP Echo option (draft-ietf-core-echo-request-tag).\r\n\r\nIs there any need for a resumption mechanism in EDHOC?\r\n",
      "createdAt": "2020-11-06T07:58:10Z",
      "updatedAt": "2021-01-23T10:52:42Z",
      "closedAt": "2021-01-23T10:52:42Z",
      "comments": [
        {
          "author": "pbtgit",
          "authorAssociation": "NONE",
          "body": "For EDHOC/OSCORE the case for re-keying seems stronger than the case for resumption. \r\nOr at least, the re-keying is a problem for OSCORE to solve rather than EDHOC.",
          "createdAt": "2020-11-10T13:08:26Z",
          "updatedAt": "2020-11-10T13:08:26Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been borught up at the LAKE interim meetings without anybody expressing the wish for resumption. ",
          "createdAt": "2021-01-23T10:52:42Z",
          "updatedAt": "2021-01-23T10:52:42Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3NDA2NDExMjg=",
      "title": "Compact encryption of identity",
      "url": "https://github.com/lake-wg/edhoc/issues/26",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current specification uses XOR with a HMAC-derived key stream for encryption of identity, which saves message overhead compared with encryption with a MAC. Are we happy with this or should we replace with some other construction?\r\n\r\n ",
      "createdAt": "2020-11-11T10:09:24Z",
      "updatedAt": "2020-11-14T13:01:01Z",
      "closedAt": "2020-11-14T13:01:01Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #34",
          "createdAt": "2020-11-14T13:01:00Z",
          "updatedAt": "2020-11-14T13:01:00Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU3NDA5MzEyMDg=",
      "title": "Understanding \"selected cipher suite\"",
      "url": "https://github.com/lake-wg/edhoc/issues/28",
      "state": "CLOSED",
      "author": "StefanHri",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In message 1 a CBOR array containing the supported cipher suites is sent.\r\nThe document says \"One of the supported cipher suites is selected.\" \r\nHow is this indicated? Is the selected suite the first in the array? If so it may make sense to write something like:\r\n\"One of the supported cipher suites is selected. The selected suite is the first suite in the SUITES_I CBOR array\"",
      "createdAt": "2020-11-11T17:12:59Z",
      "updatedAt": "2020-11-15T07:24:25Z",
      "closedAt": "2020-11-15T07:24:25Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "See commit 1f853ac. \r\n@StefanHri Please close the issue after checking.",
          "createdAt": "2020-11-14T11:03:57Z",
          "updatedAt": "2020-11-14T11:03:57Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "> See commit [1f853ac](https://github.com/lake-wg/edhoc/commit/1f853ac3dd5590ae1de2132c21812f4ef3807f18).\r\n> @StefanHri Please close the issue after checking.\r\n\r\n@gselander: I think that's the wrong commit link?",
          "createdAt": "2020-11-14T12:28:28Z",
          "updatedAt": "2020-11-14T12:28:28Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\n\r\n> > See commit [1f853ac](https://github.com/lake-wg/edhoc/commit/1f853ac3dd5590ae1de2132c21812f4ef3807f18).\r\n> > @StefanHri Please close the issue after checking.\r\n> \r\n> @gselander: I think that's the wrong commit link?\r\n\r\n@StefanHri Right, sorry, should be 820fc1d",
          "createdAt": "2020-11-14T12:34:39Z",
          "updatedAt": "2020-11-14T12:34:39Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU3NDA5Mzc4NTE=",
      "title": "Why it is required to send a list of cipher suites in message 1? Why it is not enough to send only the selected suite?",
      "url": "https://github.com/lake-wg/edhoc/issues/29",
      "state": "CLOSED",
      "author": "StefanHri",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In section 5.1.1.  Example Use of EDHOC Error Message with SUITES_R: \r\n\r\n* the Initiator sends SUITES_I = [5,5,6,7]. The selected suite is 5. \r\n* The responder supports only suite 6 -> the selected suite 5 is not supported \r\n* the responder sends error msg containing  SUITES_R = 6. \r\n* The information that suites 5,6,7 are supported by the initiator is not used ->\r\n\r\n  Is it not enough to only send SUITES_I = 5?\r\n\r\n  I know it is possible to truncate SUITES_I, but is it not better when the initiator sends the selected suite? Then if the responder does not support this suite it can answer with a list of suites? ",
      "createdAt": "2020-11-11T17:22:46Z",
      "updatedAt": "2020-12-16T12:35:14Z",
      "closedAt": "2020-12-16T12:35:14Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, it is enough to only send SUITES_I = 5, and the responder can answer with a list of suites. That is a different example, similar to the second example.\r\n\r\nIn the first example it is illustrated that the Initiator tells the Responder that it supports 5,6,7 and that it proposes to use 5. The initiator could in this case have sent just 5, that would have been a different example. Some of the illustrations intended with this example is to show a) that the Initiator can inform the Responder about suites it supports, b) that the Initiator can support more suites than it sends, and c) an example of the second message from the Initiator [6,5,6] which protects against downgrade attacks since it repeats all information about more preferred suites.\r\n\r\nIn the second example, the proposed suites by the Initiator are disjoint from those proposed by the Responder, which is addressing your second point. Again the suites of the first message are repeated in the second message and the selected is added. Given that the supported suites are the same in the first and second example, but the initiator is showing different suites in message_1 in the two examples, we thought it would be clear that yet other variants are possible, including only showing one suite, which would then be the selected suite. Can we make the examples more clear? ",
          "createdAt": "2020-11-14T11:26:22Z",
          "updatedAt": "2020-11-14T11:26:22Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "I am missing a top-level explanation of the procedure and its rationale. \r\nWhich use cases we are trying to cover?\r\n\r\nWhy it is not enough to say: the initiator selects a cipher suite and sends it to the responder. The responder either accepts or sends its list. In the latter case, the initiator selects from the received list a new preferred suite.",
          "createdAt": "2020-11-15T07:58:06Z",
          "updatedAt": "2020-11-15T07:58:06Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri You are right that the default procedure is that the Initiator sends the selected cipher suite. This example had the ambition to explain why things work also in corner cases, but your question made clear that we lost focus on the most common way how this should work. I have tried to fix that in caea215, have a look!",
          "createdAt": "2020-12-03T16:22:52Z",
          "updatedAt": "2020-12-03T16:22:52Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "looks good for me. ",
          "createdAt": "2020-12-16T12:35:11Z",
          "updatedAt": "2020-12-16T12:35:11Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU3NDA5NDU3NzM=",
      "title": "What exactly is ERR_MSG and how to distinguish a regular message from an error message",
      "url": "https://github.com/lake-wg/edhoc/issues/30",
      "state": "CLOSED",
      "author": "StefanHri",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "LAKE interim jan 2021"
      ],
      "body": "E.g. when the initiator receives a message after message 1 -> this message can be message 2 or an error message.\r\nmessage 2 :\r\n\r\n```\r\nmessage_2 = (\r\n     data_2,\r\n     CIPHERTEXT_2 : bstr,\r\n   )\r\n   \r\n      data_2 = (\r\n     ? C_I : bstr_identifier,\r\n     G_Y : bstr,\r\n     C_R : bstr_identifier,\r\n   )\r\n```\r\n\r\nerror message:\r\n\r\n```\r\n   error = (\r\n     ? C_x : bstr_identifier,\r\n     ERR_MSG : tstr,\r\n     ? SUITES_R : [ supported : 2* suite ] / suite,\r\n   )\r\n```\r\n\r\nA possible mechanism to distinguish between both is to use ERR_MSG. Is ERR_MSG something that has to be defined by the protocol implementer or something provided by the user?\r\n\r\nWhat is the recommended way to distinguish between error messages and regular messages?\r\n\r\nA test vector with an error message will be very helpful for EDHOC implementors\r\n",
      "createdAt": "2020-11-11T17:34:23Z",
      "updatedAt": "2021-02-21T10:21:41Z",
      "closedAt": "2021-02-21T10:21:41Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the error message has a mandatory text string as first or second field, which is different from normal messages. See proposed formulation in e0d85f95.\r\n\r\nAgree, test vectors needs to be added.",
          "createdAt": "2020-12-02T12:49:42Z",
          "updatedAt": "2020-12-02T12:49:42Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "I am still confused. Here are my questions:\r\n\r\n1) Is there an additional purpose for ERR_MSG than only to distinguish regular messages from error messages? \r\n2) Is ERR_MSG something which the EDHOC implementer defines? If this is the case the content of ERR_MSG cannot be processed automatically because interoperability between different implementations cannot be achieved? \r\n3) Let say my EDHOC implementation receives ERR_MSG form a different EDHOC implementation. What should I do with that? Should I provide ERR_MSG to the application? \r\n4) Section 5.5.2 in RFC7252 says:\r\n\r\n   If no Content-Format option is given, the payload of responses\r\n   indicating a client or server error is a brief human-readable\r\n   diagnostic message, explaining the error situation.  This diagnostic\r\n   message MUST be encoded using UTF-8 [RFC3629], more specifically\r\n   using Net-Unicode form [RFC5198].\r\n\r\n   The message is similar to the Reason-Phrase on an HTTP status line.\r\n   It is not intended for end users but for software engineers that\r\n   during debugging need to interpret it in the context of the present,\r\n   English-language specification; therefore, no mechanism for language\r\n   tagging is needed or provided.  In contrast to what is usual in HTTP,\r\n   the payload SHOULD be empty if there is no additional information\r\n   beyond the Response Code.\r\n   \r\nI don't understand how to interpret the second paragraph in the context of EDHOC. Can you give us some examples? ",
          "createdAt": "2020-12-16T13:06:07Z",
          "updatedAt": "2020-12-16T13:06:07Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "From my perspective, it is important and sufficient that the error message and a regular message are distinguishable. \r\n\r\nIn that case, if an error message is received the edhoc implementation can notice that, discontinue the protocol and provide the error message to the caller (application). Then the application has to handle the error. This is the easiest and most simple way from the implementation perspective.\r\n\r\nAdditionally, it will be nice to have some guidance about which are the cases where an error message may be sent. Are there cases where an error message must definitively be send, e.g. during the suite negotiation?",
          "createdAt": "2021-01-21T09:05:18Z",
          "updatedAt": "2021-01-21T09:05:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The specification was updated based on Stefans comments in -04. No more comments has been received. I therefore close this issue.\r\n\r\nA related but different issue has been opened in #74 ",
          "createdAt": "2021-02-21T10:21:41Z",
          "updatedAt": "2021-02-21T10:21:41Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU3NDEzNjYxNTk=",
      "title": "Small mistakes and clarifications",
      "url": "https://github.com/lake-wg/edhoc/issues/31",
      "state": "CLOSED",
      "author": "StefanHri",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "By reading the document I notices some small mistakes and a few things which can be explained better:\r\n\r\n1) Section 5.1.1\r\n```\r\n...Figures 6 and 7 show\r\n   examples of how the Responder can truncate SUITES_I and how SUITES_R\r\n   is used by the Responder to give the Initiator...\r\n```\r\n\r\nI think it should be: \r\n```\r\n...Figures 6 and 7 show\r\n   examples of how the **Initiator** can truncate SUITES_I and how SUITES_R\r\n   is used by the Responder to give the Initiator...\r\n```\r\n---\r\n\r\n2) Section 5.1.1 bellow figure 6\r\nI don't understand what you want to say with:\r\n\r\n\"...    As the Initiator's list of supported cipher suites and order of\r\n   preference is fixed, and the Responder only accepts message_1 if the\r\n   selected cipher suite is the first cipher suite in SUITES_I that the\r\n   Responder supports, the parties can verify that the selected cipher\r\n   suite is the most preferred (by the Initiator) cipher suite supported\r\n   by both parties.  If the selected cipher suite is not the first\r\n   cipher suite in SUITES_I that the Responder supports, the Responder\r\n   will discontinue the protocol.\"\r\n   \r\n It may make sense to paraphrase this part?  \r\n\r\n--- \r\n\r\n3) Caption figure 7 and 8 \r\nNow both figures have the same caption. It will be probably  better ->\r\nFigure 7: Transferring EDHOC in CoAP where the initiator is a CoAP client\r\nFigure 8: Transferring EDHOC in CoAP where the initiator is a CoAP server\r\n\r\n---\r\n\r\n4) Section 4.3 Encoding of bstr_identifier\r\nWhat is the rationale for using int - 24? A short sentence like: \r\n\"A bstr_identifier is a special encoding for byte strings, used hroughout the protocol. The reason for using bstr_identifier is ...\"   \r\nwill be very helpful for me.",
      "createdAt": "2020-11-12T07:51:33Z",
      "updatedAt": "2020-12-16T12:16:10Z",
      "closedAt": "2020-12-16T12:16:10Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri See 1c44106",
          "createdAt": "2020-11-14T12:58:08Z",
          "updatedAt": "2020-11-14T12:58:08Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "I still don't understand:\r\n\"A bstr_identifier is a special encoding for byte strings, used throughout the protocol to encode short byte strings as int to save overhead since CBOR ints in the interval -24 to 23 can be encoded as one byte.\"\r\n\r\nLet say we have a single-byte integer (int8_t) 120. 120-24 = 96. 96 is not in the interval -24 to 23 so we cannot encode it as CBOR int?",
          "createdAt": "2020-11-15T07:38:39Z",
          "updatedAt": "2020-11-15T07:38:39Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This applies to *byte strings* that can be encoded as CBOR ints of length one byte. I made another attempt, but perhaps it can be improved further, see 325f6a8.",
          "createdAt": "2020-11-15T08:01:55Z",
          "updatedAt": "2020-11-15T08:08:50Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "I still don't understand that completely. Probably this is better:\r\n\r\nA bstr_identifier is a special encoding for byte strings, used throughout the protocol to encode those short byte strings that can as CBOR integers. Such integers are in the interval -24 to 23. They are encoded in a single byte.\r\n\r\nHowever, it is still not clear, why we need to calculate int - 24 ?",
          "createdAt": "2020-11-15T08:12:10Z",
          "updatedAt": "2020-11-15T08:12:10Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri I tried to reformulate. Have a look at 733b590",
          "createdAt": "2020-12-02T11:12:57Z",
          "updatedAt": "2020-12-02T11:12:57Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU3NDIyMjc2ODQ=",
      "title": "Identifying a certificate with 'kid' by specified",
      "url": "https://github.com/lake-wg/edhoc/issues/32",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the specification assumes that certificates are identified with x5t or x5u which are bigger than a kid can be. This limits the use of certificates compared to raw-public keys. If a raw public key in EDHOC can be identified with a kid, then a cert can as well. I would suggest to specify identification of cert with kid. This enables certificates to be used with as small messages as RPK. Making them usable in single message lorawan and 5-hop 6tisch",
      "createdAt": "2020-11-13T07:33:38Z",
      "updatedAt": "2021-04-22T08:44:45Z",
      "closedAt": "2021-04-22T08:44:45Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The missing component to use this needs to be defined in COSE. Work in progress in draft-mattsson-cose-cbor-cert-compress.",
          "createdAt": "2021-04-22T08:44:45Z",
          "updatedAt": "2021-04-22T08:44:45Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU3NDI1MTc5OTc=",
      "title": "Reference draft-mattsson-cose-cbor-cert-compress",
      "url": "https://github.com/lake-wg/edhoc/issues/33",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should reference draft-mattsson-cose-cbor-cert-compress and c5u c5t in addition to x5u x5t. https://tools.ietf.org/html/draft-mattsson-cose-cbor-cert-compress\r\n\r\nShould wait until there is a COSE adopted draft.\r\n",
      "createdAt": "2020-11-13T15:05:24Z",
      "updatedAt": "2021-01-26T06:17:43Z",
      "closedAt": "2021-01-26T06:17:43Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in 06ba35e8",
          "createdAt": "2021-01-26T06:17:43Z",
          "updatedAt": "2021-01-26T06:17:43Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU3NDI4MjQ0NTY=",
      "title": "How to do encryption without integrity in message_2",
      "url": "https://github.com/lake-wg/edhoc/issues/34",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "LAKE interim jan 2021"
      ],
      "body": "The current specification generates a long encryption key and perform XOR cipher.\r\n\r\nAs there are no non-AEAD algorithms in COSE, other options are a bit more complex.\r\n\r\n- Remove the tag from AEAD ciphertext. Only works when AEAD has a well-defined tag.\r\n- Ascociate a IND-CPA encryption algorithm with each AEAD. Requires a table.\r\n\r\nAES-CCM -> AES\r\nAES-GCM -> AES\r\nChaCha20-Poly1305 -> ChaCha20\r\n",
      "createdAt": "2020-11-13T22:21:52Z",
      "updatedAt": "2021-02-21T06:46:06Z",
      "closedAt": "2021-02-21T06:46:06Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "As the Responder sends its identity to an unauthenticated part, there is no need to have IND-CCA against active attackers. IND-CPA encryption is enough in this case. See full SIGMA paper for more information.",
          "createdAt": "2020-11-13T22:23:39Z",
          "updatedAt": "2020-11-13T22:23:39Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Should we define the encryption to that it can be performed by removing the tag. ",
          "createdAt": "2020-11-27T09:30:10Z",
          "updatedAt": "2020-11-27T09:30:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Specifying an specific AES-CTR and ChaCha20 stream cipher mode makes it cumbersome for implementors....\r\n\r\nEDHOC need to encrypt more data than DTLS 1.3 and cannot rely on AES-ECB and the ChaCha20 block cipher.\r\n\r\nI think the right way to do this in a way easy for developers (which we want) is to just remove the tag....\r\n\r\nIf there would ever be a future COSE AEAD that does not have a well defined tag, it would be needed to define how encryption without integrity is done.",
          "createdAt": "2020-11-27T09:38:08Z",
          "updatedAt": "2020-11-27T09:38:08Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Commit 6469cb8 changes the Table solution to a remove tag solution.\r\n\r\nhttps://github.com/lake-wg/edhoc/commit/6469cb8dd1865eb19ad049c28b3781688fcb1aef\r\n\r\nLooking at the changes give a good overview of the two solutions.\r\n\r\nHaving implemented both, I have a preference to just removing the tag from the COSE_Encrypt.\r\n\r\nUsing AES-CTR or ChaCha20 stream cipher requires far more work from the implementor. The developer would have to find the raw AES and ChaCha20 functions and make sure to implement the stream ciphers. This is doable but a bit complicated. We would like to keep implementation simple.\r\n\r\nThe solution with deriving a long key and XORing was simple but raised a lot of questions as XOR encryption has in the past been used in insecure ways (repeating a short key....). HMAC-SHA-256 on the other hand could very have higher security bounds than AES-128-CTR.\r\n\r\nI think just removing the tag is the best overall solution. It works for all current and foreseeable AEAD in COSE. It is very easy to implement for the developer and it does not raise any questions like old HMAC-SHA-256+XOR solution\r\n\r\nWould be good with other peoples opinion on this\r\n ",
          "createdAt": "2020-11-27T10:34:38Z",
          "updatedAt": "2020-11-27T10:34:38Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "For -04 we are reverting back to -02. That seems like the easiest solution given that COSE does not support any IND-CPA encrytion algorithms (COSE itself does not need that). We do not want people to change their implementations unless we are sure that there will be a change.\r\n\r\nUsing HKDF as a binary additive stream cipher is perfectly secure, in fact it is a much better stream cipher than AES-CTR. The reason that AES-CTR is used is that something like HKDF-Expand is overkill security wise for simple encryption and much much slower that AES-CTR.",
          "createdAt": "2021-01-25T11:40:25Z",
          "updatedAt": "2021-01-25T11:40:25Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "much much slower is for long messages.... for very short messages is would actually be faster. For the short message_2 speed difference is negligible.\r\n\r\nAnother reasons HKDF-Expand is not typically used is that most application require both IND-CCA2 confidentiality as well as integrity protection. Both of which are given by an AEAD.",
          "createdAt": "2021-01-25T11:48:21Z",
          "updatedAt": "2021-01-25T11:48:21Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in -04?",
          "createdAt": "2021-02-11T15:16:24Z",
          "updatedAt": "2021-02-11T15:16:24Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "No objections or comments to the -04 version. -05 test vectors implement this",
          "createdAt": "2021-02-21T06:46:06Z",
          "updatedAt": "2021-02-21T06:46:06Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU3NDI5NjAxMTU=",
      "title": "Register ciphersuites with high security",
      "url": "https://github.com/lake-wg/edhoc/issues/35",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There has been interest to use EDHOC with high level security, i.e. AES-256 and 384 bit ECC.\r\n\r\nShould we register a CNSA compliant cipher suite?\r\n(A256GCM, SHA-384, P-384, ES384, P-384, A256GCM, SHA-384)\r\n\r\nAnd/or something alternative?\r\n(A256GCM, SHAKE256, X448, EdDSA, Ed448, A256GCM, SHAKE256)\r\n(ChaCha20/Poly1305, SHAKE256, X448, EdDSA, Ed448, ChaCha20/Poly1305, SHAKE256)\r\n\r\nThe document should be more clear that it is possible to use EDHOC with any registered COSE algorithms by using a private number for the cipher suite.\r\n\r\n",
      "createdAt": "2020-11-14T08:27:18Z",
      "updatedAt": "2021-01-26T06:19:52Z",
      "closedAt": "2021-01-26T06:19:52Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm proxying input on two new proposed cipher suites:\r\n\r\nArray: 11, 6, 2, -35, 2, 11, 6\r\nDesc: AES-CCM-16-64-256, SHA-384, P-384, ES384, P-384, AES-CCM-16-64-256, SHA-384\r\n \r\nArray: 13, 6, 2, -35, 2, 13, 6\r\nDesc: AES-CCM-64-64-256, SHA-384, P-384, ES384, P-384, AES-CCM-64-64-256, SHA-384",
          "createdAt": "2020-12-03T14:15:31Z",
          "updatedAt": "2020-12-03T14:15:31Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "AES-CCM-16-64-256 and AES-CCM-64-64-256 are quite odd algorithms. Combining 256 bit keys with 64 bit tags is quite unbalanced. TLS WG has dicussed and decided to not standardize any more such algorithms.\r\n\r\nPeople can already use them as private cipher suites, but I do not see that it is something that can be recommended in general. I think:\r\n\r\n(A256GCM, SHA-384, P-384, ES384, P-384, A256GCM, SHA-384)\r\n(ChaCha20/Poly1305, SHAKE256, X448, EdDSA, Ed448, ChaCha20/Poly1305, SHAKE256)\r\n\r\nwould be the reasonable high security cipher suites to register. The first of these which aligns with CNSA I think should be registered.\r\n",
          "createdAt": "2020-12-03T15:00:26Z",
          "updatedAt": "2020-12-03T15:00:26Z"
        },
        {
          "author": "lemikev",
          "authorAssociation": "NONE",
          "body": "Hi Emanjon.\r\n\r\nI'm the one who asked for \"AES-CCM-64-64-256, SHA-384, P-384, ES384, P-384, AES-CCM-64-64-256, SHA-384\".\r\nThe goal was effectively to be CNSA aligned.\r\nI agree with your comments and \"A256GCM, SHA-384, P-384, ES384, P-384, A256GCM, SHA-384\" is perfectly find for my needs.\r\nTo cover CNSA, it might be logical to also include \"A128GCM, SHA-256, P-256, ES256, P-256, A128GCM, SHA-256\".\r\nJust a suggestion, I don't correctly have a need for it.",
          "createdAt": "2020-12-03T15:30:13Z",
          "updatedAt": "2020-12-03T15:30:13Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We had a similar request some weeks ago, so I go ahead and make a commit for \"A256GCM, SHA-384, P-384, ES384, P-384, A256GCM, SHA-384\".\r\n\r\nA128GCM, SHA-256, P-256, ES256, P-256, A128GCM, SHA-256\" used to be in Suite B, but is no longer in CNSA. I Agree that it probably makes sense to add something between CNSA and Constrained CCM_8. I will bring up the question in an upcoming LAKE meeting. I think the algorithms used on state of the art web servers today is typically:\r\nA128GCM, SHA-256, Curve25519, ES256, P-256, A128GCM, SHA-256",
          "createdAt": "2020-12-03T17:58:15Z",
          "updatedAt": "2020-12-03T17:58:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a commit e3dc83b registering two more cipher suites. One aligning with CNSA and one aligning with current best practice for HTTPS (used e.g. by GitHub). I also added more information on the posibility of using private cipher suites.",
          "createdAt": "2020-12-03T18:27:03Z",
          "updatedAt": "2020-12-03T18:27:03Z"
        },
        {
          "author": "lemikev",
          "authorAssociation": "NONE",
          "body": "Thanks for this change. Please send advise if somebody else is implementing \"A256GCM, SHA-384, P-384, ES384, P-384, A256GCM, SHA-384\". I will be interested to interop with him.",
          "createdAt": "2020-12-03T20:40:19Z",
          "updatedAt": "2020-12-03T20:40:19Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in -03",
          "createdAt": "2021-01-26T06:19:52Z",
          "updatedAt": "2021-01-26T06:19:52Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU3NTY5MjcxODA=",
      "title": "Add guidelines for distinguishing received messages. Relates to #30.",
      "url": "https://github.com/lake-wg/edhoc/issues/39",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-04T08:57:50Z",
      "updatedAt": "2021-07-15T19:36:59Z",
      "closedAt": "2021-07-15T19:36:59Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Proxying draft solution:\r\n\r\n    First, check if it is an Error Message. That's the case if and only\r\n    if the first or second element of the sequence is a text string.\r\n\r\n    If it's not an Error Message:\r\n\r\n    - If the sequence has 1 or 2 elements, it's Message 3.\r\n\r\n    - If the sequence has 3 elements, it's Message 2.\r\n\r\n    - If the sequence has 5 elements, it's message 1.\r\n\r\n    - If the sequence has 4 elements, check its second element.\r\n    --- If it is an array or an integer, it's Message 1.\r\n    --- If it is a byte string, it's Message 2.\r\n",
          "createdAt": "2020-12-10T07:58:10Z",
          "updatedAt": "2020-12-10T07:58:10Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Since both a client and a server can act as Initiator or Responder, this early understanding helps in taking the next steps when receiving a message.\r\n\r\nThis helps especially for retrieving the status of an ongoing EDHOC execution when receiving Error Message, Message 2 or Message 3, or for starting processing Message 1 that potentially yields the creation and storage of a new execution status as Responder.\r\n\r\nFor the status retrieval, the endpoint uses C_I/C_R (if included in the message) or implicit transport protocol indications, depending on the correlation method.",
          "createdAt": "2020-12-18T08:51:28Z",
          "updatedAt": "2020-12-18T08:51:28Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think these are good points, but I don't see exactly why you are having a problem and how the draft should be updated. Could you provide a conrete message flow that also shows which protocol layers that are used below EDHOC. Could be that normative text on how to distinguish the messages are needed, or this is mostly implementation guidance. Might also be that something in the draft needed to be more strict or change. I think both endpoints sending message_1 has not been discussed other than from a security perspective.",
          "createdAt": "2020-12-18T10:59:20Z",
          "updatedAt": "2020-12-18T10:59:20Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "It is just for implementation guidance, as a possible way to do the message distinction. I didn't think of something to add or fix in the actual protocol.",
          "createdAt": "2020-12-18T13:31:46Z",
          "updatedAt": "2020-12-18T13:31:46Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "I'd prefer not to parse the full message (which, given it's CBOR sequences, ) at the point where I branch around; looking at the decision tree from that side.\r\n\r\nI'm only considering a server's situation here, so it can receive a Message 1, a Message 3 (carrying a c_r, of the server's choice), or a Message 2 or 4 (both carrying a c_i, with a value of the server's choice).\r\n\r\nSuch a server WOULD PROBABLY pick c_i and c_r values which it can distinguish from each other (say, by their least significant bit, or by a prefix), and WOULD PROBABLY NOT pick any value that's a legal METHOD_CORR (ie. no values from 0 to 15 inclusive).\r\n\r\nThe server can then tell whether it's\r\n* Message 1: first element in 0..=15\r\n* Message 3: first element is a C_R\r\n* Message 2: first element is a C_I\r\n* Message 4: does that ever get used with a server at all?\r\n\r\n  Probably not, as \"In deployments where no protected application message is sent from the Responder to the Initiator\" is not the case -- because that's one of the cases where it is not needed.\r\n\r\n  If s, the distinction between message 2 and 4 is \"is it over after having decoded the two elements\" (given message 4 has 2 elements in presence of a C_I, message 2 has 4).",
          "createdAt": "2021-03-01T13:53:24Z",
          "updatedAt": "2021-03-01T13:53:24Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Provided by transport. In -08 this is described for CoAP in Appendix A.3.",
          "createdAt": "2021-07-15T19:36:59Z",
          "updatedAt": "2021-07-15T19:36:59Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU3NjEwMzQ0MDU=",
      "title": "Section 3 and 4.1-4.2 needs restructure ",
      "url": "https://github.com/lake-wg/edhoc/issues/40",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The structure of sections 2, 3 and 4.1-4.2 is reflecting old versions of the protocol: New methods have been added and the symmetric key authentication variant has been removed.\r\n\r\nSome examples of why this is needed:\r\n* Section 4 is described as containing the asymmetric key authentication variant although the current protocol only supports asymmetric key authentication. There are two sections labelled as \"overview\" (3 and 4.1) with overlap in content and unclear division of content. Section 2 already contains an overview.\r\n\r\n* Figure 3 in section 3 is not very helpful to explain the protocol components, replace with figure 4 from section 4.\r\n\r\nA restructure is needed, some initial ideas:\r\n\r\n* Keep section 2 largely as is but change title to \"EDHOC outline\" and mention other methods\r\n* Rename section 3 \"Protocol components\" and move corresponding content here\r\n* Rename section 4 \"Messages formatting and processing\" and focus on that",
      "createdAt": "2020-12-10T08:44:59Z",
      "updatedAt": "2021-01-26T05:08:19Z",
      "closedAt": "2021-01-26T05:08:19Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU3NjYxOTgyMjE=",
      "title": "Missing Responder private key in test vector.",
      "url": "https://github.com/lake-wg/edhoc/issues/42",
      "state": "CLOSED",
      "author": "TimothyClaeys",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the following test vector [method 2 - Static(Initiator)-Sign(Responder)]:\r\n\r\nhttps://github.com/lake-wg/edhoc/blob/c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667/test-vectors/vectors.txt#L978\r\n\r\nThe Responder is missing its private authentication key. The Responder's private key is required to compute the `sign_or_mac2 `part of `message 2`, using an COSE_Sign1 structure.",
      "createdAt": "2020-12-14T09:31:46Z",
      "updatedAt": "2021-02-21T06:27:17Z",
      "closedAt": "2021-02-21T06:27:17Z",
      "comments": [
        {
          "author": "fpalombini",
          "authorAssociation": "COLLABORATOR",
          "body": "Again due to the copy paste typo in the generation code, now fixed in a09570b. Need to run the code to regenerate new test vectors using the updated code, I wouldn't update the appendix at the same time to match the vectors.txt though, because that's not really necessary (they are still correct, just need to fix the print).",
          "createdAt": "2020-12-14T14:38:54Z",
          "updatedAt": "2020-12-14T14:38:54Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in test-vector-05",
          "createdAt": "2021-02-21T06:27:17Z",
          "updatedAt": "2021-02-21T06:27:17Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU3NjYyMDg4MzI=",
      "title": "Redundant Responder private key",
      "url": "https://github.com/lake-wg/edhoc/issues/43",
      "state": "CLOSED",
      "author": "TimothyClaeys",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The following test vector:\r\n\r\nhttps://github.com/lake-wg/edhoc/blob/c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667/test-vectors/vectors.txt#L704\r\n\r\nSeems to have a redundant Responder private authentication key listed.\r\n\r\nhttps://github.com/lake-wg/edhoc/blob/c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667/test-vectors/vectors.txt#L766\r\n\r\nThe test vector computes the correct values using the private key:\r\n\r\nhttps://github.com/lake-wg/edhoc/blob/c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667/test-vectors/vectors.txt#L770",
      "createdAt": "2020-12-14T09:42:35Z",
      "updatedAt": "2021-02-21T06:49:07Z",
      "closedAt": "2021-02-21T06:49:07Z",
      "comments": [
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The redundant private key does **NOT** seem to match the missing key in issue https://github.com/lake-wg/edhoc/issues/42#issue-766198221.",
          "createdAt": "2020-12-14T09:46:19Z",
          "updatedAt": "2020-12-14T09:46:19Z"
        },
        {
          "author": "fpalombini",
          "authorAssociation": "COLLABORATOR",
          "body": "This seemed to be a copy-paste typo in the test vectors code (now should be fixed a09570b4fe83c3 ). \r\nKeeping open because we still need to fix the test vectors (vectors.txt) and in the draft.",
          "createdAt": "2020-12-14T14:25:27Z",
          "updatedAt": "2020-12-14T14:25:27Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with test vectors -05",
          "createdAt": "2021-02-21T06:49:07Z",
          "updatedAt": "2021-02-21T06:49:07Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU3NjYyNDI2MTc=",
      "title": "Test vectors not adhering to section 4.4.3 (cipher suite verification by the Responder in message 1)",
      "url": "https://github.com/lake-wg/edhoc/issues/44",
      "state": "CLOSED",
      "author": "TimothyClaeys",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the following test vector:\r\n\r\nhttps://github.com/lake-wg/edhoc/blob/c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667/test-vectors/vectors.txt#L2520\r\n\r\nThe Responder supports all 4 cipher suites (0, 1, 2, 3). The Initiator sends a message 1, where it includes 0, 1, and 2 as supported cipher suites and selects cipher suite 1. According to [section 4.4.3 ](https://tools.ietf.org/html/draft-ietf-lake-edhoc-02#section-4.4), the Responder must verify that the selected cipher suite is supported and that no prior cipher suites in SUITES_I are supported.\r\n\r\nSince the Responder supports cipher suite 0 and cipher suite 0 also has a higher preference for the Initiator (it appears as the first element in SUITES_I), the Responder should answer with and EDHOC error message.\r\n\r\nThe test vector can be fixed by removing cipher suite 0 from the Responder's supported cipher suites.",
      "createdAt": "2020-12-14T10:13:35Z",
      "updatedAt": "2021-01-27T08:35:16Z",
      "closedAt": "2021-01-27T08:35:16Z",
      "comments": [
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two other test vectors with the same issue:\r\n\r\nhttps://github.com/lake-wg/edhoc/blob/c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667/test-vectors/vectors.txt#L2820\r\n\r\nhttps://github.com/lake-wg/edhoc/blob/c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667/test-vectors/vectors.txt#L3075",
          "createdAt": "2020-12-14T10:34:35Z",
          "updatedAt": "2020-12-14T10:34:35Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU3NjYyNTQ0MzM=",
      "title": "Typo in section 4.4.3",
      "url": "https://github.com/lake-wg/edhoc/issues/45",
      "state": "CLOSED",
      "author": "TimothyClaeys",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "**When the responder is processing message 1, section 4.4.3 reads:**\r\n\r\nIf any verification step fails, the Initiator MUST send an EDHOC error message back, formatted as defined in Section 5, and the protocol MUST be discontinued.\r\n\r\nI think this should be:\r\n\r\nIf any verification step fails, the `Responder` MUST send an EDHOC error message back, formatted as defined in Section 5, and the protocol MUST be discontinued.\r\n\r\nPR: https://github.com/lake-wg/edhoc/pull/46#issue-539337881",
      "createdAt": "2020-12-14T10:24:10Z",
      "updatedAt": "2020-12-17T08:08:07Z",
      "closedAt": "2020-12-17T08:08:07Z",
      "comments": []
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU3NjYzODg1NDM=",
      "title": "Test vectors additions",
      "url": "https://github.com/lake-wg/edhoc/issues/47",
      "state": "OPEN",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "as requested from interop:\r\n\r\n- [x] obsolete PSK test vectors\r\n- [x] add TH4 output\r\n- [x] add exporter, exporter outputs, keyupdate, to all test vectors\r\n- [x] add KEYSTREAM_2\r\n- [x] print out public keys.\r\n- [x] Add error message\r\n- [x] Add message_4\r\n- [x] Add ead\r\n- [x] Update test vectors to -10\r\n- [x] Add JSON format\r\n- [ ] add real certificates to test vectors - 0:CBOR native and DER (and possibly later 1:ASN.1 translated)\r\n- [ ] Add ciphersuites 2 and 3 to test vectors, ECDSA keys should print out full y coordinate\r\n",
      "createdAt": "2020-12-14T12:41:48Z",
      "updatedAt": "2021-09-09T15:49:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would also be useful to have a test vector that has additional data attached to the exchange. Depending on the message, this data is also protected so a test vector would allow an implementation to verify if the protection of the additional data is done properly.",
          "createdAt": "2020-12-14T13:25:58Z",
          "updatedAt": "2020-12-14T13:25:58Z"
        },
        {
          "author": "fpalombini",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @TimothyClaeys, good point!",
          "createdAt": "2020-12-14T14:00:07Z",
          "updatedAt": "2020-12-14T14:00:07Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I have updated the list. The new test vectors add ead, error messages, and message_4 and aligns with -10.\r\n\r\nI have not added real certificates yet. But I made them a sequence 00 01 02 03 ...  to make it easy to see they are not real. The old one were random strings and several people tried to parse them",
          "createdAt": "2021-09-05T06:29:03Z",
          "updatedAt": "2021-09-05T06:29:03Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I thinking about adding the error message to actual flows where the error message might come after any of normal  EHODC messages.\r\n\r\nafter message_1 : ERR_CODE 1 or 2\r\nafter message_2 : ERR_CODE 1\r\nafter message_3 : ERR_CODE 0 or 1\r\nafter message_3 : ERR_CODE 0 or 1\r\n",
          "createdAt": "2021-09-09T15:49:50Z",
          "updatedAt": "2021-09-09T15:49:50Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU3NjgyMDEzNDk=",
      "title": "Sections 1.0 and 1.1 needs restructure",
      "url": "https://github.com/lake-wg/edhoc/issues/48",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Sections 1.1 and the text before section 1.1 in section 1 (=1.0) is overlapping, reflecting that section 1.1 has been added without harmonization of the existing text. Some  pieces are duplicate, other parts are redundant because they contain alternative reasoning with the same conclusion. \r\n\r\nSection 1.1 should be merged into a new section 1.0.",
      "createdAt": "2020-12-15T21:02:31Z",
      "updatedAt": "2021-01-26T05:08:01Z",
      "closedAt": "2021-01-26T05:08:01Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with 5f5bee3",
          "createdAt": "2021-01-26T05:08:01Z",
          "updatedAt": "2021-01-26T05:08:01Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU3NzEwMjExODE=",
      "title": "Add cipher suite with Wei25519",
      "url": "https://github.com/lake-wg/edhoc/issues/50",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-18T16:38:30Z",
      "updatedAt": "2021-02-21T06:58:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Will be done when IANA registrations are done",
          "createdAt": "2021-02-21T06:58:23Z",
          "updatedAt": "2021-02-21T06:58:23Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU3ODMyMjY1ODk=",
      "title": "Test vector",
      "url": "https://github.com/lake-wg/edhoc/issues/51",
      "state": "CLOSED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "add real certificates in the test vector (both appendix and .txt) instead of random bytes",
      "createdAt": "2021-01-11T09:56:14Z",
      "updatedAt": "2021-02-21T06:57:25Z",
      "closedAt": "2021-02-21T06:57:25Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Updates #47 with this information. Close this",
          "createdAt": "2021-02-21T06:57:25Z",
          "updatedAt": "2021-02-21T06:57:25Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU3ODUwNzU2MzE=",
      "title": "Clarify decryption of CIPHERTEXT_2",
      "url": "https://github.com/lake-wg/edhoc/issues/52",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "LAKE interim jan 2021"
      ],
      "body": "In the latest version -03, Section 5.3.3 says:\r\n\r\n\"Decrypt CIPHERTEXT_2 by computing an outer COSE_Encrypt0 as defined in see Section 5.3.2 and XORing CIPHERTEXT_2 with the 'ciphertext' of the outer COSE_Encrypt0 with the tag removed.\"\r\n\r\n\r\nCould you clarify this process and elaborate on its steps?\r\n\r\nAlso, is this actually involving a XORing? That seems being left here from the previous process in version -02 based on a keystream.",
      "createdAt": "2021-01-13T12:47:27Z",
      "updatedAt": "2021-02-12T10:57:43Z",
      "closedAt": "2021-02-12T10:57:43Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that the operation to encrypt message_2 is not determined yet. We are awaiting developer feedback if the -02 or -03 way of doing things are the best way from a development perspective.\r\n\r\nCould you clarify what is missing or unclear in the -03 description? The -03 description seems correct to me. XOR is needed in more or less all modern encryption.\r\n\r\n(Feedback that AES-CTR and ChaCha20 stream cipher without Poly1305 is the right way is also ok of course. I found that alternative way to complex to implement).",
          "createdAt": "2021-01-23T10:15:52Z",
          "updatedAt": "2021-01-23T10:15:52Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Trying to rewrite that sentence as steps, I read it as:\r\n\r\n1. Fill an Encrypt0 object like the one in Section 5.3.2 and encrypt it.\r\n\r\n2. Take the resulting 'ciphertext' of the processed object and remove the tag.\r\n\r\n3. Take the output of step 2 and XOR it with CIPHERTEXT_2 from Message_2.\r\n\r\nThe result of step 3 is the plaintext with ID_CRED_R, Signature_or_MAC_2 and possibly AD_2.\r\n\r\n\r\nIs this the intended workflow? If so, what is used as plaintext P in step 1?",
          "createdAt": "2021-01-23T12:17:18Z",
          "updatedAt": "2021-01-23T12:17:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, that is the intended workflow.\r\n\r\nThe value of P is clearly missing, P needs to be set to a byte string of zeroes of the same length as the intitial byte string, which the reciever would need to calculate as the length of the ciphertext minus the length of the tag. This is clearly missing from the text. \r\n\r\nThanks. ",
          "createdAt": "2021-01-24T06:14:15Z",
          "updatedAt": "2021-01-24T06:14:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe this removing tag is a bit more complex that I first thought. It actually requires two things from the AEAD. That is has a well-defined tag and that the encryption is done with a synchronous xor based stream cipher. Both of these happen to be true for all the currently defined AEAD algs.\r\n\r\nMight very well be that we should for the -02 version if that is easier. I think that solution fine if we reformulate it that we are using HMAC-SHA256 as a stream cipher to generate keystream. The reason nobody does that is that HMAC-SHA256 is overkill security wise and are slow.\r\n\r\nAnother alternative would be to use AES-CTR but then I think that should not be left to the developers and instead registered as an algorithm in COSE.",
          "createdAt": "2021-01-25T08:28:11Z",
          "updatedAt": "2021-01-25T08:28:11Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Or rather we are using HKDF-Expand as a stream cipher to generate key stream",
          "createdAt": "2021-01-25T08:30:17Z",
          "updatedAt": "2021-01-25T08:30:17Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Reverted to -02, rephrased as binary stream cipher, see:\r\n\r\ne2912c9\r\ncd5fdb5\r\nd5ac597\r\nc95a3d2\r\n",
          "createdAt": "2021-01-26T09:02:46Z",
          "updatedAt": "2021-01-26T09:02:46Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Thanks for this. Note that:\r\n\r\n* The notation in Figure 3 is still using K_2e for message_2.\r\n\r\n* In Section 4, below the CBOR encoding of 'info':\r\n\r\n--- K_2e is still mentioned in the first bullet point.\r\n\r\n--- The label \"K_2e\" is still in the list of possible labels, in the third bullet point.\r\n\r\nWhile still making it clear that the plaintext for message_2 is XORed with a keystream, keeping the original name K_2e may help readability (think also of Figure 3).\r\n\r\nAlso, keeping the label \"K_2e\" would preserve the current values in the test vectors.",
          "createdAt": "2021-01-26T14:02:06Z",
          "updatedAt": "2021-01-26T14:02:06Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in -04?",
          "createdAt": "2021-02-11T15:14:14Z",
          "updatedAt": "2021-02-11T15:14:14Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Yes, I think it's fixed.",
          "createdAt": "2021-02-11T17:16:17Z",
          "updatedAt": "2021-02-11T17:16:17Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU3ODU4MDE5MzI=",
      "title": "Terminology for ciphertext/authentication tag",
      "url": "https://github.com/lake-wg/edhoc/issues/53",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Comment from implementer that the use of the term ciphertext is confusing.\r\n\r\nEDHOC reuses terminology from RFC 6655 where the term ciphertext denote ciphertext concatenated with authentication tag.\r\n\r\nRFC 6655:\r\n\"The AEAD_AES_128_CCM_8 ciphertext consists of the ciphertext output of\r\n   the CCM encryption operation concatenated with the 8-octet\r\n   authentication tag output of the CCM encryption operation. \"\r\n\r\nSince -03 the protocol contains instances of three uses of the term ciphertext:\r\n1. the output of the encryption only (= ciphertext)\r\n2. the authentication tag only (= ciphertext, in case of empty plaintext), and \r\n3. the concatenation of these (= ciphertext according to RFC 6655). \r\n\r\n\r\n\r\n",
      "createdAt": "2021-01-14T08:49:21Z",
      "updatedAt": "2021-01-26T04:34:14Z",
      "closedAt": "2021-01-26T04:34:14Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "7f1e2310 addresses this issue by clarifying the the notation 'ciphertext'.\r\n\r\n\r\n",
          "createdAt": "2021-01-22T11:03:29Z",
          "updatedAt": "2021-01-22T11:03:29Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU3ODU4MDU4NDM=",
      "title": "Real certificates in test vector",
      "url": "https://github.com/lake-wg/edhoc/issues/54",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "X509_I and X509_R in appendix B.1 are just dummy byte strings. Request from implementer to replace with real certificates.",
      "createdAt": "2021-01-14T08:55:29Z",
      "updatedAt": "2021-01-21T08:14:06Z",
      "closedAt": "2021-01-21T08:14:06Z",
      "comments": [
        {
          "author": "fpalombini",
          "authorAssociation": "COLLABORATOR",
          "body": "this is a duplicate of https://github.com/lake-wg/edhoc/issues/51 and also of https://github.com/lake-wg/edhoc/issues/47",
          "createdAt": "2021-01-18T14:56:41Z",
          "updatedAt": "2021-01-18T14:57:22Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, lost track.",
          "createdAt": "2021-01-21T08:14:06Z",
          "updatedAt": "2021-01-21T08:14:06Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU3ODgzNTU1MTM=",
      "title": "Fix test vector",
      "url": "https://github.com/lake-wg/edhoc/issues/55",
      "state": "CLOSED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\n  data_2 =\r\n  (\r\n    h'71a3d599c21da18902a1aea810b2b6382ccd8d5f9bf0195281754c5ebcaf301e',\r\n    h'13'\r\n  )\r\n```\r\n\r\nShould be:\r\n\r\n```\r\n  data_2 =\r\n  (\r\n    h'71a3d599c21da18902a1aea810b2b6382ccd8d5f9bf0195281754c5ebcaf301e',\r\n    19\r\n  )\r\n```",
      "createdAt": "2021-01-18T15:23:12Z",
      "updatedAt": "2021-01-18T15:36:08Z",
      "closedAt": "2021-01-18T15:36:08Z",
      "comments": []
    },
    {
      "number": 56,
      "id": "MDU6SXNzdWU3OTA4MjAwNDY=",
      "title": "Rename EDHOC-Exporter-FS",
      "url": "https://github.com/lake-wg/edhoc/issues/56",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The name gives the impression that it is exporting something, but the function does not return anything.",
      "createdAt": "2021-01-21T08:31:37Z",
      "updatedAt": "2021-02-21T06:42:22Z",
      "closedAt": "2021-02-21T06:42:21Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "First attempt: EDHOC-Rekey-Exporter-FS  (see 2f6ecec).\r\n\r\nOther proposals: \r\n* EDHOC-Rekey-FS()\r\n* EDHOC-Rekey()",
          "createdAt": "2021-01-25T07:37:10Z",
          "updatedAt": "2021-01-25T07:37:10Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Reopened due to further comments on the name in EDHOC-04: \"EDHOC-Rekey-FS()\"\r\n\r\nJohn: The term \"key update\" (also used by TLS 1.3) is more appropriate than \"rekey\". \r\nG\u00f6ran: The notation \"FS\" as in forward secrecy is an intended property but should not be part of the function name.\r\n\r\nNew proposal: EDHOC-Key-Update()\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-02-02T10:51:35Z",
          "updatedAt": "2021-02-02T10:51:35Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in 9dcf610\r\n\r\nI will make test vectors for EDHOC-Key-Update()",
          "createdAt": "2021-02-13T08:51:58Z",
          "updatedAt": "2021-02-13T08:51:58Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should change to the more simple\r\n\r\nEDHOC-KeyUpdate( nonce ):\r\n      PRK_4x3m = Extract( nonce, PRK_4x3m )\r\n\r\nThis aligns with the other usages of Extract. \r\n\r\n\r\n",
          "createdAt": "2021-02-13T09:29:41Z",
          "updatedAt": "2021-02-13T09:29:41Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "No objection to this. This is implemented in -05 specification and test vectors.",
          "createdAt": "2021-02-21T06:42:21Z",
          "updatedAt": "2021-02-21T06:42:21Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU3OTExNDg2MTY=",
      "title": "Passing information to the application",
      "url": "https://github.com/lake-wg/edhoc/issues/57",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Sections 5.2.3, 5.3.3 and 5.4.3 can explicitly say that nothing should be passed to the application if any verification step fails and the protocol is discontinued.\r\n\r\nThis applies to Application Data and other information mentioned in the last bullet point of each of those sections.",
      "createdAt": "2021-01-21T14:27:13Z",
      "updatedAt": "2021-05-24T19:22:23Z",
      "closedAt": "2021-05-24T19:22:23Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics When to send EAD is now explicitly stated. What information to send to application is implementation dependent. Is this still an issue?",
          "createdAt": "2021-05-24T13:28:46Z",
          "updatedAt": "2021-05-24T13:28:46Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "It looks good. I think the issue can be closed.",
          "createdAt": "2021-05-24T17:13:55Z",
          "updatedAt": "2021-05-24T17:13:55Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU3OTExNTcwOTU=",
      "title": "Length values when using the Exporter for OSCORE",
      "url": "https://github.com/lake-wg/edhoc/issues/58",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "LAKE interim jan 2021"
      ],
      "body": "In Section 7.1.1, perhaps the two values specified for the 'length' parameter in the two Exporter invocations can be indicated simply as default values.\r\n\r\nThe two peers might have been able to agree in advance on different length values, out-of-band or through separate assisted negotiations.",
      "createdAt": "2021-01-21T14:34:25Z",
      "updatedAt": "2021-02-21T06:49:51Z",
      "closedAt": "2021-02-21T06:49:51Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics Please provide an example where you think this is useful.",
          "createdAt": "2021-01-25T09:49:33Z",
          "updatedAt": "2021-01-25T09:49:33Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I was thinking of a possible EDHOC profile of ACE.\r\n\r\nThen the Authorization Server can provide not only authentication information to run EDHOC, but also additional information like the intended size for the OSCORE Master Secret and Master Salt to use in the Exporters.",
          "createdAt": "2021-01-25T11:06:33Z",
          "updatedAt": "2021-01-25T11:06:33Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was thinking of a possible EDHOC profile of ACE.\r\n> \r\n> Then the Authorization Server can provide not only authentication information to run EDHOC, but also additional information like the intended size for the OSCORE Master Secret and Master Salt to use in the Exporters.\r\n\r\nThis seems to be merging into the space of https://datatracker.ietf.org/doc/draft-selander-ace-ake-authz/ where we get info from an AS.",
          "createdAt": "2021-01-25T16:01:25Z",
          "updatedAt": "2021-01-25T16:01:25Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a commit for -05 ",
          "createdAt": "2021-02-21T06:49:51Z",
          "updatedAt": "2021-02-21T06:49:51Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU3OTI3MzA0NTU=",
      "title": "Update acknowledgements.",
      "url": "https://github.com/lake-wg/edhoc/issues/59",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-24T06:15:14Z",
      "updatedAt": "2021-02-21T06:50:29Z",
      "closedAt": "2021-02-21T06:50:29Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Here are some: 2e77356. Who did I forget?\r\n",
          "createdAt": "2021-01-26T06:52:17Z",
          "updatedAt": "2021-01-26T06:52:17Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU3OTQ5NzIzNDQ=",
      "title": "Test vectors comments from Peter",
      "url": "https://github.com/lake-wg/edhoc/issues/60",
      "state": "CLOSED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "page 51 info for IV_2m, algorithm number 10;\r\nIt might be good to remind that the 10 comes from the cose algorithm number specified in item 0 of the suite.\r\n\r\npage 52 at the end\r\nK_2e = HKDF-Expand( PRK, info, length) should that not be: K_2e = HKDF-Expand( PRK_3e2m, info, length) .\r\nIf not, what should it be?\r\n\r\nThe number of bytes are sometimes a bit magical; In some cases it can be reminded that ECDH uses 32 bytes and the signature of the ed25519 is 32 bytes as well.\r\n\r\npage 51: may be mention that for MAC_2, 8 bytes is length of TAG\r\n\r\npage 52: cbor bytes of Signature_or_MAC_2  or h'Signature_or_MAC_2' instead of Signature_or_MAC_2.\r\n\r\npage 58 line 6-7: ID_CRED_I, h'Signature_or_MAC_3'\r\n\r\npage 59, line 1, HKDF-Expand(PRK_4x3m, info, L))\r\n\r\nmessage_3 = ( h'13', h'CIPHERTEXT_3')\r\n",
      "createdAt": "2021-01-27T10:27:16Z",
      "updatedAt": "2021-03-02T14:55:45Z",
      "closedAt": "2021-03-02T14:55:45Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@petervanderstok I tried to address what remains of these comments. Let me know I missed something.",
          "createdAt": "2021-02-22T18:23:51Z",
          "updatedAt": "2021-02-22T18:23:51Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed as discussed during Hackathon.",
          "createdAt": "2021-03-02T14:55:45Z",
          "updatedAt": "2021-03-02T14:55:45Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWU3OTQ5NzI4MTU=",
      "title": "Change message_1 format",
      "url": "https://github.com/lake-wg/edhoc/issues/61",
      "state": "CLOSED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @petervanderstok:\r\n\r\nCan both message_3 and message_1 be started with C_R that helps the parsing and makes a distinction between the two messages.\r\nIn message_1 C_R = h'' means that C_R is to be calcuated by Receiver.\r\nOtherwise C_R serves to determine it is a new connection (messagee_1) or an existing ongoing connection (message_3).",
      "createdAt": "2021-01-27T10:27:50Z",
      "updatedAt": "2021-07-15T19:54:35Z",
      "closedAt": "2021-07-15T19:54:35Z",
      "comments": [
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "This also relates to https://github.com/lake-wg/edhoc/issues/39\r\n\r\nIt is possible to distinguish the two message types based on the number of elements that they include.",
          "createdAt": "2021-01-28T15:56:05Z",
          "updatedAt": "2021-01-28T15:56:05Z"
        },
        {
          "author": "petervanderstok",
          "authorAssociation": "NONE",
          "body": "That is true,\n\nI found even other means to do so; But they are indirect, and not\nassured to be true in the future.\nThat is the motivation for asking the change.\n\nIt is not a major issue, just makes the code more robust.\n\ngreetings,\n\nPeter\n\nmarco-tiloca-sics schreef op 2021-01-28 16:56:\n\n> This also relates to #39 [1] \n> \n> It is possible to distinguish the two message types based on the number of elements that they include. \n> \n> --\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub [2], or unsubscribe [3].\n \n\nLinks:\n------\n[1] https://github.com/lake-wg/edhoc/issues/39\n[2] https://github.com/lake-wg/edhoc/issues/61#issuecomment-769183292\n[3]\nhttps://github.com/notifications/unsubscribe-auth/ADCZGQKTHFYJ5LWRGODKTRDS4GCKRANCNFSM4WVAIABQ",
          "createdAt": "2021-01-28T16:02:45Z",
          "updatedAt": "2021-01-28T16:02:45Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Starting message_1 with the fixed h'' sound like it might be a good idea. That only cost one byte and the size in message_1 is not critical.\r\n\r\nThe change would reduce the number of 1 byte C_R from 49 to 48 or something like that, but we could live with that.\r\n\r\nThe text would also need to be update to reflect that this would be a dummy C_R and not a value chosen by R.",
          "createdAt": "2021-02-15T17:18:09Z",
          "updatedAt": "2021-02-15T17:18:09Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "I had a very similar issue [here](https://github.com/lake-wg/edhoc/issues/30). At the end, the way to distinguish between messages is through the number of elements and their CBOR types. However, I agree with \r\npetervanderstok that this method is indirect. \r\n\r\nThe suggested dummy C_R (as far I understand) acts as a message ID. Will it be better to call it message ID? Additionally, also the error message may use a message ID which will make its parsing also easier. \r\n\r\nFor me, it is a trade-off between message size and parsing complexity, however, both variants work.",
          "createdAt": "2021-02-16T08:12:10Z",
          "updatedAt": "2021-02-16T08:12:45Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a undocumented design philosophy was that first element should be used to distinguish message_1 and message_3. This aspect dissapeared with the bstr_identifier optimization.\r\n\r\nI am always hesitant to add bytes, but I think this is a good change. Even if its possible to implement now, there could be future methods that make things more tricky.\r\n\r\nThe change also needs to make sure that the dummy value h'' cannot be used as a real C_R. ",
          "createdAt": "2021-02-16T13:08:29Z",
          "updatedAt": "2021-02-16T13:08:29Z"
        },
        {
          "author": "petervanderstok",
          "authorAssociation": "NONE",
          "body": "Hi John,\n\n\"The change also needs to make sure that the dummy value h'' cannot be\nused as a real C_R.\"\n\nAt least, h'' can be detected and represented as a byte string with\nlength 0;\nIMO that means: not yet determined.\n\nPeter\n\nJohn Mattsson schreef op 2021-02-16 14:08:\n\n> I think a undocumented design philosophy was that first element should be used to distinguish message_1 and message_3. This aspect dissapeared with the bstr_identifier optimization. \n> \n> I am always hesitant to add bytes, but I think this is a good change. Even if its possible to implement now, there could be future methods that make things more tricky. \n> \n> The change also needs to make sure that the dummy value h'' cannot be used as a real C_R. \n> \n> --\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub [1], or unsubscribe [2].\n \n\nLinks:\n------\n[1] https://github.com/lake-wg/edhoc/issues/61#issuecomment-779825214\n[2]\nhttps://github.com/notifications/unsubscribe-auth/ADCZGQKD24IKSXMEUZW4HW3S7JU53ANCNFSM4WVAIABQ",
          "createdAt": "2021-02-16T14:09:21Z",
          "updatedAt": "2021-02-16T14:09:21Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I also believe this is a good change to do.",
          "createdAt": "2021-02-16T22:02:37Z",
          "updatedAt": "2021-02-16T22:02:37Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "COLLABORATOR",
          "body": "> I had a very similar issue [here](https://github.com/lake-wg/edhoc/issues/30). At the end, the way to distinguish between messages is through the number of elements and their CBOR types. However, I agree with\r\n> petervanderstok that this method is indirect.\r\n\r\nIt's not just indirect, it's unstable to future changes in the specification.\r\nIt's also hard for an observer to help debug.\r\nSo, please let's make this explicit.",
          "createdAt": "2021-02-19T17:05:48Z",
          "updatedAt": "2021-02-19T17:05:48Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I added \r\nC_1 : bstr .size 0\r\n\r\nBut this is likely not what we want. This stops the server to negotiate the optimal client ID for OSCORE",
          "createdAt": "2021-02-21T06:22:56Z",
          "updatedAt": "2021-02-21T06:22:56Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Should we reserve one of the 1 byte or one of the 2 byte C_R / Client ID ?",
          "createdAt": "2021-02-21T06:26:05Z",
          "updatedAt": "2021-02-21T06:26:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to discuss and document how the EDHOC processing should be done. This is unfortunatly a bit missing from the document so I understand all the issues regarding this. In the document the processin is written under each message which probably gives the idea that the implementation has to know the message to do processing.\r\n\r\nI dont think my previous statement \"think a undocumented design philosophy was that first element should be used to distinguish message_1 and message_3. This aspect dissapeared with the bstr_identifier optimization.\" was true. \r\n\r\nThinking some more, I think the idea when writing the spec was as follows.\r\n\r\n```\r\n- First detemine that is is a EDHOC message.\r\n\r\n- Retrieve the security context using the connection identifier and/or other external information such as the CoAP Token and the 5-tuple.\r\n\r\nIF security context was found\r\n      - IF messege is error, process as error\r\n      - ELSE process as expected next message in security context\r\nELSE process as message_1\r\n```\r\nThe issue suggesting message_3 several times makes me a bit worried. I cannot see any concrete attacks but it is definitly not intended and might break the security properties.\r\n\r\n",
          "createdAt": "2021-02-21T11:29:41Z",
          "updatedAt": "2021-02-21T11:29:41Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Coming at this from issue https://github.com/lake-wg/edhoc/issues/39#issuecomment-787965315 (didn't see this one after I posted there), things look already pretty well distinguishable to me as long as the server doesn't pick a value from 0 to 15 for C_R. A server supporting both roles may additionally use distinct sets of C_I and C_R.",
          "createdAt": "2021-03-01T13:57:01Z",
          "updatedAt": "2021-03-01T13:57:01Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The ambition is to neither require restriction of C_R, nor policies for C_I and C_R when an endpoint simultaneously acts client and server for multiple connections. As John commented above, the bstr_identifier optimization was one reason for this problem apperaring and we need to fix it, one thing to discuss at March 2 Hackathon. \r\n\r\nIs it feasible to implement according to the procedure John described? Other preferred solution?\r\n",
          "createdAt": "2021-03-01T14:53:40Z",
          "updatedAt": "2021-03-01T16:12:56Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Some comments from Hackathon:\r\n\r\n* Need to make expected processing clear \r\n* Proposal to introduce a mandatory null (0xf6) as first field in message_1\r\n\r\n",
          "createdAt": "2021-03-02T15:34:56Z",
          "updatedAt": "2021-03-31T10:50:08Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "e3f542d adds an initial null to message_1.\r\n\r\nThis is optional since it may be inferred by other means, e.g. CoAP Uri-Path.",
          "createdAt": "2021-03-31T10:53:41Z",
          "updatedAt": "2021-04-01T08:11:44Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "First draft of new section addressing expected processing: dd3e80f6",
          "createdAt": "2021-04-01T14:02:53Z",
          "updatedAt": "2021-04-01T14:02:53Z"
        },
        {
          "author": "petervanderstok",
          "authorAssociation": "NONE",
          "body": "Sorry. Reference to coap uri is a bit cryptic. Nothing is mentioned in the text?\r\n\r\nOtherwise: nice.",
          "createdAt": "2021-04-01T17:25:29Z",
          "updatedAt": "2021-04-07T07:36:00Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@petervanderstok The use of CoAP Uri-Path to distinguish messages is mentioned in the Applicability Statmement section. This section is now moved from appendix to the body, see Editor's copy on github: \r\n\r\nhttps://lake-wg.github.io/edhoc/draft-ietf-lake-edhoc.html#name-applicability-statement\r\n\r\nWe did not want to bring in CoAP specific options into the generic message processing. Is this still cryptic?",
          "createdAt": "2021-04-06T07:05:46Z",
          "updatedAt": "2021-04-06T07:05:46Z"
        },
        {
          "author": "petervanderstok",
          "authorAssociation": "NONE",
          "body": "HI Goran,\r\n\r\nI am still not quite sure what it all means.\r\nIn my concept of the world edhoc is used for coap and in a 2nd  instance \r\nfor http.\r\nAnything else may live in the heads of the writers but is not very \r\nrelevant for the current standardization effort.\r\n\r\nThis is equivalent to what we did for resource directory: in the RD \r\nanything concerning htpp has been spelled out to remove confusions.\r\nAnd yet, confusion remains....\r\n\r\nTherefore, I recommend strongly to forget about anything beyond coap and \r\nhtpp.\r\nAnd spell out how you see the use of http by introducing an htpp section \r\nnext to the coap section. (for example discovery of an edhoc path in \r\nhttp is quite different )\r\n",
          "createdAt": "2021-04-06T07:22:44Z",
          "updatedAt": "2021-04-07T07:36:14Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Provided by transport. In -08 this is described for CoAP in Appendix A.3.",
          "createdAt": "2021-07-15T19:54:35Z",
          "updatedAt": "2021-07-15T19:54:35Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU3OTQ5NzY2MDU=",
      "title": "COSE_Key content constrained according to EDHOC",
      "url": "https://github.com/lake-wg/edhoc/issues/62",
      "state": "CLOSED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @lemikev:\r\n\r\nI have a question about the following sentence on page 13.\r\n\r\nMaybe somebody on the call can explain the rational of this sentence.\r\n\r\n \r\n\r\n  \" For COSE_Keys of type EC2 the CBOR map SHALL only include the parameters 1 (kty), -1 (crv), -2 (x-coordinate), and -3 (y-coordinate). \"\r\n\r\n \r\n\r\nFirst, this sentence is incorrect since \"subject name\" is also allowed.\r\n\r\nWhy the content of the COSE_Key is constrained?\r\n\r\nWhy 2 (kid) and 3 (alg) are excluded?\r\n\r\n \r\n\r\nCan we replace \u201cSHALL only include\u201d by \u201cSHALL minimally include\u201d?",
      "createdAt": "2021-01-27T10:32:29Z",
      "updatedAt": "2021-07-26T14:17:55Z",
      "closedAt": "2021-07-24T11:50:06Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this: The COSE_Key is now replaced with UCCS, and the mandatory terminology is removed (depends on applicability statement).",
          "createdAt": "2021-07-24T11:50:06Z",
          "updatedAt": "2021-07-24T11:50:06Z"
        },
        {
          "author": "lemikev",
          "authorAssociation": "NONE",
          "body": "Thanks for the follow-up G\u00f6ran.",
          "createdAt": "2021-07-26T14:17:55Z",
          "updatedAt": "2021-07-26T14:17:55Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU3OTYxMjM5NjY=",
      "title": "When key-confirmation is needed latest",
      "url": "https://github.com/lake-wg/edhoc/issues/63",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For applications needing key-confirmation, it may help to formulate it as a requirement for the Initiator along these lines.\r\n\r\n\"The Initiator must have achieved key-confirmation through WAY_1 or WAY_2 ... before doing THIS_1 and THIS_2, and at the latest before doing THAT.\"\r\n\r\nFor instance, the Initiator might be fine to send a protected GET request even without having achieved key-confirmation yet, while the same may not be fine for a PUT request.",
      "createdAt": "2021-01-28T15:46:02Z",
      "updatedAt": "2021-05-05T16:32:01Z",
      "closedAt": "2021-05-05T16:32:01Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The only limitation would be that you should maybe not permanently store the key. There is no relation to GET POST like TLS 0-RTT data without replay. In fact it is not so much a security problem at all, its more like a normal transport problem. I has not gotten any confirmation that R received the message.  ",
          "createdAt": "2021-02-21T12:24:14Z",
          "updatedAt": "2021-02-21T12:24:14Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics can we close this?",
          "createdAt": "2021-04-22T08:49:24Z",
          "updatedAt": "2021-04-22T08:49:24Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I think so, the text in Section 8.1 builds on John's point.\r\n\r\nI just wonder if the recommendation about \"not permanently storing\" extends also to the possible application key material already derived from PRK_4x3m and TH_4.",
          "createdAt": "2021-04-22T09:38:42Z",
          "updatedAt": "2021-04-22T09:38:42Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics While this is strictly up to the application, I think it makes sense to extend this recommendation to the derived application keys, see recent commit 592c6fe.",
          "createdAt": "2021-05-04T14:03:38Z",
          "updatedAt": "2021-05-04T14:03:38Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Looks good, thanks!",
          "createdAt": "2021-05-04T14:38:28Z",
          "updatedAt": "2021-05-04T14:38:28Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": " @marco-tiloca-sics John made an update: 52b7490. \r\nStill good/ready to close the issue?",
          "createdAt": "2021-05-05T14:13:05Z",
          "updatedAt": "2021-05-05T14:13:05Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Yes, and it looks even better now.",
          "createdAt": "2021-05-05T15:23:42Z",
          "updatedAt": "2021-05-05T15:23:42Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU3OTYxMjUwMjc=",
      "title": "Max retransmissions of EDHOC messages",
      "url": "https://github.com/lake-wg/edhoc/issues/64",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thinking of CoAP for transport:\r\n\r\n1. Let's say that the Initiator (Responder) trasmits Message_1 (Message_2) as a Confirmable message, does not receive an ACK from the other peer and retransmits the message. This happens again multiple times, until the maximum number of retransmissions is reached. Should the sender peer simply discontinue the protocol?\r\n\r\n2. Let's say that the same as above happens with the Initiator (Responder) transmitting Message_3 (Message_4). Should the sender peer delete PRK_4x3m, TH_4 and any possible application keys derived with the exporter, including the possible OSCORE Security Context?",
      "createdAt": "2021-01-28T15:47:09Z",
      "updatedAt": "2021-08-26T16:43:22Z",
      "closedAt": "2021-08-26T16:43:21Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics Can we close this?",
          "createdAt": "2021-04-22T08:49:05Z",
          "updatedAt": "2021-04-22T08:49:05Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I understand that the details on retransmission and reliability are left to the used transport, but I couldn't find indications on what to do if a session \"gets stuck\" before completing.\r\n\r\nIf the next expected message does not come before a timeout possibly influenced by the used transport, I suppose this can be seen as a failure, followed by discontinuing the protocol as in other cases, so that memory and state can be freed up, and especially the allocated connection identifier can be made available again. When this involves message_3 or message_4, this possibly extends to deleting application key material already derived from PRK_4x3m and TH_4.\r\n\r\nI'm not sure if it's worth also sending an Error Message after that, but it would be at least consistent with what is done in other situations where the protocol is discontinued.",
          "createdAt": "2021-04-22T09:38:17Z",
          "updatedAt": "2021-04-22T09:38:17Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "It is not clear to me what the specification should write here. \r\n\r\nFailure in transport is out of scope for EDHOC. That the EDHOC implementation needs to get informed that transport failed to be able to free state is probably obvious?\r\n\r\nSimilarly, in order to free state of existing exporter secret or OSCORE security context, the EDHOC implementation need to get informed about it being obsolete. The OSCORE security context may expire because e.g. because exceeding the number of allowed encryptions, but there may also be  policies about lifetime out of scope of EDHOC.\r\n\r\nThe case that the endpoint sending the last message of the protocol does not know if it reached the other endpoint seems to belong to either of these two cases. \r\n",
          "createdAt": "2021-04-27T12:36:14Z",
          "updatedAt": "2021-04-27T12:36:31Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics Considering  the changes made -08, is there any further clarification needed in the specification, for EDHOC in general or for CoAP in particular?\r\n",
          "createdAt": "2021-07-15T20:04:57Z",
          "updatedAt": "2021-07-15T20:04:57Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Reading this with fresh eyes, now I think that my points are basically covered in Section 5.1 \"Message Processing Outline\", already before version -08, where:\r\n\r\n* > The protocol state is assumed to be associated to an applicability statement ... which provides the context for how messages are transported ...\r\n\r\n  explicitly involves the used transport, whatever it is and whatever the way it works.\r\n\r\n* > If the processing fails, then the protocol is discontinued, an error message sent, and the protocol state erased.\r\n\r\n  does mention the cleanup I had in mind.\r\n\r\n\r\nSo a \"processing failure\" can also be the result of a \"transport failure\", e.g., not receiving an expected next message by a certain timeout or exceeding the maximum number of admitted retransmissions.\r\n\r\nThe only possible clarification can be making this point explicit here, otherwise it seems to be already fine as is.",
          "createdAt": "2021-07-16T13:52:36Z",
          "updatedAt": "2021-07-16T13:52:36Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The text in Section 5.1 \"Message Processing Outline\" is quite general. I added \"for some reason\" to \"If the processing fails\" without going into the specific detail of that it may be lack of confirmation on transport layer.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-08-13T09:44:04Z",
          "updatedAt": "2021-08-13T09:44:04Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like this can be closed.",
          "createdAt": "2021-08-26T16:43:21Z",
          "updatedAt": "2021-08-26T16:43:21Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU3OTYxMjY1ODk=",
      "title": "Loss of Message_4",
      "url": "https://github.com/lake-wg/edhoc/issues/65",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thinking of CoAP for transport, let's say that the Responder sends Message_4 as a Non-Confirmable message, and this never reaches the Initiator.\r\n\r\nOne can expect the Initiator to eventually resend Message_3. When the Responder receives this Message_3, it has to resend the same Message_4 as above. However, it can come to understand what to do in two possible ways:\r\n\r\n1. It stores a full copy of Message_3 upon first receiving it, to check for a perfect match against the retransmitted one. This copy has to be stored until the first protected application-message is received from the Initiator.\r\n\r\n2. After having processed the first Message_3 for the first time, it keeps storing PRK_3e2m and TH_3 until the first protected application-message is received from the Initiator. Then, when receiving the retransmitted Message_3, the Responder can just process it again as it did when receiving it the first time.\r\n\r\nWhich is preferable? The first one costs more in terms of storage, but it still allows the Responder to delete the temporary PRK_3e2m and TH_3 as soon as possible, i.e. when it has completed the processing of the first received Message_3.",
      "createdAt": "2021-01-28T15:48:58Z",
      "updatedAt": "2021-05-21T19:04:29Z",
      "closedAt": "2021-05-21T19:04:28Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Good questions and points.\r\n\r\nFrom an pure EDHOC perspective, the lower layers does not really matter. After message_3 has been received and processed, the Responder should never process message_3 again and PRK_3e2m and TH_3 will have been deleted.\r\n\r\nI think 2. violated the EDHOC protocol.\r\n\r\nI think 1. is not needed. I dont think the responder needs to check message_3 again. The Initiator must not change message_3. If message_3 is changed things break, which is fine.\r\n",
          "createdAt": "2021-02-21T11:38:59Z",
          "updatedAt": "2021-02-21T11:38:59Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics Can we close this?",
          "createdAt": "2021-04-22T08:45:47Z",
          "updatedAt": "2021-04-22T08:45:47Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I think so, thanks to the last paragraph in Section 5.2. For the case in question:\r\n\r\ni) the resent message_3 would not match the protocol state on the responder;\r\nii) in general and also thanks to (i), message_3 is not reprocessed;\r\niii) also because of (i), message_4 would not be resent either (the state on the responder has moved on).\r\n\r\nSide note, though. The text in Section 5.2 also says that if (i) happens (like in this case), the protocol fails, which means it is discontinued and an Error Message is sent. Isn't this excessive for this case and perhaps other ones? This is more related to discontinuing and sending an Error Message for every possible deviation or instead admitting justified exceptions.",
          "createdAt": "2021-04-22T09:36:50Z",
          "updatedAt": "2021-04-22T09:36:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the last paragraph in the previous comment, we keep this open pending the resolution of #101                                                                                                                                                                                                                                                   ",
          "createdAt": "2021-04-27T11:04:39Z",
          "updatedAt": "2021-04-27T11:04:39Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "#101 has been closed. Closing this as well",
          "createdAt": "2021-05-21T19:04:28Z",
          "updatedAt": "2021-05-21T19:04:28Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU4MDAxODE2MjA=",
      "title": "Information in test vectors",
      "url": "https://github.com/lake-wg/edhoc/issues/66",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It would help to have also the following information explicitly specified in the test vectors.\r\n\r\n1) When authentication with signatures is used, please include also the public authentication keys. They are not strictly needed to reproduce the test vectors as stand-alone test units, since they focus on producing outgoing messages. However, they are needed to reproduce the results in full-fledged EDHOC peers, that will have to do signature verification of incoming messages.\r\n\r\n2) When using a ciphersuite with ECDSA, please include also the Y coordinate of authentication public keys.",
      "createdAt": "2021-02-03T10:15:32Z",
      "updatedAt": "2021-02-21T06:55:38Z",
      "closedAt": "2021-02-21T06:55:38Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "1. I have added public authentication keys to my test vector code, which will used for -05\r\n2. We currently do not have any ECDSA test vectors. Maybe for -06",
          "createdAt": "2021-02-12T15:08:25Z",
          "updatedAt": "2021-02-12T15:08:25Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated #47 with this info. Will close this",
          "createdAt": "2021-02-21T06:55:38Z",
          "updatedAt": "2021-02-21T06:55:38Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU4MDAxOTY2MTI=",
      "title": "REST code for EDHOC Error Message as CoAP response",
      "url": "https://github.com/lake-wg/edhoc/issues/67",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The following is a possible exchange that might happen, if using the \"EDHOC-in-OSCORE\" optimization proposed in [1].\r\n\r\n1. The Initiator (as CoAP client) sends an OSCORE-protected request, embedding both EDHOC Message 3 and the actual request payload protected with the just-established Security Context, as per the proposed approach.\r\n\r\n2. The Responder (as CoAP server) processes EDHOC Message 3. If this processing fails, the Responder replies with an unprotected EDHOC error message. As of today, this would be a 2.04 response, hence a successful response for CoAP.\r\n\r\nHowever, as per [2], \"A successful response to a request with the OSCORE option SHALL contain the OSCORE option.\" Thus, when receiving the unprotected 2.04 response above, the Initiator would experience an OSCORE failure, which is fine and consistent per se.\r\n\r\nHowever, if the OSCORE processing happens before the EDHOC processing on the Initiator, it might become impossible to access and process the actual response content, i.e. the EDHOC Error Message. Whether which of the two processing comes first is implementation specific.\r\n\r\nAn easy way out would be to rather have the EDHOC Error Message sent as a CoAP error response. On the Initiator, the response would then be not discarded by OSCORE, and would ensure a correct processing of the EDHOC Error Message.\r\n\r\n[1] https://datatracker.ietf.org/doc/draft-palombini-core-oscore-edhoc/\r\n[2] https://tools.ietf.org/html/rfc8613#section-2",
      "createdAt": "2021-02-03T10:34:28Z",
      "updatedAt": "2021-05-07T14:41:45Z",
      "closedAt": "2021-05-07T14:41:45Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "First update of text on transport of error message, see 75d8dd7.\r\n@marco-tiloca-sics Please comment.",
          "createdAt": "2021-02-11T21:34:59Z",
          "updatedAt": "2021-02-11T21:34:59Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "In general, it would be good to better understand what issues are avoided when cross-protocol proxies are used.\r\n\r\nOtherwise, the new content can be split and rephrased as follows, i.e. part as general and part as specific to CoAP.\r\n\r\n[Section 6.1 - \"EDHOC Error Message]\r\n\r\nAn EDHOC error message can be sent by either endpoint as a reply to any non-error EDHOC message. How errors at the EDHOC layer are transported depends on lower layers, which need to enable error messages to be sent and processed as intended.\r\n\r\nEDHOC errors sent as transport-successful messages can avoid issues created by usage of cross protocol proxies (e.g. UDP to TCP).\r\n\r\n[Section 7.2 \"Transferring EDHOC in CoAP\"]\r\n\r\nEDHOC errors SHOULD be sent as POST requests and 2.04 (Changed) responses. An exception is the combined EDHOC-in-OSCORE case {{I-D.palombini-core-oscore-edhoc}}, where an error message response following a combined EDHOC message_3/OSCORE request needs to be sent with a CoAP error code.\r\n",
          "createdAt": "2021-02-12T10:19:02Z",
          "updatedAt": "2021-02-12T10:19:02Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Following on the original comment and building on more recent discussions, another advantage of having EDHOC Error Messages as CoAP error responses is that they would become cacheable.",
          "createdAt": "2021-03-11T15:42:50Z",
          "updatedAt": "2021-03-11T15:42:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we have addressed this issue. We have removed the statement about avoiding cross protocol proxies (92d9a98d) which wasn't clear, tuned down the requirement on transport (41cf0e9fe) and moved OSCORE processing to the CoRE draft. \r\n\r\nI close this issue now, we can always reopen if there is something we missed.",
          "createdAt": "2021-05-07T14:41:45Z",
          "updatedAt": "2021-05-07T14:41:45Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU4MDU0NDUwOTQ=",
      "title": "More information about certificate transport",
      "url": "https://github.com/lake-wg/edhoc/issues/68",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "v-05"
      ],
      "body": "Peter is requesting the specification to provide more information about transporting a certificate in ID_CRED_x, to support a BRSKI use case and to improve interoperability. \r\n",
      "createdAt": "2021-02-10T11:52:16Z",
      "updatedAt": "2021-02-22T17:45:36Z",
      "closedAt": "2021-02-22T17:45:36Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Are you sure the \"more infroamtion\" should be in EDHOC and not in COSE?",
          "createdAt": "2021-02-10T16:27:54Z",
          "updatedAt": "2021-02-10T16:27:54Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@petervanderstok Does this address your comment?",
          "createdAt": "2021-02-11T20:26:23Z",
          "updatedAt": "2021-02-11T20:26:23Z"
        },
        {
          "author": "petervanderstok",
          "authorAssociation": "NONE",
          "body": "I thought the issue was solved,\r\nby additionally specifying for ID_CREDx:  {5chain: DER} wher DER is a bstr containing a certificate in DER\r\n5chain to be defined in COSE registry",
          "createdAt": "2021-02-12T11:50:34Z",
          "updatedAt": "2021-02-12T11:50:34Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Both the commit and Peter's comment seem restricted to a single certificate, not a general chain.\r\n",
          "createdAt": "2021-02-12T12:03:02Z",
          "updatedAt": "2021-02-12T12:03:02Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@petervanderstok x5chain is already defined to be exactly this. See the last sentence of https://tools.ietf.org/html/draft-ietf-cose-x509-08#section-2\r\nThere is already a temporary label assigned, namely 33, see https://www.iana.org/assignments/cose/cose.xhtml#header-parameters\r\n",
          "createdAt": "2021-02-12T13:14:29Z",
          "updatedAt": "2021-02-12T13:14:29Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@emanjon Yes, this was just an example intended to clarify how to transport a credential. As you previously commented, it is not clear if this information should be in EDHOC or in some COSE draft, but since transport of credential was not sufficiently clear, at least one example like this was needed. This does not exclude that we add more information about credential transport, perhaps as a separate section?",
          "createdAt": "2021-02-12T13:26:22Z",
          "updatedAt": "2021-02-12T13:26:22Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@emanjon It was only a minor change to the text to also cover certificate chains, see aeaadb8",
          "createdAt": "2021-02-18T11:34:23Z",
          "updatedAt": "2021-02-18T11:34:23Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The latest text is also strange technically. Can be several values in ID_CRED_ID and Cred_X does not have to be one the values. I think this \"explanation\" makes things worse.",
          "createdAt": "2021-02-21T06:29:11Z",
          "updatedAt": "2021-02-21T06:29:11Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with b5346fb1",
          "createdAt": "2021-02-22T17:45:36Z",
          "updatedAt": "2021-02-22T17:45:36Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU4MDU2NzA4ODM=",
      "title": "Make clear that non-ECC signature algorithms are allowed.",
      "url": "https://github.com/lake-wg/edhoc/issues/69",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The specification that a cipher suite includes \"EDHOC signature algorithm curve\" make it seems like only ECC signature algorithms can be used. That is not the intension. PS256, HSS-LMS, and future PQC should be allowed.",
      "createdAt": "2021-02-10T16:30:42Z",
      "updatedAt": "2021-05-21T19:03:32Z",
      "closedAt": "2021-05-21T19:03:32Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR to begin to adress this problem #106. This was an old know issue that was not transfered from the old GitHub repository.\r\n\r\nIn the PR is it explained that algorithms might have parameters and that parameters need to be included so hat the algorithm is determined.\r\n\r\nWhile making the PR, it struck me that the signature algorithm curve is not needed at all and in COSE and X.509 terms this is determined by the public key algorithm. I think this needs to be addresses. Either we remove the signature curve from the cipher suite completely or we specify it as a profiling of the public key. Profiling the public key is however problematic as it is not a COSE key and may be any PKIX algorithm that may not even be standardized for COSE at all. I do not think there is any reason to restrict PKIX.\r\n\r\nMy suggestion is that we remove the public key parameters from the cipher suite.\r\n\r\n",
          "createdAt": "2021-04-25T09:20:35Z",
          "updatedAt": "2021-04-25T09:20:35Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #106 is merged with master. Any further comments on this?",
          "createdAt": "2021-05-07T14:30:42Z",
          "updatedAt": "2021-05-07T14:30:42Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR has been discussed and merged. Closing",
          "createdAt": "2021-05-21T19:03:32Z",
          "updatedAt": "2021-05-21T19:03:32Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWU4MDc3MDgyNTk=",
      "title": "Message_4 ",
      "url": "https://github.com/lake-wg/edhoc/issues/70",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Making key confirmation or introducing signaling to indicate that message_4 should be seem to both introduce comlexity. I suggest that message_4 is moved to things that \"parameters to be agreed upon between Initiator and Responder\". This works well for example EAP-EDHOC (if message_4 would be included there).\r\n\r\nAny text on key confirmation should just be guidance.\r\n\r\nThe AEAD calculation in message_4 is not needed. We are taking the output from one PRF to generate output from a second (probablypu worse) PRF. I suggest that we just put the output from the exporter in message_4.\r\n\r\n\"Applicability Statement Template\"  -   Is it only me that do not understand at all what this appendix is about by reading the heading in the toc?\r\n",
      "createdAt": "2021-02-13T08:47:50Z",
      "updatedAt": "2021-02-22T17:56:19Z",
      "closedAt": "2021-02-22T17:56:19Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a lot of the text in the message_4 section can be removed and replaced with\r\n\r\nMAC_4 is  EDHOC-Exporter( \"EDHOC_message_4_MAC\", length )",
          "createdAt": "2021-02-13T09:33:09Z",
          "updatedAt": "2021-02-13T09:33:09Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Applicability Statement Template\" - I think it should be understood in the following way. This appendix lists the different protocol parameters and settings that the application needs to ensure are configured/agreed between the endpoints. An \"applicability statement\" corresponds to a configuration with certain settings. An applicability statement template is a template for what are the parameters and settings that needs to be specified and guidance for how to set them.\r\n\r\nOther proposals for title are welcome. \r\n",
          "createdAt": "2021-02-15T09:33:38Z",
          "updatedAt": "2021-02-15T09:33:38Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree that how the Initiator gets key confirmation needs to be left application dependent. But I would like to avoid to leave this completely open. Can we keep a statement that maintains this intent:\r\n\r\n\"In deployments where no protected application message is sent from the Responder to the Initiator, the Responder MUST send message_4.\"\r\n\r\n* One comment was that this is not possible to verify.\r\n* What if the applicability statement specifies R to send an OSCORE response, but R cannot enforce that, e.g. in case there is an error with the request?\r\n",
          "createdAt": "2021-02-15T09:53:52Z",
          "updatedAt": "2021-02-15T09:53:52Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "\"In deployments where no protected application message is sent from the Responder to the Initiator, the Responder MUST send message_4.\"\r\n\r\nThat sounds very good to me. I don't see any need for any more text.\r\n",
          "createdAt": "2021-02-15T16:44:31Z",
          "updatedAt": "2021-02-15T16:44:31Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The text is included in section 7.1",
          "createdAt": "2021-02-22T17:56:19Z",
          "updatedAt": "2021-02-22T17:56:19Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU4MTIwNDU0NTU=",
      "title": "Deterministic CBOR encoding of e.g. CBOR intergers",
      "url": "https://github.com/lake-wg/edhoc/issues/71",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Migth be a good idea that the method should be encoded as 01 instead of 0001, 00000001, 0000000000000001.\r\n\r\nWe should look through the drafy.",
      "createdAt": "2021-02-19T13:58:34Z",
      "updatedAt": "2021-04-20T05:51:06Z",
      "closedAt": "2021-04-20T05:51:06Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I will start adding a sentence or two regarding this to the draft for the next submission.",
          "createdAt": "2021-04-19T11:24:54Z",
          "updatedAt": "2021-04-19T11:24:54Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Commit in 31b338a",
          "createdAt": "2021-04-20T04:43:19Z",
          "updatedAt": "2021-04-20T04:43:19Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU4MTI3ODQ4MjA=",
      "title": "Strange places to mention draft-palombini-core-oscore-edhoc",
      "url": "https://github.com/lake-wg/edhoc/issues/72",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "draft-palombini-core-oscore-edhoc is mention several times in general places it should maybe not be mentioned.\r\n\r\ndraft-palombini-core-oscore-edhoc is not mention in \r\n7.2.  Transferring EDHOC in CoAP\r\nwhere it should absolutly be mentioned.\r\n",
      "createdAt": "2021-02-21T06:17:32Z",
      "updatedAt": "2021-04-19T14:05:27Z",
      "closedAt": "2021-04-19T14:05:27Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "draft-palombini-core-oscore-edhoc (now draft-ietf-core-oscore-edhoc) is now only mentioned in 7.2.2, so the issue is seemingly resolved.\r\n\r\nBut we probably want to make more changes here. draft-ietf-core-oscore-edhoc is already mentioning combined use of OSCORE and EDHOC, so we may want to move section 7.2.1. \"Deriving an OSCORE Context from EDHOC\" and the last part of section 7.2.2 to that draft.\r\n\r\nIn which case we would want to keep a reference of draft-ietf-core-oscore-edhoc in 7.2.0.\r\n\r\n(Note also changes proposed in 7.2.2: #91 )",
          "createdAt": "2021-04-09T09:45:06Z",
          "updatedAt": "2021-04-09T09:45:06Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWU4MTI3OTE1Mjc=",
      "title": "Unclear which parts of the spec that are MTI",
      "url": "https://github.com/lake-wg/edhoc/issues/73",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The things that are Mandatory or optional to support or now spread out in various places.",
      "createdAt": "2021-02-21T07:07:26Z",
      "updatedAt": "2021-09-10T09:44:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This does not need to be a new section (like the MTI section in TLS 1.3) but it definitly needs to be clear what in the draft is mandatory to implement or not. Could be as simple as stating.\r\n\r\n- Everything is mandatory\r\n- Nothing is mandatory\r\n- Something in between\r\n\r\nCurrently is is undefined which is not good I think ",
          "createdAt": "2021-05-05T10:03:47Z",
          "updatedAt": "2021-05-05T10:03:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I started making an MTI section inspired by RFC 8446. I think this makes things clearer.\r\n\r\nI added some editorial notes in the section that needs to be discussed.",
          "createdAt": "2021-09-10T09:44:33Z",
          "updatedAt": "2021-09-10T09:44:33Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU4MTI4MjEyNjI=",
      "title": "Classes of Error messages.",
      "url": "https://github.com/lake-wg/edhoc/issues/74",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "At the last interim there was a suggestion to standardize classes of error messages and to ask the IoT groups in IETF about what classes of error messages that should be standardized.\r\n\r\n- The error message should then be augmented with a error message class. int? array of int?\r\n- Shoudl the optional text string remain. That cannot be used for any automation. But might be useful for loggging for later reading by a human. The initial classes or error message might not provide much info, e.g. \"authentication error\"\r\n",
      "createdAt": "2021-02-21T10:21:04Z",
      "updatedAt": "2021-05-21T19:03:14Z",
      "closedAt": "2021-05-21T19:03:14Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Mailthread in iotops:\r\nhttps://mailarchive.ietf.org/arch/msg/iotops/KcWcK19kACOYnimRqFNJDBu_MAk/\r\n",
          "createdAt": "2021-02-21T17:12:47Z",
          "updatedAt": "2021-02-21T17:12:47Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal after discussion in Hackathon:\r\n\r\nerror = (\r\n\u00a0 ? C_x : bstr_identifier,\r\n\u00a0 \u00a0 DIAG_MSG : tstr,\r\n\u00a0\u00a0\u00a0 ERR_CODE : int / 2* int,\r\n\u00a0 ? SUITES_R : [ supported : 2* suite ] / suite,\r\n)\r\n\r\nTop-level ERR_CODEs:\r\n\r\n(0. Success)\r\n1. Message field error (syntax error or incorrect protocol field of expected message)\r\n2. Selected cipher suite not supported (include SUITES_R in message)\r\n3. Credential/context error (error related to establish certificate/raw public key context for processing message, including certificate expired, revoked, unsupported, corrupt, unknown CA, or other issue in processing the credential)\r\n4. Decrypt error (a cryptographic operation failed, including being unable to correctly verify a signature or a MAC in the protocol message)\r\n5. Auxiliary data error (unsupported or missing auxiliary data)\r\n6. Access denied (credential valid but peer not allowed access)\r\n7. Internal error (error not related to the protocol or the peer)\r\n\r\nSelected comments during Hackathon:\r\n- Relation to errors on other layer, e.g. CoAP errors or error in application. \r\n- - EDHOC does not require CoAP so could have use for specified own errors.\r\n- - Does \"5. AD error\" belong to EDHOC?  Perhaps, auxiliary data provides means for security applications to reuse EDHOC and this would be a channel to send errors in those applications. [Not sure if this helps but, alternatively, errors could be encoded as auxiliary data, which may require an AD-field in the error message]\r\n- - Does \"6. Access denied\" belong to EDHOC? Perhaps, it provides a suitable error to the requirement \"Verify that the identity of the Responder is an allowed identity for this connection\"\r\n\r\n\r\nFurther comments are welcome. Happy to make the list shorter if possible. ",
          "createdAt": "2021-03-02T15:29:50Z",
          "updatedAt": "2021-03-02T15:29:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Other thoughts:\r\n\r\n* We can put some of these error classes into an \"x. unspecified error\" bucket if we don't think they are not meaningful to act upon individually. \r\n\r\n* We can define a class of errors \"y. general error\" and allow implementations to use class y for any error, including those properly belonging to some class above. This would allow implementations to only support some of the specified errors above, potentially listed in the applicability statement. (That would render the list of classes above just a RECOMMENDATION.)\r\n\r\n\r\n\r\n",
          "createdAt": "2021-03-02T15:31:06Z",
          "updatedAt": "2021-03-02T15:31:06Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Many OSs, shells, and programming languages (e.g. C) use 0 for success and everthing non-zero (negative or positive) is considered an error. HTTP and Coap use postive numbers only where 2. or 2xx is considered success.\r\n\r\nI think we should probably follow one of these convensions instead of making a new one.\r\n\r\nThe specification should also probably define that everything else than whatever we decide for success is considered an error.\r\n",
          "createdAt": "2021-04-21T09:31:03Z",
          "updatedAt": "2021-04-21T09:31:03Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR #113 addressing all known issues regarding this.  ",
          "createdAt": "2021-05-05T09:58:00Z",
          "updatedAt": "2021-05-05T09:58:00Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This is ready to merge unless there are any objections.",
          "createdAt": "2021-05-07T13:36:56Z",
          "updatedAt": "2021-05-07T13:36:56Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR has been discussed and merged. Closing",
          "createdAt": "2021-05-21T19:03:14Z",
          "updatedAt": "2021-05-21T19:03:14Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU4MTI4MzA4MjE=",
      "title": "Move 7.2.  Transferring EDHOC in CoAP to draft-palombini?",
      "url": "https://github.com/lake-wg/edhoc/issues/75",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "7.2 was written before draft-palombini existed. Would it make sense to move all OSCORE specific informaiton to draft-palombini and make that draft more general. Right now you probably have to read both. A lot of the new issues and discussion are concerning the OSCORE EDHOC interaction.",
      "createdAt": "2021-02-21T11:18:13Z",
      "updatedAt": "2021-07-16T08:15:29Z",
      "closedAt": "2021-07-16T08:15:29Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "As there has been no comment on this issue, we now plan for moving out section 7.2.1 and second half of 7.2.2 to draft-ietf-core-oscore-edhoc (former draft-palombini- ...)",
          "createdAt": "2021-04-23T13:12:29Z",
          "updatedAt": "2021-04-23T13:12:29Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "This makes sense for me.",
          "createdAt": "2021-04-23T14:10:13Z",
          "updatedAt": "2021-04-23T14:10:13Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Yes, that makes sense.",
          "createdAt": "2021-04-24T08:46:40Z",
          "updatedAt": "2021-04-24T08:46:40Z"
        },
        {
          "author": "rikard-sics",
          "authorAssociation": "NONE",
          "body": "Sounds good to me also.",
          "createdAt": "2021-04-27T12:46:31Z",
          "updatedAt": "2021-04-27T12:46:31Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed during the last interim, I do not believe removing the link of draft-ietf-lake-edhoc with OSCORE is a good idea from the charter point of view of the LAKE WG.\r\n\r\nI just went through the editor's version of draft-ietf-core-oscore-edhoc and here is my proposal forward:\r\n\r\n* Create a new appendix in draft-ietf-lake-edhoc named \"Use with OSCORE\", say Appendix A.\r\n* Move the content of Section 4 of draft-ietf-core-oscore-edhoc back to draft-ietf-lake-edhoc, to Appendix A.1.\r\n* Merge the content of Section 3 of draft-ietf-core-oscore-edhoc with the content in Section 7.2 of draft-ietf-lake-edhoc. Move the result to Appendix A.2.\r\n\r\nWith that, draft-ietf-lake-edhoc contains all the information to implement EDHOC and use it to key OSCORE. draft-ietf-core-oscore-edhoc becomes streamlined and focuses on optimizing the specific use case when message_3 and OSCORE request are sent in the same CoAP message for performance reasons.",
          "createdAt": "2021-06-24T13:30:50Z",
          "updatedAt": "2021-06-24T13:30:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@malishav @mcr I believe -08 does exactly what you requested. Can we close this?",
          "createdAt": "2021-07-15T20:07:30Z",
          "updatedAt": "2021-07-15T20:07:30Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM, closing",
          "createdAt": "2021-07-16T08:15:29Z",
          "updatedAt": "2021-07-16T08:15:29Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU4MTMyNjc3MDk=",
      "title": "appendix b.1.1",
      "url": "https://github.com/lake-wg/edhoc/issues/76",
      "state": "CLOSED",
      "author": "petervanderstok",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some typos in appendix B.1\r\npage 51,\r\n G_X (Initiator\u2019s ephemeral public key) (32 bytes)\r\n 89 8f f7 9a 02 06 7a 16 ea 1e cc b9 0f a5 22 46 f5 aa 4d d6 ec 07 6b ba\r\n 02 59 d9 04 b7 ec 8b 0c\r\nprobably a typo in the key value because not accepted by mbedtls \r\n\r\nGS: Seems identical to test-vector.txt. Perhaps someone else can confirm this?\r\n\r\npage 57,\r\nMAC_2 (8 bytes) mention that this is the length of the tag.\r\n\r\nGS: Using \"CBOR unencoded\". See new text in appendix.\r\n\r\npage 58\r\nK_2e = HKDF-Expand( PRK, info, length )\r\nPRK relaced by prk_3e2m\r\n\r\n-> GS: Replaced with PRK_2e. (As of -04 formulated in terms of KEYSTREAM_2)\r\n\r\npage 62,\r\nMAC_3 (8 bytes) mention that this is tag length\r\n\r\n-> GS: Using \"CBOR unencoded\".\r\n\r\npage 63\r\nThe Plaintext is the following CBOR Sequence: plaintext = ( ID_CRED_I\r\n , Signature_or_MAC_3 )\r\nshould this not be h'Signature_or_MAC_3'\r\n\r\n-> GS: Using \"CBOR unencoded\".\r\n\r\npage 64,\r\nNonce IV_3ae is the output of HKDF-Expand(PRK_3e2m, info, L).\r\nI had understood that PRK_4x3m should be used.\r\n\r\n-> No this is actually correct. See section 4.0: \"K_3ae and IV_3ae are derived using the transcript hash TH_3 and the pseudorandom key PRK_3e2m. \"\r\n\r\npage 65\r\nmessage_3 =\r\n (\r\n h\u201913\u2019,\r\n h\u2019\u2019\r\n )\r\nshould be :\r\n\r\nmessage_3 =\r\n (\r\n h\u201913\u2019,\r\n h'CIPHERTEXT_3\u2019\r\n )\r\n\r\n-> GS: Using \"CBOR unencoded\".",
      "createdAt": "2021-02-22T08:29:48Z",
      "updatedAt": "2021-03-02T14:55:13Z",
      "closedAt": "2021-03-02T14:55:13Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@petervanderstok Edited previous comment. Please let me know if there are further comments.",
          "createdAt": "2021-02-22T17:54:27Z",
          "updatedAt": "2021-02-22T17:54:27Z"
        },
        {
          "author": "petervanderstok",
          "authorAssociation": "NONE",
          "body": "the mbedtls library only support a basic curve25519 set.\r\nFor that reason many ecdh ephemeral keys are refused in my impementation.\r\n\r\nIs it posible to only support the basic set in edhoc?",
          "createdAt": "2021-03-02T11:27:21Z",
          "updatedAt": "2021-03-02T11:27:21Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed as discussed during Hackathon.",
          "createdAt": "2021-03-02T14:55:13Z",
          "updatedAt": "2021-03-02T14:55:13Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU4MTMyNjk5NzY=",
      "title": "use of 5chain",
      "url": "https://github.com/lake-wg/edhoc/issues/77",
      "state": "CLOSED",
      "author": "petervanderstok",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "on page 14 would it not be suitable to add that\r\nID_CRED_x = { x5chain : certificate in DER }, for x = I or R,",
      "createdAt": "2021-02-22T08:32:29Z",
      "updatedAt": "2021-02-22T17:43:18Z",
      "closedAt": "2021-02-22T17:43:18Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Very timely comment. I just made an update to this effect, see b5346fb. I didn't want to include this kind of notation as it requires explanation. Is it good enough?\r\n",
          "createdAt": "2021-02-22T10:26:24Z",
          "updatedAt": "2021-02-22T10:26:24Z"
        },
        {
          "author": "petervanderstok",
          "authorAssociation": "NONE",
          "body": "Suggest to give it a bullet as well.\nG\u00f6ran Selander schreef op 2021-02-22 11:26:\n\n> Very timely comment. I just made an update to this effect, see b5346fb [1]. I didn't want to include this kind of notation as it requires explanation. Is it good enough? \n> \n> --\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub [2], or unsubscribe [3].\n \n\nLinks:\n------\n[1]\nhttps://github.com/lake-wg/edhoc/commit/b5346fb15acba5116b97808415e77bf91d044e74\n[2] https://github.com/lake-wg/edhoc/issues/77#issuecomment-783268938\n[3]\nhttps://github.com/notifications/unsubscribe-auth/ADCZGQLVOZUOR4WZG2V3ZPTTAIWN5ANCNFSM4YACBI2A",
          "createdAt": "2021-02-22T10:41:04Z",
          "updatedAt": "2021-02-22T10:41:04Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "MDU6SXNzdWU4MTYyOTg1OTY=",
      "title": "JSON test vector format for automatic parsing",
      "url": "https://github.com/lake-wg/edhoc/issues/78",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "We have gotten feedback that the test vectors should be in JSON intead (or in addition) of a text file. I plan to fix this. ",
      "createdAt": "2021-02-25T10:22:57Z",
      "updatedAt": "2021-09-11T06:36:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1\r\n\r\nI think this would make it a lot easier to create unit tests for the implementations.\r\n\r\nI've provided an example how I have structured the test vectors in JSON format.\r\n\r\nhttps://github.com/TimothyClaeys/EDHOC-C/blob/master/test/test_vectors/vector1.json\r\n\r\nAll data that is needed and computed by both sides is combined under the key 'S (shared)'. Input that is only required by one of the peers is put under the keys 'I' and 'R', respectively.",
          "createdAt": "2021-03-09T10:53:15Z",
          "updatedAt": "2021-03-09T10:55:26Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @TimothyClaeys !\r\n\r\nComments on the proposal are welcome!\r\n\r\nIn the interest of increasing the number of test vectors we should also set up how people can input their results using this template, when we have agreed on it. \r\n\r\nFor that we also need to have a well defined input in JSON, any proposal?",
          "createdAt": "2021-04-16T14:58:07Z",
          "updatedAt": "2021-04-16T14:58:07Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for this, it looks good!\r\n\r\nAs a general comment, I would have to produce new output for several sub-elements and in this particular format (which is fine).\r\n\r\nMore specific comments:\r\n\r\n* To fully cover the considered configuration, 'auth_key' in the \"I\" and \"R\" objects should also include the string to use as subject name when building CRED_x.\r\n\r\n* 'secret' can be better renamed to 'g_xy'.\r\n\r\n* Why including 'p_2m' and 'p_3m' in the \"S\" object? They are always the empty byte string.\r\n\r\n* As to 'a_2m', 'a_3m' and 'a_3ae in the \"S\" object, they are available for me to print only deep in the COSE library I use, so not really in my actual implementation. That's why now I'm easily printing only the actual external data (i.e. << TH_2, CRED_R, ? AD_2 >>, << TH_3, CRED_I, ? AD_3 >> and  << TH_3, CRED_I, ? AD_3 >>). So, I would have to manually (re-)build the AAD array just for printing it, considering also the \"Encrypt0\" context string and << ID_CRED_X >>.\r\n\r\n* The \"S\" object may include the further elements related to message_4 when this is used.",
          "createdAt": "2021-04-24T10:30:07Z",
          "updatedAt": "2021-04-24T10:30:07Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we need to compile somewhere the CBOR used to create this data? For example, that \"eph_key\" = {1: 1, -1: 4, -2: h' ... ', -4: h' ... '} in this case?\r\n\r\n(Section 3.5 already says:\r\n\"The ECDH ephemeral public keys are formatted as a COSE_Key of type EC2 or OKP according to Sections 7.1 and 7.2 of [I-D.ietf-cose-rfc8152bis-algs] \" but may not be obvious on first encounter with the test vector.)\r\n\r\n",
          "createdAt": "2021-04-27T12:59:18Z",
          "updatedAt": "2021-04-27T12:59:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I very quickly transformed my -10 test vectors to JSON (or almost JSON as JSON forbids a trailing comma.....)\r\n\r\nhttps://github.com/lake-wg/edhoc/tree/master/test-vectors-10-json\r\n\r\nI just quickly tried to convert my test vecors to JSON. I tried to somewhat align with Timothy, but there are differences. In my test vectors, names ending with _raw and not CBOR and everything else are CBOR sequences. \r\n\r\nHappy to change my JSON test vectors to any format implementors would want.",
          "createdAt": "2021-09-06T13:41:25Z",
          "updatedAt": "2021-09-06T14:46:38Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I merged my two cpp files. JSON can now be found in\r\n\r\nhttps://github.com/lake-wg/edhoc/tree/master/test-vectors-10\r\n\r\n@TimothyClaeys and @marco-tiloca-sics if you agree on a JSON format, I'll update my output to match that. I don't have any opinions about the JSON format. Now I just made something very quick that aligned with the draft out that is used in the draft.\r\n",
          "createdAt": "2021-09-09T12:02:59Z",
          "updatedAt": "2021-09-09T12:02:59Z"
        },
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @emanjon,\r\n\r\nI think this looks good. Maybe a small remark: for automatic parsing purposes, I might be useful to put each test case in a parent JSON structure. Something like this:\r\n\r\n`\r\n{\r\n    \"test_vector_1\": {\r\n        \"method\": 0,\r\n        \"suites_i\": \"00\",\r\n        ...\r\n     },\r\n     \"test_vector_2\": {\r\n        \"method\": 1,\r\n        \"suites_i\": \"01\",\r\n        ...\r\n      }\r\n}\r\n`",
          "createdAt": "2021-09-09T12:34:24Z",
          "updatedAt": "2021-09-09T12:34:24Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me too; I agree with Timothy's point.",
          "createdAt": "2021-09-09T15:15:59Z",
          "updatedAt": "2021-09-09T15:15:59Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, I added a parent map as suggested by Timothy. I also removed the extra commas to make the output correct JSON.",
          "createdAt": "2021-09-09T15:44:12Z",
          "updatedAt": "2021-09-09T15:44:12Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "If we are happy enough the current format, I plan to close this issue soon. Any future changes can be discussed in the general #47 or in new issues. ",
          "createdAt": "2021-09-11T06:36:00Z",
          "updatedAt": "2021-09-11T06:36:00Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU4MTg5NDMwODk=",
      "title": "Coding density for bstr_identifier",
      "url": "https://github.com/lake-wg/edhoc/issues/79",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We could increase (by a factor of about 3) the number of identifier values encodable in 2-byte bstr_identifier -- if rather than treating them as a byte string toward the application, we treat them as distinct integer and bytes values.\r\n\r\nAs before, the same 1-byte values could be encoded (-24 to 23). Of the 2-byte long encodings, there there would be ~3x256 inhabited ones (unlike now, ~256): We could use the 256 `18 xx` (for xx > 24 as those would be encoded in a single byte), `38 xx` (again, xx < 24 staying uninhabited) and the `41 xx` (1-long byte strings) values.\r\n\r\nWhether this makes implementation harder or easier is IMO dependent on the programming style; for me it'd make things easier. (Implementers can't store the value as a length-delimited bytestring with a custom encoder any more, but can still store the CBOR encoded item in an opaque string).\r\n\r\nThis would also allow applications that find it easier to work with small numbers to just use numeric identifiers for everything they mint themselves, and use these in lookup. (These then lose some of the benefits of identifier compression.)",
      "createdAt": "2021-03-01T14:52:52Z",
      "updatedAt": "2021-07-16T12:26:27Z",
      "closedAt": "2021-07-16T12:26:27Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Considering how the OSCORE extractor uses C_I and C_R, this would be problematic.\r\n\r\nOptions are:\r\n1. Leave it as is -- with only ~256 2-byte C_x available\r\n2. Allow arbitrary int / bstr as bstr_identifier, but move the text over to the OSCORE extraction to say that this mapping is applied between C_x and `kid`. That would leave the general applications with the wide possibilities, while OSCORE would have the 0-length KID in a 1-byte bstd_identifier, a few selected KIDs (00 to 18) also in the 1-byte bstr_identifier, and all the others in len+1 bstr_identifier slots.\r\n3. Go for even more efficiency (but that has minimal returns at great complexity so is almost certainly not worth it)\r\n\r\nI have a soft preference for 2, but 1 is probably fine as well -- given that OSCORE will be a main user of EDHOC and couldn't use the optimization.",
          "createdAt": "2021-03-04T17:02:31Z",
          "updatedAt": "2021-03-04T17:02:31Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think 2 is the right way to go. I think we should do that. I think the current specification of bstr_identifier is a bit complex. We have gotten several comment and questions regarding this. I think 2 make things simpler. ",
          "createdAt": "2021-04-19T11:23:45Z",
          "updatedAt": "2021-04-19T11:23:45Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a pull request for this issue. @chrysn check that the transformation between C_x and OSCORE ID is what you wanted. I did not see any point in making it more complex.\r\n\r\nI just realized that we could expand the number of 1 byte excodings with almost 50 % by also allowing major type seven I.e.\r\n\r\nC_x : bstr / int / #7 \r\n\r\n(null is reserved for used by C_1)",
          "createdAt": "2021-04-22T11:30:10Z",
          "updatedAt": "2021-04-22T11:30:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Even with this change the bstr_identifier stays for its use in compressing ID_CRED_x when kid is used i.e. { 4 : kid_R }. ",
          "createdAt": "2021-04-22T11:39:51Z",
          "updatedAt": "2021-04-22T11:39:51Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Or maybe we can not use #7 as the values 0..19 are unassigned",
          "createdAt": "2021-04-22T13:33:05Z",
          "updatedAt": "2021-04-22T13:33:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue needs to wait until we have decided what to do with correlation. Suggestions on the table are diverse\r\n- to leave it to lower layers\r\n- make all C_x mandatory ",
          "createdAt": "2021-05-04T10:41:52Z",
          "updatedAt": "2021-05-04T10:41:52Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Next step (from current discussion): provide PR, and describe (explicitly and locally) how an integer can encode for a `{4: x}` value. Then we can discuss further based on that.\r\n\r\nAlternative: explain bstr_identifier better.\r\n\r\nOther alternative: just let a bstr encode for `{4: x}` -- that allows having a single one-byte value still (rather than ~48), and 256 two-byte values. Good enough for the cases where there *is* one distinct to-be-optimized-for peer, and in how many cases is 48 enough?",
          "createdAt": "2021-05-17T14:15:07Z",
          "updatedAt": "2021-05-17T14:28:57Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": ">Other alternative: just let a bstr encode for {4: x} -- that allows having a single one-byte value still (rather than ~48), >and 256 two-byte values. Good enough for the cases where there is one distinct to-be-optimized-for peer, and in how >many cases is 48 enough?\r\n\r\nThat is a good observation. Might be useful with two values when the distinct to-be-optimized-for peer updates its key.\r\n\r\n\r\nIf bstr_identifier is not used for connection id, maybe the bstr_identifier section could be removed and replaced by:\r\n\r\n* plaintext = ( ID_CRED_R / bstr / int, Signature_or_MAC_2, ? AD_2 )\r\n\r\n* If ID_CRED_R contains a single 'kid' parameter, i.e., ID_CRED_R = { 4 : kid_R }, only the kid_R is conveyed in the plaintext. If \u2018kid\u2019 is in the interval h'00' to h'2f\u2019, it is encoded as the corresponding integer minus 24, instead. I.e. { 4 : h\u20192a\u2019 } is encoded as the integer 18, while { 4 : h'' } is encoded as h\u2019\u2019.\r\n\r\n",
          "createdAt": "2021-05-18T07:15:53Z",
          "updatedAt": "2021-05-18T07:15:53Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Specifically for the 'kid' use of bstr_identifier, how about registering a new CBOR Header Parameter  (https://www.iana.org/assignments/cose/cose.xhtml) called, say, 'kid-int' with same function as 'kid' but where the value is a CBOR int instead of a CBOR bstr.\r\n\r\n~~~~~~~~~~\r\n   +-----------+-------+----------------+-------------+----------------+-------------------+\r\n   | Name      | Label | Value Type     | Value       | Description    | Reference         |\r\n   |           |       |                | Reference   |                |                   |\r\n   +-----------+-------+----------------+-------------+----------------+-------------------+\r\n   | kid-int   | TBD   | int            |             | Key identifier | [[This document]] |\r\n   +-----------+-------+----------------+-------------+----------------+-------------------+\r\n~~~~~~~~~~~",
          "createdAt": "2021-05-19T12:19:05Z",
          "updatedAt": "2021-05-19T12:19:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "That is an interesting idea. Another alternative would be to expand the existing 'kid' in COSE to be bstr / int. ",
          "createdAt": "2021-05-19T12:26:43Z",
          "updatedAt": "2021-05-19T12:26:43Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Both sound practical, and would make the WIP PR more readable. In an\necosystem where thins are passed around as COSE objects, having\nidentifiers bstr/int does make sense. (Among other things, it allows\nconfiguration storages to save their values in their pre-encoded compact\nform).\n",
          "createdAt": "2021-05-19T13:07:50Z",
          "updatedAt": "2021-05-19T13:07:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree a single key identifier with value bstr / int is a better idea. In practice, how would we redefine 'kid' to be bstr / int? I assume it is too late to make the change in draft-ietf-cose-rfc8152bis-struct, so this would be a draft updating that RFC. Any compatibility issues with old and new implementations of 'kid'? \r\n\r\nWould it be an alternative to define a new key identifier:\r\n\r\n~~~~~~~~~~\r\n   +-----------+-------+----------------+-------------+----------------+-------------------+\r\n   | Name      | Label | Value Type     | Value       | Description    | Reference         |\r\n   |           |       |                | Reference   |                |                   |\r\n   +-----------+-------+----------------+-------------+----------------+-------------------+\r\n   | kid2      | TBD   | bstr / int     |             | Key identifier | [[This document]] |\r\n   +-----------+-------+----------------+-------------+----------------+-------------------+\r\n~~~~~~~~~~~",
          "createdAt": "2021-05-20T06:17:54Z",
          "updatedAt": "2021-05-20T06:17:54Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "> Any compatibility issues with old and new implementations of 'kid'? \n\nEither way (kid2 or kid redefinition), a peer needs to know in advance\nwhat the other can accept; KIDs are (AFAICT) currently not exchanged\nin-band. Whoever knows enough of their peer to use a kid2 could use the\nsame knowledge to know that they support int-valued KIDs.\n\nTrouble is where implementers come in anew and use numeric KIDs without\nknowing that some peers may not support them -- that's a bit more\nobvious with a kid2, but in the end I think in both cases it should fail\nclearly at the KID distribution step (and if that's only \"Sorry, I can't\nenter that into my system, it expects a byte string and you gave me an\ninteger\").\n\nWith an eye on code point usage (of 1..23, 10 are already assigned), I'd\nprefer opening up kid, but ultimately that's something that ultimately\nwill need to be decided in COSE.\n",
          "createdAt": "2021-05-20T07:59:55Z",
          "updatedAt": "2021-05-20T07:59:55Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "kid2 or kid redefinition seems cleaner than kid_int, at least for EDHOC. It must be specified that the int is encoded with deterministic CBOR.\r\n\r\nIn EDHOC we could mandate support of of  numeric kids.\r\n\r\nIt would have been easier if there was only deterministic CBOR, then you could do kid = any\r\n",
          "createdAt": "2021-05-20T08:51:12Z",
          "updatedAt": "2021-05-20T08:51:12Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "kid = any would be hard on parsers (any could be tags the receiver does not support), and it'd switch disambiguation between raw kid and actual COSE object (now it's \"bstr or int are special\", then it'd be \"it's a kid to pack in {4:x} unless it's a map in which case treat it's the map itself).\n",
          "createdAt": "2021-05-20T08:58:56Z",
          "updatedAt": "2021-05-20T08:58:56Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "How about we introduce kid2 in the draft, with the assumption of deterministic CBOR, and an editorial note that it may be changed to kid later.  Then we can carry out the changes in the PRs to be able to better evaluate them. In parallel we bring up the discussion in COSE. If COSE accepts the redefinition of kid then we simply replace kid2 with kid, otherwise we keep it.",
          "createdAt": "2021-05-20T09:57:15Z",
          "updatedAt": "2021-05-20T09:57:15Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": " bstr_identifier is now removed and replaced with bstr / int. The mapping to OSCORE Sender/Recipient ID is described in A.1. kid2 is defined as above pending discussion in COSE.\r\n\r\n@chrysn Can we close this?",
          "createdAt": "2021-07-15T20:11:06Z",
          "updatedAt": "2021-07-15T20:11:06Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Yes. From the quick glance I had so far I think that still some enhancements can be made to the conversion described now, but I'll need some time to propose anything concrete there, and at any rate, the original concern is addressed. Thanks, closing.",
          "createdAt": "2021-07-16T12:26:27Z",
          "updatedAt": "2021-07-16T12:26:27Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU4MjAxNDE4MDI=",
      "title": "Applicability statement can depend on conditions during EDHOC execution",
      "url": "https://github.com/lake-wg/edhoc/issues/80",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The applicability statement is agreed out of band, but the policy can depend on information gained during the protocol run, e.g. ~~the identity of the peer,~~ the RESTful resource being called, CoAP options being used or other transport parameters.",
      "createdAt": "2021-03-02T15:46:25Z",
      "updatedAt": "2021-07-19T07:37:12Z",
      "closedAt": "2021-07-19T07:37:12Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "One step back: The applicability statement needs to be understood already at reception of message_1 to be able to verify supported method/corr etc. so cannot depend on identity of the peer.",
          "createdAt": "2021-03-03T13:55:05Z",
          "updatedAt": "2021-03-03T13:55:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The type of ID_CRED_I can definitly depend on message_2.\r\n\r\nNot sure I like the suggestion to make the applicability statement normative text in the body.....",
          "createdAt": "2021-04-19T08:01:23Z",
          "updatedAt": "2021-04-19T08:01:23Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU4MjEwOTg3ODQ=",
      "title": "Effects of limited amounts of randomness",
      "url": "https://github.com/lake-wg/edhoc/issues/81",
      "state": "OPEN",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "Randomness can be limited in constrained devices, and that can affect EDHOC.\r\n\r\n8.2. Cryptographic Considerations does talk about the necessity of randomness, but it did not become apparent to me from reading that alone that without a new fresh key I not only lose liveness and open up to interleaving, but also run into loss of all security properties when deriving an OSCORE secret from it and neither party has any randomness to put in.\r\n\r\nIf one of the involved parties of EDHOC is just scraping together a few bits of entropy (which is as good as having none), is there a direction in which EDHOC can be used with limited loss of properties? (Gut feeling says no because an attacker can replay a previous EDHOC exchange with them).\r\n\r\nIt may be helpful to also outline how a monotonous counter (similar to that of OSCORE B.1.1) can be used together with a private secret to obtain sufficient randomness. (That may follow from RFC 8937 already, not sure).",
      "createdAt": "2021-03-03T13:14:20Z",
      "updatedAt": "2021-09-10T13:10:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Now having read a more recent version of the draft:\r\n\r\nLooking further into the B.1.1 applicability, one way that'd to me gut-feeling-sounds like it might be OK is that the initiator only saves-to-disk its counter between receiving M2 and before sending M3.\r\n\r\nThus, an initiator might use the same ephemeral key twice, but before it completes the exchange, it ensures it will \"never\" use the same ephemeral key again.\r\n\r\n---\r\n\r\nThe reason this would be useful is that it'd defer the point where the B.1.1 process performs a kind-of-destructive operation (writing to flash that has a finite number of duty cycles) to a point in time when it has good reason to believe that there is actually a peer that makes it worth it. (The response could still be replayed from an adversary that intercepted message_1 in an earlier iteration of this, stopped message_2 from reaching the device and then injected it now -- but that only gives the attacker one flash write for one time the attacker intercepts messages, and doesn't put the attacker in any better a position than other replays do).",
          "createdAt": "2021-03-06T18:41:42Z",
          "updatedAt": "2021-03-06T18:41:42Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@chrysn  What remains of this issue? Is there anything you want to add to the text?",
          "createdAt": "2021-07-19T06:20:17Z",
          "updatedAt": "2021-07-19T06:20:17Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU4MjExNDMzMjA=",
      "title": "COSE header map for public key",
      "url": "https://github.com/lake-wg/edhoc/issues/82",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue needs to be resolved in COSE, but I didn't find this listed anywhere so I put a placeholder here. There is no COSE header map defined for transport of public key in ID_CRED_x. Needed for opportunistic settings, also required by draft-selander-ace-ake-authz.\r\n\r\n",
      "createdAt": "2021-03-03T14:08:42Z",
      "updatedAt": "2021-07-24T11:48:37Z",
      "closedAt": "2021-07-24T11:48:37Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, the type of public key needs to be specified. It could be different COSE header maps for different COSE key types:\r\nhttps://www.iana.org/assignments/cose/cose.xhtml#key-type\r\n\r\nEC types OKP and EC2 could have the same COSE header map label (TBD) but differ in content, like CRED_x as in EDHOC Section 3.3.3.\r\n\r\n{ TBD :  CRED_x }\r\n\r\n* For type OKP the CBOR map SHALL, except for subject name, only include the parameters 1 (kty), -1 (crv), and -2 (x-coordinate).\r\n\r\n* For type EC2 the CBOR map SHALL, except for subject name, only include the parameters 1 (kty), -1 (crv), -2 (x-coordinate), and -3 (y-coordinate).\r\n\r\nFor example, for OKP\r\n\r\nCRED_x = {\r\n  1:  1,\r\n -1:  4,\r\n -2:  h'b1a3e89460e88d3a8d54211dc95f0b90\r\n        3ff205eb71912d6db8f4af980d2db83a',\r\n \"subject name\" : \"42-50-31-FF-EF-37-32-39\"\r\n}\r\n\r\nThe corresponding text in 3.3.3 could be moved to a COSE draft which is normatively referenced from EDHOC.",
          "createdAt": "2021-04-16T14:50:50Z",
          "updatedAt": "2021-04-16T14:50:50Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "COSE should probably specify how to transfer a COSE_KEY without any further restrictions. Alternatively the c5c header could be used without much overhead. It might be better to do a new type of C509 without signature that is a RPK. COSE_KEYs are not efficiently encoded at all. ",
          "createdAt": "2021-04-19T07:58:42Z",
          "updatedAt": "2021-04-19T07:58:42Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The \r\n\r\nCRED_x = {\r\n1: 1,\r\n-1: 4,\r\n-2: h'b1a3e89460e88d3a8d54211dc95f0b90\r\n3ff205eb71912d6db8f4af980d2db83a',\r\n\"subject name\" : \"42-50-31-FF-EF-37-32-39\"\r\n}\r\n\r\nShould probably  be replaced by CWT or C509",
          "createdAt": "2021-05-12T20:34:57Z",
          "updatedAt": "2021-05-12T20:34:57Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this: COSE header map for CWT/UCCS is now defined, and the example of CRED_X is replaced. ",
          "createdAt": "2021-07-24T11:48:36Z",
          "updatedAt": "2021-07-24T11:48:36Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU4MjEyMjc2Njc=",
      "title": "Summarize all CDDL in one appendix",
      "url": "https://github.com/lake-wg/edhoc/issues/83",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Request from Christian",
      "createdAt": "2021-03-03T15:40:25Z",
      "updatedAt": "2021-04-22T08:37:22Z",
      "closedAt": "2021-04-22T08:37:22Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "info is also CDDL. But info is a bit different as it is not sent on the wire. ",
          "createdAt": "2021-04-19T07:31:47Z",
          "updatedAt": "2021-04-19T07:31:47Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in -06",
          "createdAt": "2021-04-22T08:37:22Z",
          "updatedAt": "2021-04-22T08:37:22Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU4MjIyODkzMzY=",
      "title": "Make .well-known/edhoc specific to OSCORE",
      "url": "https://github.com/lake-wg/edhoc/issues/84",
      "state": "OPEN",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "Given we're now moving towards that EDHOC needs to know the application (with its applicability statement), it would make sense to move the definition of the .well-known/edhoc resource over to @fpalombini's draft on EDHOC/OSCORE.\r\n\r\nThe general mechanisms of EDHOC-over-CoAP could stay here (which eg. say which corr to use, and which content format), but using it for OSCORE key extraction could be the exclusive user of .well-known/edhoc (which may get a different name in the course of this). Other applications would then be indicated with different paths.",
      "createdAt": "2021-03-04T16:23:53Z",
      "updatedAt": "2021-09-05T06:31:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "I put this badly: it should be about \"getting OSCORE contexts from EDHOC\" and not generic for \"EDHOC over CoAP\" -- but not necessarily limited to the particular way in Francesca's draft.",
          "createdAt": "2021-03-05T12:30:39Z",
          "updatedAt": "2021-03-05T12:30:39Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think moving everything OSCORE related to Francesca's draft is a good idea.",
          "createdAt": "2021-04-19T07:28:50Z",
          "updatedAt": "2021-04-19T07:28:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@chrysn @marco-tiloca-sics Given how the content is now distrbuted in lake-edhoc-08 and core-oscore-edhoc-01, is this still relevant. Should we replace this issue with a draft-core-oscore-edhoc github issue? Anything that remains to do here?",
          "createdAt": "2021-07-15T20:26:34Z",
          "updatedAt": "2021-07-15T20:26:34Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Yes, it makes sense, let's take is as a first step and see where it leads to.\r\n\r\nThe text in Appendix A.3 of draft-ietf-lake-edhoc-08 says:\r\n\r\n> According to this specification, EDHOC is transferred in POST requests ... to the Uri-Path: \"/.well-known/edhoc\". An application may define its own path ...\r\n\r\nThen maybe this can be further generalized to mention \"/.well-known/edhoc\" as nothing more than an example used in the following figures.",
          "createdAt": "2021-07-16T14:31:07Z",
          "updatedAt": "2021-07-16T14:31:07Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "If I understand the current distribution right (applying-to-coap-oscore is described here, oscore-edhoc is only about msg3 in an option), I think it should stay here (both tracker- and document-wise).\r\n\r\n@marco-tiloca-sics, if it were really just an example for use in the figures, it wouldn't need to be well-known (when would there be the justification for even registering it), and as a reader I'd be missing a way to discover the path. I'd expect applications (either defined by downstream standards or just application behavior) to say no more than \"EDHOC and OSCORE are used all the time with keys exchanged through X\", so this is an actual default and not an example. (And frankly the only reason I'd see for any application to not use .well-known/edhoc is if they use any of the AD, don't know if that can be multiplexed onto .wk/e or not).",
          "createdAt": "2021-07-16T14:39:33Z",
          "updatedAt": "2021-07-16T14:39:33Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Yes, that's the current distribution and I see your points. Ok to keep it here then",
          "createdAt": "2021-07-16T14:52:34Z",
          "updatedAt": "2021-07-16T14:52:34Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this?",
          "createdAt": "2021-08-26T16:44:39Z",
          "updatedAt": "2021-08-26T16:44:39Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU4MjIyOTIzODY=",
      "title": "State idempotency",
      "url": "https://github.com/lake-wg/edhoc/issues/85",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When setting EDHOC up on a constrained CoAP library, it'd help a lot if there'd be a statement that the EDHOC operations must be idempotent, ie. tolerate that retransmissions of a request are passed on to EDHOC multiple times (ie. the CoAP library may forego request deduplication). Ideally, all these requests should lead to identical responses.\r\n\r\nI think that these properties are already there (possibly necessitating that messages 2 and 4 are distinguishable by a server in initiator mode, if message 4 ever happens there); having a statement would make it possible to justify using EDHOC on a library like, say, RIOT's gcoap, in the first place.",
      "createdAt": "2021-03-04T16:27:19Z",
      "updatedAt": "2021-05-21T19:08:08Z",
      "closedAt": "2021-05-21T19:08:08Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Tying this to the draft: \"The transport is responsible to handle message loss, *reordering, message duplication*, fragmentation, and denial of service protection, where necessary\". I think that EDHOC can do without the highlighted ones already.",
          "createdAt": "2021-03-05T21:01:06Z",
          "updatedAt": "2021-03-05T21:01:06Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "(Summarizing otherwise not-yet-written-down developments for chronology): It looks like it won't be \"idempotency\", but more something \"the CoAP stack may forego message deduplication, because the EDHOC implementation needs to report back the last message when requested again\".\r\n\r\n",
          "createdAt": "2021-03-23T09:24:37Z",
          "updatedAt": "2021-03-23T09:24:37Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Looking at [I-D.ietf-ace-wg-coap-eap](https://tools.ietf.org/html/draft-ietf-ace-wg-coap-eap-00), they face a similar situation -- but EAP expresses as a requirement for the lower layer that it must have ordered message transmission. I disagree with the mechanism they use (introducing a sequence number option; discussion ongoing), but maybe something comes out of the discussions there that'd help here as well; will keep this updated.",
          "createdAt": "2021-03-23T09:29:37Z",
          "updatedAt": "2021-03-23T09:29:37Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@chrysn Could you please comment on the new text?",
          "createdAt": "2021-04-09T09:29:43Z",
          "updatedAt": "2021-04-09T09:29:43Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Sounds good, and well implementable. Two notes:\r\n\r\n* Why does this need to be part of the applicability statement? Whether deduplication happens on CoAP level or on EDHOC level should be transparent to a well-behaved peer. (Plus, in the presence of proxies, even if one party does EDHOC level deduplication, there may actually happen CoAP level deduplication on the path -- but no well-behaved party would see the difference).\r\n\r\n* On wording, it took me a bit to parse the \"Note that if a different instance\" sentence; suggested alternative to mix and match (with an addition of when this happens):\r\n\r\n> Note that if two different versions of EDHOC message_x are received (message_x1 and message_x2, in that sequence), then the \"processing\" described above of message_x2 will produce the response to message_x1. That will correctly result in a failure in integrity verification due to difference in transcript hashes between the message_x instances. The situation can only arise when the peer violates the requirements of not processing a message twice, or when the messages are tampered with.",
          "createdAt": "2021-04-09T09:41:30Z",
          "updatedAt": "2021-04-09T09:41:30Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "About applicability statement: I believe you are right. I was thinking that if only one endpoint supports EDHOC message deduplication, the other endpoint would fail in case duplicate message appears. But actually, the other endpoint do need to support **some kind** of deduplication, it just doesn't matter which kind. So I'll remove that part.\r\n\r\nOn wording: I'll make another attempt.",
          "createdAt": "2021-04-09T13:06:24Z",
          "updatedAt": "2021-04-09T13:06:24Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure that this should be an appendix. If it is an appendix it should not be hidden behind the test vectors.\r\n\r\nThe suggested text states \"duplication due to re-transmissions\". What about other duplications? Duplication can happen anywhere in the network path. Or by an attacker.\r\n\r\n\"but the received message must not be processed more than once by the EDHOCimplementation. \"\r\n\r\nThis is true for 2,3,4, not true for 1 and error. Needs to make clear that this is per instance.\r\n",
          "createdAt": "2021-04-19T07:27:19Z",
          "updatedAt": "2021-04-19T07:27:19Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR has been discussed and merged. Closing",
          "createdAt": "2021-05-21T19:08:08Z",
          "updatedAt": "2021-05-21T19:08:08Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWU4MjIyOTM3MzQ=",
      "title": "Change log",
      "url": "https://github.com/lake-wg/edhoc/issues/86",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Please introduce a change log in the document in the next version, eg. in a \"This section is to be removed before publication\" appendix.\r\n\r\nFor purpose of the implementers it'd suffice to list mechanical changes there, and helpful if they were distinct (if only in sequence) from editorial changes if they are listed at all.",
      "createdAt": "2021-03-04T16:28:55Z",
      "updatedAt": "2021-04-19T07:23:21Z",
      "closedAt": "2021-04-19T07:23:21Z",
      "comments": [
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "Hi all,\r\nI went through the last few drafts and made a changelog, which may be helpful for someone else too\r\n\r\n`\r\n# EDHOC Changes\r\n\r\n### July 06, 2020   draft-selander-lake-edhoc-01 ->  draft-ietf-lake-edhoc-00\r\n* in the test vector - connection identifier chosen by Responder (1 bytes) changed form 2b to 13. -> No action required since data_2 (CBOR Sequence) remains the same\r\n* Text improvements \r\n\r\n### August 02, 2020   draft-ietf-lake-edhoc-00.txt \t-> draft-ietf-lake-edhoc-01.txt \r\n* PSK mode removed\r\n* Message size example changed to have only kid and x5t \r\n* x5bag and x5chain identifiers for public keys removed\r\n* Text improvements \r\n\r\n### November 02, 2020   draft-ietf-lake-edhoc-01.txt\t-> draft-ietf-lake-edhoc-02.txt \r\n* Added test vector for static DH autthentication\r\n* Clarification regarding bstr_identifier\r\n* Text improvements \r\n\r\n \r\n### December 18, 2020  draft-ietf-lake-edhoc-02.txt \t->  draft-ietf-lake-edhoc-03.txt\r\n* added Appendix C.  Applicability Statement Template\r\n* Clarifications regarding Authentication Credentials\r\n* Cipher Suites 4 and 5 added \r\n* EDHOC-EXPORTER-FS - generate a new PRK_4x3m from a old one\r\n* Changes in CPHERTEXT_2 calculation -> No changes in the test vector\r\n* Error message clarifications\r\n* Text improvements\r\n\r\n### January 27, 2021  draft-ietf-lake-edhoc-03.txt \t->   draft-ietf-lake-edhoc-04.txt \r\n* Added message 4\r\n* \"K_2e\", \"IV_2e\" -> KEYSTREAM_2\r\n* EDHOC-Exporter-FS -> EDHOC-Rekey-FS\r\n* Changes in CPHERTEXT_2 calculation -> CIPHERTEXT_2 = plaintext XOR KEYSTREAM_2\r\n* less constrained devices SHOULD implement both suite 0 and 2\r\n* Exporter interface test vector added\r\n* Text improvements\r\n\r\n### 22 February, 2021 draft-ietf-lake-edhoc-04.txt \t->  draft-ietf-lake-edhoc-05.txt \r\n* EDHOC-Rekey-FS -> EDHOC-KeyUpdate\r\n* Text improvements\r\n* Appendix B.1.1\r\n\t* last byte of message 1 0x40 -> 0x2e \r\n\t* C_R im data_2 13 -> 37 -> different TH_2\r\n\t* Different CRED_R -> many following differences in B.1.1\r\n\t* KEYSTREAM_2 used\r\n* Appendix B.2.1\r\n\t* different C_R -> many following differences\r\n\t* KEYSTREAM_2 used`",
          "createdAt": "2021-03-29T12:23:16Z",
          "updatedAt": "2021-03-29T12:23:16Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Stefan! We can use this as a basis for the new appendix.",
          "createdAt": "2021-03-29T13:01:59Z",
          "updatedAt": "2021-03-29T13:01:59Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a very good idea. I think we can close this now",
          "createdAt": "2021-04-19T07:23:21Z",
          "updatedAt": "2021-04-19T07:23:21Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU4MjIzOTgxNjU=",
      "title": "Compressing \".well-known/edhoc\"",
      "url": "https://github.com/lake-wg/edhoc/issues/87",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If the 18 bytes of the \".well-known\" \"edhoc\" get in the way anywhere, there is always the possibility to register an option that expands to that. For example, Someone (probably not in this document; it'd be a short CoRE draft) could ask for an option in the <269 range that is uint valued, and whose uints expand to a TBD IANA registry where 0 is mapped to Uri-Paths \".well-known\" \"core\" and 1 is mapped to \".well-known\" \"edhoc\".\r\n\r\nThat'd save 15 bytes in messages 1 and 3, provided the .well-known/edhoc resource is really used. (Is it at all, with the most critical applications?)",
      "createdAt": "2021-03-04T18:39:58Z",
      "updatedAt": "2021-07-16T14:44:16Z",
      "closedAt": "2021-07-16T14:44:16Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This proposal has been brought up in CoRE and is not really in the scope of LAKE. Can we close it?\r\n\r\n@marco-tiloca-sics Perhaps better to have a placeholder as a github issue related to draft-ietf-core-oscore-edhoc?",
          "createdAt": "2021-07-15T20:18:55Z",
          "updatedAt": "2021-07-15T20:18:55Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Yes, it makes sense, let's take is as a first step and see where it leads to.",
          "createdAt": "2021-07-16T14:30:28Z",
          "updatedAt": "2021-07-16T14:30:28Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Yes, can close; I have a note to start a short document on draft-amsuess-core-common-option-compression based on the 2021-05-12 interim presentation.",
          "createdAt": "2021-07-16T14:44:16Z",
          "updatedAt": "2021-07-16T14:44:16Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU4MjM2OTM5NTg=",
      "title": "Opportunistic use",
      "url": "https://github.com/lake-wg/edhoc/issues/88",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "EDHOC looks to me like it should be usable in situations where one party has no need (or intention) to authenticate, but still wants to authenticate the other party or just use opportunistic encryption.\r\n\r\nOne use case might be a constrained device A obtaining the certificate indicated by device B in the A-B EDHOC exchange from the certificate URI at C indicated by B. A has no need to present credentials (C hosts the certs publicly), but doesn't want to reveal to passive evesdroppers that it's talking to B. It doesn't need to authenticate C, but that might still be a good idea to lock out active MITMs.\r\n\r\nMy impression is that this is possible with EDHOC as it is and that EDHOC is suitable for the task (if not, stop reading and tell me).\r\n\r\nIf it is suitable, would both of these work?\r\n* Create (in COSE) a key ID type where a RPK that is CRED_x can be transported in ID_CRED_x (useful where you want to come back w/o having any original claims on first use)\r\n* Have a key where your ID_CRED_x says \"just what my ephemeral key is\". That'd make exchanges just as compact as short-ID'd RPKs, and still be good-enough for unilateral authentication.",
      "createdAt": "2021-03-06T16:53:55Z",
      "updatedAt": "2021-08-26T16:42:22Z",
      "closedAt": "2021-08-26T16:42:22Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "From just in the WG meeting: RPK-by-value sounds doable in COSE and would be good enough for a start.\r\n\r\nThe extended case is probably exceeding the LAKE requirements and is to be postponed.\r\n\r\n(Personally I'd like to keep looking into it, if only to influence any left-over decisions that don't have any other influencing factors and one would rule this out -- but that can happen outside WG activity).",
          "createdAt": "2021-03-09T13:41:44Z",
          "updatedAt": "2021-03-09T13:41:44Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Covered by #82 ",
          "createdAt": "2021-03-31T12:08:28Z",
          "updatedAt": "2021-03-31T12:08:28Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The more I think about this, the more I think that specifying a new type in the C509 draft is the right way to go.\r\n\r\n- COSE_Key was not meant to be sent over the wire. It does not have a order and it is not very optimized.\r\n- When working on issue #69 and PR #106 I realized that the singature curve has nothing to do with the signature alg and is completely detemined by the public key. It would be messy to have to types of public key formation and algorithms. Only using X.509 / C509 seems simpler in my view.\r\n- A new type in C509 naturally allows optional sending of parameters like key usage, subject name, and life time, which might be useful in a RPK setting as well. \r\n\r\nBelow is an example using the example certificate in the C509 draft. The type is changed to 2, the signature is removed, and all parameters are set to there minimum size. This PRK has key usage digital signature. Could be discussed if fields should be removed or have a non-present value.\r\n\r\nThe RPK has size 43 bytes:\r\n\r\n2,\r\nh'',\r\n[],\r\nnull,\r\nnull,\r\n[],\r\n1,\r\nh'02B1216AB96E5B3B3340F5BDF02E693F16213A04525ED44450\r\n       B1019C2DFD3838AB',\r\n1\r\n\r\nBelow is another example where a serial number, expiery time, and subject name (EUI-64) is provided, size 55 bytes.\r\n\r\n2,\r\nh'01f5',\r\n[],\r\nnull,\r\n1612224000,\r\nh'0123456789AB',\r\n1,\r\nh'02B1216AB96E5B3B3340F5BDF02E693F16213A04525ED44450B1019C2DFD3838AB',\r\n1\r\n\r\n\r\n",
          "createdAt": "2021-04-25T10:04:39Z",
          "updatedAt": "2021-04-25T10:04:39Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is important to define, I will start to make some more concrete suggestion and analysis.",
          "createdAt": "2021-05-05T10:05:21Z",
          "updatedAt": "2021-05-05T10:05:21Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The use of UCCS for trust-on-first-use is now included in the master branch, see a1b25ba and commits in its vicinity.\r\n\r\nCan we close the issue?",
          "createdAt": "2021-07-24T11:47:15Z",
          "updatedAt": "2021-07-24T11:47:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this can be closed.",
          "createdAt": "2021-08-26T16:42:22Z",
          "updatedAt": "2021-08-26T16:42:22Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU4MjM3MDIyOTY=",
      "title": "editorial / usability: corr and C_x omission",
      "url": "https://github.com/lake-wg/edhoc/issues/89",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Both while trying to understand an implementation and in discussions of transport considerations, I was repeatedly had by the correlation numbers. It's convenient in the serialization to look into bits of a 2-bit number, but for talking about it, I always had to look things up.\r\n\r\nConcrete proposal:\r\n\r\nIn the Message Correlation subsection, state after each bullet the respective one of \"There is a C_x in the first message position\", \"In the first message position, C_I is sent and C_R is omitted\", ..., \"In the first message position, no C_x is sent\". If phrased more concisely (\"C_I is sent, C_R is omitted\"), it'd need a paragraph that states that \"The above statements about sending or omitting C_x only refer to the first positions in the messages; the C_I in Message 1 and C_R in Message 2 are always sent\". Ideally, this could be put in a table.\r\n\r\nThen, in the descriptions of Responder Processing of Message 2 and following, it can just say \"C_x is sent depending on the correlation from {{}}\".\r\n\r\nIMO having these in one place and not baking the bit extraction in every step would make it easier to read.",
      "createdAt": "2021-03-06T17:32:58Z",
      "updatedAt": "2021-07-15T20:38:00Z",
      "closedAt": "2021-07-15T20:38:00Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not understanding exactly what you sugest, but it is probably a good idea. Could you make a pull request?",
          "createdAt": "2021-04-19T07:21:28Z",
          "updatedAt": "2021-04-19T07:21:28Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "As @chrysn noted in #105, a solution to that issue (which is included in -08) solves this issue.",
          "createdAt": "2021-07-15T20:38:00Z",
          "updatedAt": "2021-07-15T20:38:00Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU4NTMyMTAzODM=",
      "title": "Clarify \"auxiliary data\"",
      "url": "https://github.com/lake-wg/edhoc/issues/90",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is too easy to confuse \"application data\" with \"auxiliary data\". The former is the data which is protected with keys obtained through the use of EDHOC, i.e. a straightforward application of EDHOC so the name \"application data\" is fairly intuitive. The latter is an extension point for use with security applications during EDHOC execution, like third party assisted authorization or certificate enrolment. \r\n\r\nPerhaps we should rename \"auxiliary data\" something with \"extension\"?",
      "createdAt": "2021-04-08T08:23:29Z",
      "updatedAt": "2021-07-19T09:12:01Z",
      "closedAt": "2021-07-19T09:12:00Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think extension is a bad word choice as it is easy to think about TLS extensions, which this is not similar to at all.\r\n\r\nMaybe \"external data\" ",
          "createdAt": "2021-04-19T07:19:23Z",
          "updatedAt": "2021-04-19T07:19:23Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest \"external authorization data\" EAD. I think it is good to point out that the data is external to EDHOC and to give a hint of what it is used for.",
          "createdAt": "2021-05-04T08:29:36Z",
          "updatedAt": "2021-05-04T08:29:36Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Doing a pull request for this, I stumbled upon several things:\r\n\r\n? AD_1 : bstr,\r\n\r\nWhy is this bstr instead of any. If the data is CBOR encoded in the first place, wrapping it in a bstr adds two bytes without any benefit I suggest we change this to\r\n\r\n? AD_1 : any,\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-05-04T08:40:25Z",
          "updatedAt": "2021-05-04T08:40:25Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Specifying bstr also makes it harder to put any structure to the data in a formal way later as was discussed.\r\n",
          "createdAt": "2021-05-04T08:41:07Z",
          "updatedAt": "2021-05-04T08:41:07Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": ">The Responder MUST finish the verification step of message_3 before passing AD_3 to the application.\r\n\r\nWhy is this stated? I don't understand at all. The reason for AD_3 to exist is to send things like access tokens that are processed before message_3 is completely processed.\r\n\r\nThe current text makes it sound like AD_3 is application data which the agreement is that it is not.....\r\n\r\n",
          "createdAt": "2021-05-04T08:43:00Z",
          "updatedAt": "2021-05-04T08:43:00Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR #111 addressing all the issue mentioned with aux data.\r\n\r\nThe PR addresses issue #110 ",
          "createdAt": "2021-05-04T10:38:53Z",
          "updatedAt": "2021-05-04T10:38:53Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Any comments on #111?",
          "createdAt": "2021-05-07T13:37:59Z",
          "updatedAt": "2021-05-07T13:37:59Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "An earlier version of EDHOC stated that was then called EXT and is now called EAD \"could be used for authorization tokens that are protected outside of EDHOC.\" The intention with that text was CWT. The text has since been removed without being being replaced with any other way to transfer CWT. CWT can in the current version not be transfered in EAD_2 or EAD_3",
          "createdAt": "2021-05-12T20:33:43Z",
          "updatedAt": "2021-05-12T20:33:43Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Why can't CWT can be transferred in EAD_2 or EAD_3? As I recall the statement about \"protected outside of EDHOC\" that allowed protection within as well as outside of EDHOC.",
          "createdAt": "2021-05-24T06:56:52Z",
          "updatedAt": "2021-05-24T06:56:52Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "It can, but it creates more overhead. Treating CWT differently than X509 seems a bit strange, especially in the opportunistic RPK case.\r\n\r\nI don't think the question is why can't. It is more why should it. Are there any benefits with sending it in EAD? ",
          "createdAt": "2021-05-24T07:13:51Z",
          "updatedAt": "2021-05-24T07:13:51Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue: The discussion above was a misunderstanding between John and myself on authentication vs. authorization related information. Meanwhile, in addition to PR #111, IANA registration of COSE header parameter for CWT and for EAD types have been requested. With this, CWT can be transported in ID_CRED_x and in EAD (as soon as the accompanying EAD type has been registered).",
          "createdAt": "2021-07-19T09:12:00Z",
          "updatedAt": "2021-07-19T09:12:00Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU4NTM0Nzk4MTA=",
      "title": "Implementation guidance for CoAP",
      "url": "https://github.com/lake-wg/edhoc/issues/91",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A request for more implementation guidance for CoAP. E.g. in section 7.2.2, add\r\n\r\n\"Since CoAP Token correlates responses to requests, connection identifiers can be left out of responses (if specified in the applicability template). In this case can the error messages ({{error}}) be identified in the following way:\r\n\r\n* if it is a request with 3 elements and the second is an int\r\n* if it is a response with 2 elements and the first is an int\"\r\n\r\nIs this the right place for such text?",
      "createdAt": "2021-04-08T13:33:48Z",
      "updatedAt": "2021-07-19T06:11:10Z",
      "closedAt": "2021-07-19T06:11:09Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The bullets has nothing to do with CoAP. Might be good to have an appendix on how to differentiate between different messages. But I don't think the CoAP section is the right place for the bullet. The first suggested sentence could be added to the CoAP section. ",
          "createdAt": "2021-04-19T07:17:46Z",
          "updatedAt": "2021-04-19T07:17:46Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "The above bullet points hold if `corr` is `1` or `2`. This may not apply to CoAP only, but it comes from having assumed so far that using CoAP implies `corr` `1` or `2` (relates to #95).\r\n\r\nIt would be *very good* to have an Appendix with a sequence of steps describing how a recipient can determine the message type when receiving a message, in the most general case.\r\n\r\nIf CoAP cannot imply `corr` `1` or `2` anymore (relates to #95), it may become pretty challenging to distinguish message types and especially identify Error Messages.",
          "createdAt": "2021-04-20T09:51:41Z",
          "updatedAt": "2021-04-20T09:51:41Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This is not an issue anymore;  corr is now removed, the CoAP section describes how to correlate messages.",
          "createdAt": "2021-07-19T06:11:09Z",
          "updatedAt": "2021-07-19T06:11:09Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWU4NTQzNjYwODc=",
      "title": "Remove section 8.7?",
      "url": "https://github.com/lake-wg/edhoc/issues/92",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 8.7  \"Other Documents Referencing EDHOC\" is not up to date. We are not making use of any of the referenced documents in the specification. Do we really need this section?\r\n\r\nEdit: Or only keep references to security analyses made?",
      "createdAt": "2021-04-09T09:50:14Z",
      "updatedAt": "2021-04-19T07:15:10Z",
      "closedAt": "2021-04-19T07:15:09Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes",
          "createdAt": "2021-04-19T07:15:09Z",
          "updatedAt": "2021-04-19T07:15:09Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU4NTk5MTQ3NDM=",
      "title": "Selected hash alg. vs hash alg in x5t",
      "url": "https://github.com/lake-wg/edhoc/issues/93",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "x5t is parametrized with the hash function it uses. (x5t mandates support for SHA-256, but not its use.)\r\n\r\nThe spec doesn't state that the hash function in x5t (when used) needs to be the same as the hash alg in the selected cipher suite.\r\n\r\n* If it doesn't, then the endpoint may not be able to verify the hash of the certificate because it does not support the hash algorithm used in x5t.\r\n\r\n* If it does, then there are redundant bytes in x5t, since the hash alg is known from the selected cipher suite. Is it worth doing anything about that?\r\n\r\n",
      "createdAt": "2021-04-16T15:23:41Z",
      "updatedAt": "2021-05-21T18:59:59Z",
      "closedAt": "2021-05-21T18:59:59Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This is covered by the applicability statement of ID_CRED_x. I don't see any need for change. ",
          "createdAt": "2021-04-19T07:14:56Z",
          "updatedAt": "2021-04-19T07:14:56Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Clossing this as there was no further comments",
          "createdAt": "2021-05-21T18:59:59Z",
          "updatedAt": "2021-05-21T18:59:59Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU4NTk5MjgyMjk=",
      "title": "Action in case of early error",
      "url": "https://github.com/lake-wg/edhoc/issues/94",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current specification mandates sending error messages upon certain failures. But in cases when message processing fails when no state has been allocated or when no connection identifier has been found or then a more appropriate action would be to just silently drop the message. ",
      "createdAt": "2021-04-16T15:32:33Z",
      "updatedAt": "2021-05-21T19:01:09Z",
      "closedAt": "2021-05-21T19:01:09Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the MUST (if possible) is good. Debugging without any error messages is not nice. We now other protocols that it is good to mandate error messages. It is kind of obvious that can not send an error if you don't now where/how to send it. Don't know if that has to be pointed out....",
          "createdAt": "2021-04-19T07:13:13Z",
          "updatedAt": "2021-04-19T07:13:13Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Migth be good to not sent error if you are under a DoS attack.",
          "createdAt": "2021-04-19T13:20:13Z",
          "updatedAt": "2021-04-19T13:20:13Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is addressed by pull request #109 that also address availability",
          "createdAt": "2021-05-05T09:52:49Z",
          "updatedAt": "2021-05-05T09:52:49Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR has been discussed and merged. Closing",
          "createdAt": "2021-05-21T19:01:09Z",
          "updatedAt": "2021-05-21T19:01:09Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU4NTk5NTczMTQ=",
      "title": "Dependency between corr and transport",
      "url": "https://github.com/lake-wg/edhoc/issues/95",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There has been an off-list/off-git discussion about correlation and transport. The specification does not normatively specify that a certain transport is associated to a certain corr.\r\n\r\nSection 3.2.4: \r\n\r\n\"If the transport provides a mechanism for correlating messages received with messages previously sent, then some of the connection identifiers **may** be omitted.\"\r\n\r\n\"For example, if the key exchange is transported over CoAP, the CoAP Token **can** be used to correlate messages, see Section 7.2.\"\r\n\r\nIn the case of CoAP, two examples are shown and corr factors stated in those cases.\r\n\r\nSection 7.2:\r\n\r\n\"An example of a successful EDHOC exchange using CoAP is shown in Figure 9. In this case the CoAP Token enables the Initiator to correlate message_1 and message_2 so the correlation parameter corr = 1.\"\r\n\r\n\"An alternative exchange that protects the server identity against active attackers and the client identity against passive attackers is shown in Figure 10. In this case the CoAP Token enables the Responder to correlate message_2 and message_3 so the correlation parameter corr = 2. \"\r\n\r\n\r\nA question raised is if this dependency between CoAP transport and corr is in fact mandatory, and that corr is redundant to send since it is determined by transport.\r\n\r\nOn the other hand, if EDHOC is used over interchanging transports between the endpoint and not all transports support the same correlation, then it is not possible to deduce corr from transport. Just because that last hop is over CoAP, the Initiator may still not be able to correlate a received message_2 to a sent message_1. With this in mind, it must be allowed to set corr = 0 also for CoAP transport.\r\n\r\nDoes it make sense? Is this an issue? \r\n\r\nin any case we need to clarify this. \r\n\r\n",
      "createdAt": "2021-04-16T16:10:07Z",
      "updatedAt": "2021-07-19T06:08:31Z",
      "closedAt": "2021-07-19T06:08:30Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see what the problem is. ",
          "createdAt": "2021-04-19T07:09:24Z",
          "updatedAt": "2021-04-19T07:09:24Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Corr is included in message_1 so that it is covered by the integrity protection. This was a comment from the CFRG review. So I do not think Corr is redundant.",
          "createdAt": "2021-04-19T13:15:43Z",
          "updatedAt": "2021-04-19T13:15:43Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@emanjon My understanding is that a mere reception of `message_1` over a given transport determines the `corr` value. E.g. if the responder receives `message_1` over CoAP and the responder plays a CoAP server, the Responder knows that the value of `corr` is `1`. If the CoAP server receives a POST trigger as in Fig. 8 in EDHOC-05, and then sends `message_1` in the 2.04 response, the EDHOC Responder-CoAP client knows that the value of `corr` is `2`. That said, my question is why do you need to transport `corr` on the wire? Is there any counter example where `corr` is not uniquely determined from the transport itself? Could you not integrity-protect `corr` without transporting it on the wire?",
          "createdAt": "2021-04-19T16:45:49Z",
          "updatedAt": "2021-04-19T16:45:49Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Maybe the following case can be the counter example. Think of this setup:\r\n\r\n* An initiator talking only a protocol PROT that requires `corr` `0`.\r\n* An intermediary acting as PROT-to-CoAP forward proxy.\r\n* A responder talking CoAP.\r\n\r\nThe initiator has to use `corr` `0`. The responder will receive CoAP messages but cannot imply `corr` `1` or `2` from that; rather, it has to follow `corr` as indicated in `message_1`, and talk CoAP with the proxy while using `corr` `0` in the EDHOC session.\r\n\r\nFrom then on, this should work just fine from an EDHOC and transport point of view, but CoAP itself would not be taken by the responder as an indication of `corr` `1` or `2`.\r\n\r\nAs a consequence, especially for the responder it may become pretty challenging to distinguish message types of received messages and identify Error Messages (relates to #91). That is, the responder has to consider the \"union\" of possible message formats putting together the alternatives from `corr` `0`, `1` and `2`, which would yield interpretation ambiguities.\r\n\r\nPossibly considering this too, it would help anyway to have an Appendix with a sequence of steps describing how a recipient can determine the message type when receiving a message (relates to #91).",
          "createdAt": "2021-04-20T10:18:46Z",
          "updatedAt": "2021-04-20T10:18:46Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "More generally, when receiving an EDHOC message, a correlation cannot be implied from the message itself. This can make the message parsing difficult and ambiguous (see previous comment), while it may still be needed to be done --- and in a certain way --- also to retrieve the right session in question.\r\n\r\nA safe way to address this kind of situation can work as follows.\r\n\r\n1. Associate the received EDHOC message with the pertinent applicability statement. As discussed in the document, this can be done, e.g., through a specific URI, port number, etc.\r\n\r\n2. If the applicability statement does not indicate a correlation to use, assume `corr` is `0` by default. Otherwise, consider the indicated correlation(s).\r\n\r\n3. Parse the message according to what determined at the previous step.\r\n\r\nFor an applicability statement to prevent the original problem to come back, it is fine that it indicates correlation = 0, or correlation = (1, 2) coexisting, or correlation = 3, but not e.g. correlation = (0, 1, 2) coexisting.\r\n",
          "createdAt": "2021-04-21T14:39:18Z",
          "updatedAt": "2021-04-21T14:39:18Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just reading `-06` so I would like to take a step back: the point of `corr` is to allow us to omit `C_I` in `message_2`, which is typically 1 byte, and to omit `C_R` in `message_3`, again typically 1 byte. Do we have consensus that the complexity introduced by `corr` is worth saving that byte?",
          "createdAt": "2021-04-22T09:31:02Z",
          "updatedAt": "2021-04-22T09:31:02Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@malishav Yes, that is the question. And that goes back to the requirements on message sizes, in particular 45 bytes of message_2  coming from the 6tisch estimate. Are we making the right trade-off here?\r\n\r\nThis also depends on other potential optimizations, see #103, which also adds complexity but reduces overhead.",
          "createdAt": "2021-04-22T09:36:58Z",
          "updatedAt": "2021-04-22T09:36:58Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "There is also the option that we say that corr = 0 by default, say, mandatory unless the Initiator and Responder agrees beforehand what corr value is used. \r\n\r\n(We still need to decide what other optimizations to make.)",
          "createdAt": "2021-04-22T09:50:07Z",
          "updatedAt": "2021-04-22T09:50:07Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this since corr is now removed.",
          "createdAt": "2021-07-19T06:08:30Z",
          "updatedAt": "2021-07-19T06:08:30Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU4NjEzMzM0MDk=",
      "title": "Computation of transcript hashes",
      "url": "https://github.com/lake-wg/edhoc/issues/96",
      "state": "CLOSED",
      "author": "malishav",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While working on the EDHOC hacspec with @karthikbhargavan and @TimothyClaeys, a following issue was discussed:\r\n\r\n`TH_2` in `edhoc-05` is computed as:\r\n\r\n`TH_2 = H(message_1, data_2 )`\r\n\r\nThis requires the Initiator to preserve the entire `message_1` in memory in order to calculate `TH_2` once `message_2` is received.  In order to simplify the implementations, wouldn't it make more sense to compute `TH_2` as `H(TH_1, data_2)`, where `TH_1 = H(message_1)`?\r\n\r\nSimilarly, `TH_3` is computed as:\r\n\r\n`TH_3 = H(TH_2 , CIPHERTEXT_2, data_3)`,\r\n\r\nwhich requires the Responder to preserve `CIPHERTEXT_2` in memory while waiting for `message_3` to arrive, in order to compute `TH_3`. `CIPHERTEXT_2` has a dynamic and potentially significant length: removing the need to preserve `CIPHERTEXT_2` in memory would simplify the embedded implementations.\r\n\r\nA proposal is to define:\r\n\r\n`TH_2' = H(TH_2, CIPHERTEXT_2)`, computed at the end of the creation process of message_2, and to finally calculate `TH_3` as:\r\n\r\n`TH_3 = H(TH_2', data_3)`.\r\n\r\n",
      "createdAt": "2021-04-19T13:51:24Z",
      "updatedAt": "2021-05-03T09:14:56Z",
      "closedAt": "2021-05-03T09:14:56Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Great to get some feedback and discussion on these things:\r\n\r\n\r\n-- I am not sure that the first suggestion always simplifies or use less memory.\r\n\r\nTH_2 = H(message_1, data_2 )\r\nvs\r\nTH_1 = H(message_1), TH_2 = H(TH_1, data_2)\r\n\r\nThe example size of message_1 is 37 bytes so a 32 byte TH_1 would not be much smaller. With a larger message_1 (AD_1 could be arbitrary large) is saves memory. But would not the implementation need to store a lot of the information in message_1 anyway to be able to process message_2? \r\n\r\n\r\n-- The second suggestion make a lot of sense to me, it seems to strictly improve memory use.\r\n\r\nTH_3 = H(TH_2 , CIPHERTEXT_2, data_3),\r\nvs\r\nTH_2' = H(TH_2, CIPHERTEXT_2)\r\nTH_3 = H(TH_2', data_3)\r\n\r\nWould be good with some more detailed calculation as well as feedback from more implementors.\r\n",
          "createdAt": "2021-04-21T06:23:55Z",
          "updatedAt": "2021-04-21T06:23:55Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My take on the proposed `TH_1` is that it does simplify the implementation as you are dealing with a fixed size and do not need to worry how large `message_1` may grow. I see the value in doing this for embedded implementations. While I understand that the implementation needs to remember certain elements from message_1 after sending it, I do not see why it would need to save the serialized version of it after sending. Implementers feedback very welcome! @TimothyClaeys @marco-tiloca-sics @StefanHri",
          "createdAt": "2021-04-21T08:25:04Z",
          "updatedAt": "2021-04-21T08:25:04Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "For me to use the approach proposed by malishav is a good idea. Fixed-length fields are easier to handle on constrained devices without dynamic memory allocation where only stack memory can be used. ",
          "createdAt": "2021-04-21T09:40:30Z",
          "updatedAt": "2021-04-21T09:40:30Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Good and quick input. Semms like we should do both of these changes then.\r\n\r\n(If I remember correctly having a running transcript hash like TLS 1.3 is not optimal for some IoT devices)",
          "createdAt": "2021-04-21T09:45:11Z",
          "updatedAt": "2021-04-21T09:45:11Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Looks good to me.",
          "createdAt": "2021-04-21T15:43:29Z",
          "updatedAt": "2021-04-21T15:43:29Z"
        },
        {
          "author": "TimothyClaeys",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 \r\n\r\nCurrently I'm saving intermediate hashing contexts in between different message processing methods so I don't have to store the individual parts that go into the transcript hash. My current way of implementing this is kind of hacky so I would be nice to see this properly defined in the specification.\r\n\r\nhttps://github.com/openwsn-berkeley/EDHOC-C/blob/7da0b54d85dabaa1100d3404193014630e7f9123/src/process.c#L118",
          "createdAt": "2021-04-22T09:15:53Z",
          "updatedAt": "2021-04-22T09:16:26Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU4NjEzMzg3ODk=",
      "title": "Forbidding multiple calls to EDHOC-Exporter with the same label",
      "url": "https://github.com/lake-wg/edhoc/issues/97",
      "state": "CLOSED",
      "author": "malishav",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec should likely forbid multiple calls to the EDHOC-Exporter interface with the same label, in order to prevent the same key being reused.\r\n\r\nDiscussed with @karthikbhargavan and @TimothyClaeys.",
      "createdAt": "2021-04-19T13:56:41Z",
      "updatedAt": "2021-05-24T13:20:26Z",
      "closedAt": "2021-05-24T13:20:26Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch. Yes, we should have some text about that, but it should probably more be a requirement on the application using EDHOC that on EDHOC itself. Two different application should defintly not use the same label. The same application might rederive the same key several times as long as it keep track of its AEAD nonces and replay window.\r\n\r\n- I thought that we had already IANA registry proposed for this, but that is not the case. We should probably have one.\r\n- If we have a IANA registry the labels get more fixed and it might be that we need a context input parameter as well.",
          "createdAt": "2021-04-20T14:58:10Z",
          "updatedAt": "2021-04-20T14:58:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "If we make a IANA registrer for labels, I think we need to let the application add additional information in some way. Two alternatives:\r\n\r\n1. We make an IANA register for label prefixes, and let the application append information to the label prefix. This was recently planned for EAP-TLS (and methods built on EAP-TLS) but was changes because the TLS export labels are not really ment to be labels. This would not change the current exporter interface.\r\n\r\n2. We expand the interface with a context parameter. This is similar to the TLS exporter. A problem with the TLS exporter is that some implementations decided to not even support context.",
          "createdAt": "2021-04-21T10:01:31Z",
          "updatedAt": "2021-04-21T10:01:31Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@emanjon how is the context parameter intended to be used? Could you give an example? Would this be some sort of \"salt\" when deriving the key?",
          "createdAt": "2021-04-22T09:47:25Z",
          "updatedAt": "2021-04-22T09:47:25Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "Don't register labels, register label prefixes.",
          "createdAt": "2021-04-22T14:57:47Z",
          "updatedAt": "2021-04-22T14:57:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The motivation for \"context\" or \"label postfixes\" is to increase the flexibility for the application. Restricting the application to IANA registered labels is very limiting. An application might want to use the EDHOC exporter to derive a number of keys and we should encourage that. The alternative is that the application needs to implement its own key derivation, which might be less secure and might be outside of the TEE. I called it \"context\" just because TLS calls the paramater in its exporter context. ",
          "createdAt": "2021-04-22T15:13:55Z",
          "updatedAt": "2021-04-22T15:13:55Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "\"Be like TLS\" is of course a good motivation.\r\nTechnically, a label prefix is not different from a context, it just saves the need to separate prefix and suffix.\r\n",
          "createdAt": "2021-04-22T15:30:20Z",
          "updatedAt": "2021-04-22T15:30:20Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "(And of course there is nothing wrong with multiple calls with the same label; the application has a \"right to forget\" :-)",
          "createdAt": "2021-04-22T15:36:46Z",
          "updatedAt": "2021-04-22T15:36:46Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The solutions should be equal when it comes to security. The choice should be made based on what is easiest for implementators and apllications using EDHOC.\r\n\r\nAlt 1.\r\n--------------------------\r\n\r\nWe make an IANA register for label prefixes:\r\n\r\n  \"OSCORE Master Secret\"\r\n  \"OSCORE Master Salt\"\r\n\r\nThe Export function stays the same:\r\n\r\n      EDHOC-Exporter(label, length)\r\n        = EDHOC-KDF(PRK_4x3m, TH_4, label, length)\r\n\r\nAn application is allowed to append things to the label prefix:\r\n\r\n  \"OSCORE Master Secret\"\r\n  \"OSCORE Master Secret PickleRick\"\r\n\r\nAlt 2.\r\n--------------------------\r\n\r\nWe make an IANA register for labels:\r\n\r\n  label = \"OSCORE Master Secret\"\r\n  label = \"OSCORE Master Salt\"\r\n\r\nThe Export function needs to change:\r\n\r\n      EDHOC-Exporter(label, ctx, length)\r\n        = EDHOC-KDF(PRK_4x3m, TH_4, [label, ctx] , length)\r\n\r\nAn application is not allowed to append things to the label and uses the ctx instead:\r\n\r\n  label = \"OSCORE Master Secret\"\r\n  ctx = \"\"\r\n\r\n  label = \"OSCORE Master Secret\"\r\n  ctx = \"PickleRick\"\r\n\r\n",
          "createdAt": "2021-04-23T10:10:56Z",
          "updatedAt": "2021-04-23T10:10:56Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "No major opinion. Alt 2 breaks the test vector for the OSCORE security context.\r\nIt would be good to get more input.",
          "createdAt": "2021-05-03T09:14:09Z",
          "updatedAt": "2021-05-03T09:14:09Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Any preference @mcr, @pbtgit, @chrysn ?",
          "createdAt": "2021-05-04T14:21:50Z",
          "updatedAt": "2021-05-04T14:21:50Z"
        },
        {
          "author": "pbt-lab",
          "authorAssociation": "NONE",
          "body": "If desired the CTX is more convenient it can always be added in a wrapper on top of EDHOC-Exporter().\r\n(I assume re-use of label+ctx in Alt 2 is equivalent to  re-use of label in Alt 1?)\r\n",
          "createdAt": "2021-05-05T07:20:18Z",
          "updatedAt": "2021-05-05T07:20:18Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I prefer to have `ctx` explicitly specified. We can pass to `EDHOC-KDF` the concatenation of `label` and `ctx`. When `ctx` is undefined/empty, test vectors are not affected. I guess this is what @pbt-lab is referring to?",
          "createdAt": "2021-05-05T08:45:29Z",
          "updatedAt": "2021-05-05T08:45:29Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "> I assume re-use of label+ctx in Alt 2 is equivalent to re-use of label in Alt 1?)\r\n\r\nlabel is a CBOR byte string. While alt 2 use an CBOR array. Definging alt2 as a wrapper seems more complication in my view.\r\n",
          "createdAt": "2021-05-05T09:31:41Z",
          "updatedAt": "2021-05-05T09:31:41Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Would be good if people stated alt 1. or alt 2. or made a concrete suggestion for alt 3.",
          "createdAt": "2021-05-05T09:32:42Z",
          "updatedAt": "2021-05-05T09:32:42Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alt 3 (CBOR sequence)\r\n--------------------------\r\n\r\nWe make an IANA register for labels:\r\n\r\n  label = \"OSCORE Master Secret\"\r\n  label = \"OSCORE Master Salt\"\r\n\r\nThe Export function needs to change:\r\n\r\n      EDHOC-Exporter(label, ctx, length)\r\n        = EDHOC-KDF(PRK_4x3m, TH_4, label_context, length)\r\n        \r\nwhere `label_context` is a CBOR sequence:\r\n\r\n```\r\nlabel_context = (\r\n      label : tstr,\r\n      ctx : bstr,   (edited per suggestion below)\r\n)\r\n```\r\n\r\nIf you want to keep the test vectors intact, then you could make `ctx` optional in the CDDL, but not sure how to specify an optional parameter in the `EDHOC-Exporter` interface definition.",
          "createdAt": "2021-05-05T09:53:31Z",
          "updatedAt": "2021-05-05T14:05:44Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. That is a valid alt 3. but ctx should probably be a bstr ",
          "createdAt": "2021-05-05T09:57:08Z",
          "updatedAt": "2021-05-05T09:57:08Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think keeping the test vectors intact is an important goal at all. Let's decide on what is simplest for a user of the exporter interface. ",
          "createdAt": "2021-05-05T09:59:38Z",
          "updatedAt": "2021-05-05T09:59:38Z"
        },
        {
          "author": "pbt-lab",
          "authorAssociation": "NONE",
          "body": "> I prefer to have `ctx` explicitly specified. We can pass to `EDHOC-KDF` the concatenation of `label` and `ctx`. When `ctx` is undefined/empty, test vectors are not affected. I guess this is what @pbt-lab is referring to?\r\nSomething like that, yes. Later post do differentiate the type of \"label\" and \"ctx\" and in light of that and changing test vectors Alt3 seems clean.   \r\n",
          "createdAt": "2021-05-05T20:43:37Z",
          "updatedAt": "2021-05-05T20:43:37Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with alt 3. I can start making PR for that unless somebody has different ideas.\r\n\r\nI don't alt 1 is a good alternative anymore as is restricts context to being a unicode string. Which would require some base64 encoding or similar for a general context.",
          "createdAt": "2021-05-06T06:43:23Z",
          "updatedAt": "2021-05-06T06:43:23Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Please review alt. 3 as specified in #114. Unless there are any comments we would like to merge this.",
          "createdAt": "2021-05-07T13:35:57Z",
          "updatedAt": "2021-05-07T13:35:57Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This is included in -07 so I close the issue.",
          "createdAt": "2021-05-24T13:20:23Z",
          "updatedAt": "2021-05-24T13:20:23Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU4NjI3MzUxMDg=",
      "title": "TEE security consideration",
      "url": "https://github.com/lake-wg/edhoc/issues/99",
      "state": "OPEN",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 8.6 in -05 states:\r\n\r\n  \"Typically an \r\n    adversary with physical access to a device can be assumed to gain \r\n    access to all information outside of the TEE, but none of the \r\n    information inside the TEE.\"\r\n\r\nStefan Hristozov commented:\r\n\r\n    \"A TEE does not provide protection against physical adversary, since the same CPU with the same physical memory executes both the operations in the TEE and in the non-TEE domains. It provides protection only against remote adversary exploiting, e.g., a buffer overflow for conducting code injection or return oriented attacks.\"\r\n\r\nFollowing the description in [1] I replaced the text with:\r\n\r\n\"The use of a TEE enforces that code within that environment cannot be tampered with, and that any data used by such code cannot be read or tampered with by code outside that environment.\"\r\n\r\nhttps://github.com/lake-wg/edhoc/commit/665d60c\r\n\r\nAny objections to this?\r\n\r\n\r\n[1] https://tools.ietf.org/html/draft-ietf-teep-architecture-14\r\n",
      "createdAt": "2021-04-20T11:51:03Z",
      "updatedAt": "2021-05-06T18:06:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Good to talk about attacks from code outside of the TEE, but not good to remove everything about physical attacks. The original text was written only thinking about physical attacks using the TEE definition from [1]. That definition in [1]states: \"The TEE resists against all software attacks as well as the physical attacks performedon the main memory of the system.\" so I don't think \"A TEE does not provide protection against physical adversary\" is completely correct. I would prefer the definition of TEE in [1] but I guess I have to accept the that current commercialy avilable TEEs does not enforce does not enforce memory encryption and also only provides a single zone inside the TEE.\r\n\r\nI think the suggested new text is ok, but I think it needs to be augmented with a sentence about memory encryption as well as attacks from non-EDHOC code inside the TEE.\r\n",
          "createdAt": "2021-04-20T15:21:40Z",
          "updatedAt": "2021-04-20T15:21:40Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I added some additional text on additional attacks and how to protect. I think the new is very good. The TEE definition taken from TEEP describe a quite basic TEE which is good.\r\n\r\nIf you agree with the updated text we can close this issue.",
          "createdAt": "2021-04-29T09:31:51Z",
          "updatedAt": "2021-04-29T09:31:51Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri are you ok with the suggested update?\r\n\r\nhttps://github.com/lake-wg/edhoc/commit/57ac5116f91b81a1e9ada0d157d896eca814d331\r\n\r\n",
          "createdAt": "2021-04-30T12:06:05Z",
          "updatedAt": "2021-04-30T12:06:05Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "Hi,\r\nI don't understand what you want to say with the sentence \"The TEE can also be used to protect the EDHOC and application protocol (e.g. OSCORE) implementation using some form of \"secure boot\", memory protection etc.\" Secure boot and TEE are different things. I think both make sense but they are not necessarily related to each other. \r\n\r\nI also think the sentence \"To provide better protection against physical attacks, memory encryption needs to be enforced.\"\r\nis incorrect since physical attacks are a very broad topic and memory encryption certainly does not protect against some common form of physical attacks such as (deferential) power analysis and fault injections.\r\n\r\n",
          "createdAt": "2021-05-03T07:53:40Z",
          "updatedAt": "2021-05-03T07:53:40Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The \"secure boot\" text was old, I don't know where it came from. I wrote a new sentence about secure boot and REE.\r\n\r\nRegarding physical attacks. bus encryption seems to be recommended to protect against some physical attacks. I agree that this does not protect against all physical attacks.\r\n\r\nhttps://www.usenix.org/system/files/raid2019-zhao.pdf\r\nhttps://people.dsv.su.se/~icss-jpc/exjobb/interesting/2004_vlsid_invited.pdf\r\n\r\nI changed the text to say \"some forms of physical attacks\" and rewrote the text a bit.\r\n\r\n\"If supported by the device, it is RECOMMENDED that at least the long-term private keys is stored in a Trusted Execution Environment (TEE) and that sensitive operations using these keys are performed inside the TEE. To achieve even higher security it is RECOMMENDED that additional operations such as ephemeral key generation, all computations of shared secrets, and storage of the PRK keys can be done inside the TEE. The use of a TEE enforces that code within that environment cannot be tampered with, and that any data used by such code cannot be read or tampered with by code outside that environment. Note that non-EDHOC code inside the TEE might still be able to read EDHOC data and tamper with EDHOC code, to protect against such attacks EDHOC needs to be in its own zone. **To provide better protection against some forms of physical attacks, sensitive EDHOC data should be stored inside the SoC or encrypted and integrity protected when send on a data bus (e.g. between the CPU and RAM or Flash). Secure boot can be used to increase the security of code and data in the Rich Execution Environment (REE) by validating the REE image.**\"\r\n\r\n\r\n\r\n",
          "createdAt": "2021-05-05T21:20:51Z",
          "updatedAt": "2021-05-05T21:20:51Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "There are many different attacks and different countermeasures which depend a lot on the hardware platform. To give an in-depth analysis of different attacks and countermeasures is certainly outside the scope of the standard. I will suggest keeping it short and reference relevant papers where more concrete analysis is done. Moreover, this is a general problem that every security protocol has. ",
          "createdAt": "2021-05-06T18:06:26Z",
          "updatedAt": "2021-05-06T18:06:26Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU4NjI5NDQ0MDg=",
      "title": "Scope of the applicability statement.",
      "url": "https://github.com/lake-wg/edhoc/issues/100",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "My view of the applicability statement appendix was that is was a simple list of things that I and R needs to make sure that they both support because otherwise the protocol will end in error. Now the appendix has been move into the body, been made normative, and to my understanding changed scope.\r\n\r\n\"In order to ensure that EDHOC is used for the intended purpose, each message needs to be verified against an applicability statement associated to the protocol instance. If the message does not comply with the applicability statement, the protocol needs to be discontinued.\"\r\n\r\nI don't think this is a good idea. This seems to unesicarily increase complexity and make implementations bigger. Comparing with TLS this would be like stating that you need to check the every cipher suite, extension, certificate format etc has been pre-approved for use with a certain endpoint. Are any of the checks strictly needed for security reasons? Otherwise I think these kind of checks should be part of an optional policy mechanism outside of EDHOC.",
      "createdAt": "2021-04-20T15:30:44Z",
      "updatedAt": "2021-09-11T20:22:55Z",
      "closedAt": "2021-09-11T20:22:55Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with the new text",
          "createdAt": "2021-09-11T20:22:55Z",
          "updatedAt": "2021-09-11T20:22:55Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU4NjM2ODQ1MjU=",
      "title": "EDHOC and Availability",
      "url": "https://github.com/lake-wg/edhoc/issues/101",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft has the following text in several places:\r\n\r\n\"If any verification step fails, the Responder MUST send an EDHOC error message back, formatted as defined in {{error}}, and the protocol MUST be discontinued.\"\r\n\r\nI am not sure this is a good idea. This means that the availability of EDHOC will be low. An attacker can e.g. send a single byte as message_4 and it would make EDHOC shut down imidiatly. I think we need to soften this and give the implementation some more choice here.\r\n\r\nAre there constrained radio protocols where noice could be mistaken for an actual message and forwarded to EDHOC or do all constrained radio have strong enough CRC to make sure that that more or less never happens? ",
      "createdAt": "2021-04-21T09:49:35Z",
      "updatedAt": "2021-05-21T19:04:02Z",
      "closedAt": "2021-05-21T19:04:02Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I just changed the following text\r\n\r\nOLD:\r\nIf the Initiator previously received from the Responder an error message with error code 1 (see Section 6.3) indicating cipher suites supported by the Responder which also are supported by the Initiator, then the Initiator SHALL select the most preferred cipher suite of those.\r\n\r\nNEW:\r\nIf the Initiator previously received from the Responder an error message with error code 1 (see Section 6.3) indicating cipher suites supported by the Responder which also are supported by the Initiator, then the Initiator SHOULD select the most preferred cipher suite of those (note that error messages are not authenticated and may be forged).\r\n\r\nMade me think about that I don't think the group has discussed if some error messages should be authenticated.\r\n\r\nSome error messages to message_2 could include a MAC to prove that the error was sent by the same party that sent message_3. error messages to message_3 and message_4 could be authenticated.\r\n\r\nI am uncertain if this is worth specifying. At least not as long as there are easier ways to an attacker to end the protocol. I think what needs to be done is to specify that\r\n- a processing error does not need to discontinue the protocol, the received message can have been an attack.\r\n- receiveing an error does not need to discontinue the protocol, the received error can have been an attack.",
          "createdAt": "2021-04-21T18:20:56Z",
          "updatedAt": "2021-04-21T18:20:56Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "from 20210422 interim: CB perhaps wisely said: \"Use cases exist for multiplexing over same port/URI, so applications should normally sort/demultiplex traffic before start interpreting as EDHOC, which implies treating invalid messages that get to EDHOC code as an error or attack\"\r\n",
          "createdAt": "2021-04-22T14:46:43Z",
          "updatedAt": "2021-04-22T14:46:43Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, my understanding is that we only need to be concerned about attacks where an attacker sends a packet crafted so that it will be processed by EDHOC (which is not hard). ",
          "createdAt": "2021-04-25T09:40:15Z",
          "updatedAt": "2021-04-25T09:40:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a pull request #109 addressing this issue\r\n- Added text on demultiplexing.\r\n- Changed procession so implementation are not mandated to shut down the session if an attacker sends a few bytes to the EDHOC resource / port..\r\n- Added more security consideration on Denial of service.",
          "createdAt": "2021-04-30T11:35:24Z",
          "updatedAt": "2021-04-30T11:35:24Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Writing this PR made me think about whether we want to mandate that error messages are always fatal as well as downgrade protection.\r\n\r\n- The \"\"Wrong selected cipher suite\" error is fatal because it is sent in repsponse to message_1. You could consider similar types of error sent in response to message_2 and message_3. E.g. ID_CRED format not supported or CRED format not supported or X.509 public key algorithm not supported.\r\n\r\n[BBFGKZ16] defines the following theoretical downgrade protection for a session: The cryptographic parameters should be the same on both sides and should be the same as if the peers had been communicating in the absence of an attack. But this definition has very little to do with practical security. In practice it does not matter if an attacker can influence the chosen parameter in the current session or a following session.\r\n\r\nI am still confused regarding the purpose of the applicability statement. Is it a informal section describing things the parties need to both support to make the protocol work or is a normative security section relevant for policy and downgrade.\r\n\r\nIf we want downgrade protection over multiple sessions, the parties need to agree or securely negotiate everything. Downgrade protection for a session does not make much sense to me if an attacker can force the parties to set up a second session with lower security.\r\n\r\n       \r\n",
          "createdAt": "2021-04-30T11:59:12Z",
          "updatedAt": "2021-04-30T11:59:12Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we need to align the terminology, we use both \"session\" and \"instance\" in the draft?",
          "createdAt": "2021-04-30T13:19:47Z",
          "updatedAt": "2021-04-30T13:19:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I just changed \"protocol\" to \"session\" not remembering that the draft use instance in other places.",
          "createdAt": "2021-04-30T13:27:42Z",
          "updatedAt": "2021-04-30T13:27:42Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "We can resolve this later, I opened #112.\r\n\r\nUnless there are other comments we will soon merge this.",
          "createdAt": "2021-05-04T15:04:31Z",
          "updatedAt": "2021-05-04T15:04:31Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR has been discussed and merged. Closing",
          "createdAt": "2021-05-21T19:04:01Z",
          "updatedAt": "2021-05-21T19:04:01Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU4NjQ3Mzg2NDQ=",
      "title": "Optimization of message size",
      "url": "https://github.com/lake-wg/edhoc/issues/103",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to nail down what optimizations to make in the final message format. \r\n\r\nKnown lengths of byte strings can be used as discussed in the old issue tracker:\r\nhttps://github.com/EricssonResearch/EDHOC/issues/95\r\n",
      "createdAt": "2021-04-22T09:27:34Z",
      "updatedAt": "2021-08-26T16:41:12Z",
      "closedAt": "2021-08-26T16:41:12Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We should confirm the values from the rewuirement phase. If I remember correctly 45 bytes for message_2 in 5-hop 6TiSCH was the strictest requirement. We can reasch that but before we optimize for that, we should confirm that the group wants to optimize for 5-hop 6TiSCH (or is 4-hop godd enough) and also double check and verify that 45 bytes is the correct number to optimize for.\r\n\r\nIf I remember correctly Lorawan was a little bit less demanding than 5-hop 6TiSCH wih 48 bytes?.\r\n\r\nEvery single byte can make a large difference if you suddenly have to fragment and send two frames instead of one. On the other hand there has been discusssions that is would be nice to mandate C_R in message_2 and to skip the bstr_identifier optimization of ID_CRED_R. ",
          "createdAt": "2021-04-23T09:56:11Z",
          "updatedAt": "2021-04-23T09:56:11Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "John added a comment on an issue in the old repo which probably was intended to be on this issue: \r\nhttps://github.com/EricssonResearch/EDHOC/issues/95",
          "createdAt": "2021-05-17T15:23:14Z",
          "updatedAt": "2021-05-17T15:23:14Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Several things have been discussed regarding optimisations (or simplifications adding bytes).\r\n\r\nMessage_2 is the largest message and it is sent over downlink in 6TiSCH which is more constrained than uplink in 6TiSCH. Therefore only message_2 is discussed below.\r\n\r\n- Connection IDs - It has been discussed to make conection IDs mandatory (or default). Given the current connection id encoding this would add 1 byte to message_2 when sent in CoAP response. Note that there has also been suggested to move connection ids to a shim layer. This would not affect the total overhead, just move bytes from EDHOC to lower layers. If connection ids are kept in EHOC I think EDHOC should adopt Christians suggestion for encoding.\r\n\r\n- bstr_identifier - Is has been pointed out that the bstr_identifier is complicated and looks like overopimization, adding complexity to spec and implementations. Christian has some excellent suggestions on how to encode the connection identifiers. Then the bstr_identifier is only use to encode ID_CRED containing kid. This optimisations could maybe be skipped. This would add 1 byte to message_2 when certain 1 byte KIDs are used. I think this should be done unless the byte saving is very much needed.\r\n\r\n- Known lengths - There are several bstr whose length is known. E.g. G_Y and Signature_or_MAC_2. Concatenating G_Y and CIPHERTEXT_2 would save 1-2 bytes. The known length of Signature_or_MAC_2 is harder to use as a change would mean that the plaintext is no longer a CBOR sequance. Changing plaintext to be a CBOR SEQUENCE concatenated with the value of Signature_or_MAC_2 would save an additional 1-2 bytes. I don't think any of these optimizations should be done unless the byte savings are essential.\r\n\r\nThe above addition/removal of optimizations needs to be discussed together with a renewed discussion of the limits in 6TiSCH. In the end it is a tradeoff between complexity and how many deployments should be supported with unfragmented message_2.",
          "createdAt": "2021-05-17T15:25:27Z",
          "updatedAt": "2021-05-17T15:25:55Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed during the design team meeting, the new \"6TiSCH Overhead Estimator\" is available at: https://docs.google.com/spreadsheets/d/1FjlGrgVu6ZSw2bt1KxAS9O5gtGXxBoGnqK3QeVFGx1Q/edit?usp=sharing\r\n\r\nThis estimator obsoletes the old Google document by updating the overhead numbers to the latest RFCs that are used in 6TiSCH, fixes an erratum present in the old doc, and adds new features such as short addressing support and UDP overhead compression.",
          "createdAt": "2021-05-26T09:33:05Z",
          "updatedAt": "2021-05-26T09:33:05Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed in the recent interim meeting, we postpone the resolution of this issue until the draft is ready for WGLC.",
          "createdAt": "2021-07-15T20:41:33Z",
          "updatedAt": "2021-07-15T20:41:33Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this can be closed now. We have discussed and done the agreed optimizations. ",
          "createdAt": "2021-08-26T16:41:11Z",
          "updatedAt": "2021-08-26T16:41:11Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU4NjU4Mjg0MjE=",
      "title": "distinguishing different certificates types/encoding within x5chain",
      "url": "https://github.com/lake-wg/edhoc/issues/104",
      "state": "CLOSED",
      "author": "StefanHri",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We can use EDHOC with DER/PEM x509 certificates as well as re-encoded x509 and native CBOR certificates. How certificate type and encoding can be distinguished when x5chain is used?  ",
      "createdAt": "2021-04-23T07:24:54Z",
      "updatedAt": "2021-05-05T14:15:55Z",
      "closedAt": "2021-05-05T14:15:55Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "For C509 certificates (working name for what was previously called CBOR certificates) other CBOR labels are requested, see\r\nhttps://tools.ietf.org/html/draft-mattsson-cose-cbor-cert-compress-08#section-8.8\r\n\r\nc5c correspond to x5chain\r\nc5b correspond to x5bag\r\nc5t correspond to x5t\r\nc5u correspond to x5u\r\n\r\nThe two types of C509 certificates, re-encoded X.509 and natively signed C509, can be distinguished by the first bit. ",
          "createdAt": "2021-04-23T07:45:00Z",
          "updatedAt": "2021-04-23T07:45:00Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": ">  first bit\r\n\r\nfirst byte right now, but formally the first CBOR item\r\n\r\n>We can use EDHOC with DER/PEM x509\r\n\r\nI do not think you can use COSE/EDHOC with PEM encoding. x5chain/x5bag/x5t is always DER encoding as far as I know. I don't know about how x5u and pplication/pkcs7-mime is encoded. ",
          "createdAt": "2021-04-23T09:49:03Z",
          "updatedAt": "2021-04-23T11:24:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri does this answer you questions? Seems mostly like a COSE question. Do you think any clarifications are needed to the EDHOC document?\r\n",
          "createdAt": "2021-04-30T12:07:10Z",
          "updatedAt": "2021-04-30T12:07:10Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "Yes, I think this is now clear for me. However, I noticed now something more in this section namely: \r\n\r\nThe section starts with:\r\n\"ID_CRED_I and ID_CRED_R are identifiers of the public authentication\r\n   keys of the Initiator and the Responder, respectively.  ID_CRED_I and\r\n   ID_CRED_R do not have any cryptographic purpose in EDHOC.\"\r\n\r\nand then a bit later:\r\n\"ID_CRED_x MAY contain the actual credential used for\r\n      authentication, CRED_x.  For example, a certificate chain can be\r\n      transported in ID_CRED_x with COSE header parameter c5c or\r\n      x5chain, defined in [I-D.mattsson-cose-cbor-cert-compress] and\r\n      [I-D.ietf-cose-x509].\" \r\n\r\nBoth sentences are contradictory. I will suggest changing the first sentence to something like: \"ID_CRED_x MAY contain an identifier or a certificate ...\" ",
          "createdAt": "2021-05-03T08:10:29Z",
          "updatedAt": "2021-05-03T08:10:29Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri I suppose the use of the term \"identifier\" is confusing. How about changing the beginning: \r\n\r\nOLD\r\n\"ID_CRED_I and ID_CRED_R are identifiers of the public authentication\r\nkeys of the Initiator and the Responder, respectively. \r\n\r\nNEW\r\n\"ID_CRED_I and ID_CRED_R are used to identify the public authentication\r\nkeys of the Initiator and the Responder, respectively. \r\n\r\n\r\n",
          "createdAt": "2021-05-04T12:53:25Z",
          "updatedAt": "2021-05-04T12:53:25Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "I am confused. ID_CRED_I and ID_CRED_R can contain a certificate right? When ID_CRED_I and ID_CRED_R contain a certificate they are not used to identify the public authentication but carry it?\r\n",
          "createdAt": "2021-05-04T16:25:21Z",
          "updatedAt": "2021-05-04T16:25:21Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@StefanHri I didn't see a contradiction between a piece of data identifying a credential and containing the credential. But if it is confusing it is perhaps better to be explicit. How about this:\r\n\r\nOLD\r\n\"ID_CRED_I and ID_CRED_R are identifiers of the public authentication\r\nkeys of the Initiator and the Responder, respectively.\r\n\r\nNEW\r\n\"ID_CRED_I and ID_CRED_R are used to identify and optionally transport the public authentication keys of the Initiator and the Responder, respectively.",
          "createdAt": "2021-05-05T13:59:34Z",
          "updatedAt": "2021-05-05T13:59:34Z"
        },
        {
          "author": "StefanHri",
          "authorAssociation": "NONE",
          "body": "This is way more clear for me. Thank you!",
          "createdAt": "2021-05-05T14:06:29Z",
          "updatedAt": "2021-05-05T14:06:29Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU4NjU5ODUxMzg=",
      "title": "Simplifying the correlation",
      "url": "https://github.com/lake-wg/edhoc/issues/105",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "So here's something that may sound a bit intrusive on the whole specification, but from two discussions today it may be worth it:\r\n\r\n*What If we take the topic of correlation out of EDHOC completely (like, make corr=3 the only mode it has) and in exchange make it a requirement on the transport to provide method correlation all the time?*\r\n\r\nThe goal of that exercise would be to reduce over-all complexity. It would take complexity out of EDHOC itself, move it to the EDHOC-over-foo layers -- but it seems to me that all those correlation topics are easier to describe there, reducing over-all complexity.\r\n\r\nConcrete changes would be:\r\n\r\n* Mentions of the corr parameter would go away from everywhere thy are now; METHOD_CORR would just become METHOD (2 bits rather than 4).\r\n* All the data_x items that now have leading `? C_x` would drop them.\r\n* \"Message correlation\" would be added to the transport (applicability statement) requirements.\r\n* The CoAP applicability statement would grow by text like this:\r\n\r\n> Whenever an EDHOC message is sent from a client to a server in the payload, the EDHOC message is prefixed with the CBOR serialization of the C_x the server picked; in a message_1 (as the server has not picked the C_x), a `null` (encoded as `f6`) is sent there instead. The server uses this first CBOR item to identify the ongoing exchange, and uses the remainder of the payload as an EDHOC message.\r\n>\r\n> As a side note, this means that while responses in an exchange of EDHOC over CoAP are of media type application/edhoc, the requests are not, and there is currently no media type that describes \"application/edhoc with an identifier prefixed\". This is more of a theoretical concern, as EDHOC exchanges are not typically accompanied by explicit content formats.\r\n\r\nThese two paragraphs (of which only one is essential) can be much shorter as the stripped-out text, because not only does all the talk about encoding and naming the correlations gets dropped, but also the roles are clearer: We don't have to talk of \"C_I in this case, C_R in that case\", but (now that we have the terminology of server and client provided by CoAP) can talk of \"the C_x picked by the server\".\r\n\r\n(A side effect of this phrasing \"in the payload\" is that it'd trivially ensure that the EDHOC option from draft-palombini-core-oscore-edhoc-02 would be sent without the C_i which was considered for manual stripping-out anyway as it'd be redundant with the kid from the OSCORE option).",
      "createdAt": "2021-04-23T10:37:09Z",
      "updatedAt": "2021-07-16T12:20:18Z",
      "closedAt": "2021-07-16T12:20:18Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Note that this would trivially resolve #89.",
          "createdAt": "2021-04-23T10:41:52Z",
          "updatedAt": "2021-04-23T10:41:52Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The current spec (-08) essentially incorporated this proposal. \r\n\r\n@chrysn Anything missing?",
          "createdAt": "2021-07-15T20:36:44Z",
          "updatedAt": "2021-07-15T20:36:44Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "I've just only had a short glance at -08, and what I've seen resolves this issue; in particlar, I like how appendix turned out.\r\n\r\nI'll read (and maybe implement -- no promises) the changed document until the IETF111, but if anything *is* missing I'd open a separate issue; closing this.\r\n\r\nThanks!",
          "createdAt": "2021-07-16T12:20:18Z",
          "updatedAt": "2021-07-16T12:20:18Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU4NzA4MDI0Mzc=",
      "title": "CFRG suggestion for make the EDHOC Elliptic-Curve-Point-to-Octet-String Conversion a bit more formal so that it can be refered by other specifications.",
      "url": "https://github.com/lake-wg/edhoc/issues/107",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was suggested in CFRG during the discussion on HPKE Elliptic-Curve-Point-to-Octet-String Conversion. The compact representation used in EDHOC can be used whenever compact output is used in ECDH (which it almost always is).\r\n\r\nImportant to differenctiate between the wire format, the validation done, and the algorithm for multiplication. EDHOC only touch the wire format, and do not loosen any validation requirements or recommend any particular algorithms form multiplication.\r\n\r\nSuggestion oflline that it might be better to specify that the \"y-bit\" is set to 0 instead of giving the implementor an option.\r\n\r\nSuggestion offline that the draft should refer to SECG in addition or instead of NIST.\r\n ",
      "createdAt": "2021-04-29T09:20:34Z",
      "updatedAt": "2021-05-04T14:55:54Z",
      "closedAt": "2021-05-04T14:55:54Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR #108 trying to capture the suggestion from CFRG. I think the PR is ready to merge.",
          "createdAt": "2021-05-04T10:39:57Z",
          "updatedAt": "2021-05-04T10:39:57Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU4NzQzOTMyNTQ=",
      "title": "Add AD_4",
      "url": "https://github.com/lake-wg/edhoc/issues/110",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Has been suggestion to add AD_4 to message 4.",
      "createdAt": "2021-05-03T09:18:19Z",
      "updatedAt": "2021-05-24T13:17:44Z",
      "closedAt": "2021-05-24T13:17:44Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR #111 addressing all the issue mentioned with aux data.\r\n\r\nThe PR addresses issue #90 ",
          "createdAt": "2021-05-04T10:39:09Z",
          "updatedAt": "2021-05-04T10:39:09Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "EAD_4 is added to message_4 in -07 so I close this issue.",
          "createdAt": "2021-05-24T13:17:44Z",
          "updatedAt": "2021-05-24T13:17:44Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU4NzU1NTM0NjU=",
      "title": "Align \"session\" and \"protocol instance\"",
      "url": "https://github.com/lake-wg/edhoc/issues/112",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The text use both the terms \"session\" and \"protocol instance\", would be good to settle for one term.",
      "createdAt": "2021-05-04T15:00:58Z",
      "updatedAt": "2021-05-07T14:24:11Z",
      "closedAt": "2021-05-07T14:24:11Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Just chose one, I don't think this needs an issue",
          "createdAt": "2021-05-05T09:33:33Z",
          "updatedAt": "2021-05-05T09:33:33Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "In the security considerations \"session\" makes most sense to me. There is also the term \"connection\". I will make a proposal.",
          "createdAt": "2021-05-05T14:02:52Z",
          "updatedAt": "2021-05-05T14:02:52Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWU4OTA0NTc2OTg=",
      "title": "Transfer CWT",
      "url": "https://github.com/lake-wg/edhoc/issues/115",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Discussion today in COSE on how to do RPK by value in EDHOC. Suggestions to send a COSE_Key or a C509. Additional suggestion from Carsten to use CWT. Several issues in the old GitHub on CWTs, that were not transfered to the new GitHub:\r\n\r\nhttps://github.com/EricssonResearch/EDHOC/issues/5\r\nhttps://github.com/EricssonResearch/EDHOC/issues/33\r\nhttps://github.com/EricssonResearch/EDHOC/issues/37\r\n\r\nDiscussion to transfer CWT in kid, in Auxilery data, and as COSE header parameter.\r\n\r\nTransfering CWT is related to issues #88, #62,  #90, #82",
      "createdAt": "2021-05-12T20:26:17Z",
      "updatedAt": "2021-08-26T16:45:14Z",
      "closedAt": "2021-08-26T16:45:14Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a pull request for this\r\n\r\nhttps://github.com/lake-wg/edhoc/pull/116\r\n\r\nI think it is essential that EDHOC supports CWT. CWTs are much more flexible than X.509 / C.509. I think both are needed. The need for CWT has been discussed since 2016. I think it was decided clear quite early that transporting CWT is needed but was a discussion on how to transfer them. In Aux Data, in COSE header parameter, or in the kid bstr. For some reason nothing was ever specified. \r\n\r\nTLS WG is discussing to add support for CWT. \r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-tschofenig-tls-cwt-02\r\n\r\nI think certificates and CWT needs to be included, I am not sure that we need a different format for RPK. Likely CWT or C509 can be used for this purpose.",
          "createdAt": "2021-05-13T12:31:10Z",
          "updatedAt": "2021-05-13T12:31:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it should be discussed if CWT is good enough for the #88. My initial understanding is that it is but this needs to be analyzed and discussed. My current thoughts.\r\n\r\n- CWT needs to be supported in EDHOC.\r\n- Most things in CWT is optional, it is likely an optimized enough format for the oportunistic / TOFU use case of \"RPK\". CWT is also very flexible.\r\n- When CWT exist it would be strange to standardize a new format for transfereing a COSE_Key unless it is really really needed to save bytes.\r\n- CWT + Deterministic CBOR could maybe replace the discussion on how to integrity protect COSE_Keys. We should at least remove the new subject_name from the COSE_Key part in the EDHOC document. CWT and C509 can be used when subject name is needed. Does \"Raw\" COSE_Keys that are not CWT even need to be supported? Or would CWT / C509 / X.509 be enough",
          "createdAt": "2021-05-17T08:48:52Z",
          "updatedAt": "2021-05-17T08:48:52Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This change has now been done in the master branch, see a1b25ba and commits in its vicinity.\r\n\r\nCan we close the issue?",
          "createdAt": "2021-07-24T11:45:51Z",
          "updatedAt": "2021-07-24T11:45:51Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This has now been addressed.",
          "createdAt": "2021-08-26T16:45:14Z",
          "updatedAt": "2021-08-26T16:45:14Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU4OTQwOTU2MTA=",
      "title": "C_1: use \"nil\" instead of \"null\"",
      "url": "https://github.com/lake-wg/edhoc/issues/118",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "CDDL knows both names for \"null\" and \"nil\", but (especially with #117) a careless reader could read the \"prepending a null\" as \"prepend the byte zero\", which is not what is meant (given that the prepending is introduced as \"prepend the CBOR serialization of C_x\").\r\n\r\nA downside is that in CBOR itself, the value is always called \"Null\" -- but unlike CDDL (and COSE), it does not introduce much of terminology for the simple types (it just describes it as meaning \"null\"; most of the remaining use of the term is in the context of a JSON null).\r\n\r\nI suggest this change in an issue rather than in a PR, as doing any change now while #117 is in the air would just create more work later anyway.\r\n\r\nIf this is accepted (and \"let's better stick to plain CBOR terminology\" is still a plausible outcome), I can PR this once #117's fate is decided.",
      "createdAt": "2021-05-18T08:01:25Z",
      "updatedAt": "2021-08-21T15:21:34Z",
      "closedAt": "2021-08-21T15:21:34Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I am personally fine with both. ",
          "createdAt": "2021-05-18T14:20:05Z",
          "updatedAt": "2021-05-18T14:20:05Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree \"null\" is confusing. Not sure \"nil\" is less confusing. The fact that RFC8610 defines null as nil may result in the same interpretation, and most people don't read beyond RFC8949 where the term \"nil\" is not used. \r\n\r\nWould it be less ambiguous to pick another CBOR Simple Value, like \"true\" (0xf5)?\r\n\r\n",
          "createdAt": "2021-05-21T07:18:56Z",
          "updatedAt": "2021-05-21T07:18:56Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "OTOH, if it just a matter of disambiguating the word \"null\", then we could use \"nil\" instead. Given that we stick to the simple CBOR value 0xf6, as in -08, then making the change is an improvement.",
          "createdAt": "2021-07-15T20:47:35Z",
          "updatedAt": "2021-07-15T20:47:35Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Given the usefulness to implementers of CBOR tools like cbor.me,  I  think there is a good reason to stick to the diagnostic notation in RFC 8949. For this reason I reopen this issue.",
          "createdAt": "2021-08-18T17:07:11Z",
          "updatedAt": "2021-08-18T17:07:11Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "We should thus replace the current 'nil' with some 1-byte value with  RFC 8949 diagnostic notation. Instead of reverting to 'null' I propose we pick another simple value. I did not note any objection to the proposal above to use 'true' and will therefore make that change now.",
          "createdAt": "2021-08-18T17:43:23Z",
          "updatedAt": "2021-08-18T17:43:23Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Change made in 31f2ce58d",
          "createdAt": "2021-08-18T17:58:47Z",
          "updatedAt": "2021-08-18T17:58:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This has now been changes to true. Which make this issue outdated",
          "createdAt": "2021-08-21T15:21:34Z",
          "updatedAt": "2021-08-21T15:21:34Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWU4OTQ0NjA5MjU=",
      "title": "Initial set of cipher suites",
      "url": "https://github.com/lake-wg/edhoc/issues/120",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Is it worth having 4 diiference CCM based ciphser suites. And are they the correct 4?\r\n\r\n- EDHOC should probably have a ChaCha20-Poly1305 cipher suite from start. Probably with SHA-256. X25519 and EdDSA.\r\n\r\n- The CNSA cipher suite does not really need a 1 byte value. Could live with 2 byte value.",
      "createdAt": "2021-05-18T14:42:11Z",
      "updatedAt": "2021-07-15T20:48:40Z",
      "closedAt": "2021-07-15T20:48:40Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "-Agreement during interim is that the 4 different CCM are all needed and that they are the correct ones.\r\n-ChaCha20 should be combined with both P-256 and X25519\r\n-CNSA suite can have two bytes.\r\n",
          "createdAt": "2021-06-02T10:37:58Z",
          "updatedAt": "2021-06-02T10:37:58Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should specify a X448/SHAKE256 suite to complement the CNSA suite.",
          "createdAt": "2021-06-02T10:39:15Z",
          "updatedAt": "2021-06-02T10:39:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The GCM suite is chosen to match what is currently used on the web which is X25519 combined with P-256 ECDSA. Not sure we need to specify anything else here. IoT community seems more interested in ChaCha20 than GCM.\r\n\r\n~~~~~~~~~~~\r\n   6. ( 1, -16, 4, -7, 1, -16 )\r\n      (A128GCM, SHA-256, X25519, ES256,\r\n       A128GCM, SHA-256)\r\n~~~~~~~~~~~",
          "createdAt": "2021-06-02T10:41:13Z",
          "updatedAt": "2021-06-02T10:41:13Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/lake-wg/edhoc/pull/127",
          "createdAt": "2021-06-02T10:43:00Z",
          "updatedAt": "2021-06-02T10:43:00Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved  with #127.",
          "createdAt": "2021-07-15T20:48:40Z",
          "updatedAt": "2021-07-15T20:48:40Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWU4OTQ5ODQ1MjI=",
      "title": "Simpler more secure MAC calculation",
      "url": "https://github.com/lake-wg/edhoc/issues/121",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "COSE has discussed and are are planning to standardize new encryption algorithms for the AEAD interface after a request from FIDO. The new algorithms would not provide any integrity protection.\r\n\r\nThe current version of the Group OSCORE draft would not be secure at all with these new algorithms due to the unusual design choice to let the sender countersign it's own AEAD. This could easily be addressed by using a traditional MAC-then-Sign approach.\r\n\r\nEDHOC currently uses the inner COSE_Encrypt as a MAC function, this would of course be unsecure if the encryption function is AES-CTR.",
      "createdAt": "2021-05-19T04:44:50Z",
      "updatedAt": "2021-08-21T15:20:50Z",
      "closedAt": "2021-08-21T15:20:50Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Might actually be a very good idea to change the inner COSE_Encrypt0 to just a simple single invocation of the EDHOC-KDF(). As pointed out in [1] the short MAC length is probably the weakest point in the EDHOC design.\r\n\r\n[1] https://github.com/lake-wg/edhoc/blob/master/Security%20Level/Security%20Levels%20and%20Design%20Goals%20of%20EDHOC.txt\r\n\r\nChaning inner COSE_Encrypt0 to EDHOC-KDF() would significantly simplify the specification\r\n\r\nNEW\r\n```\r\nCompute MAC_3 = EDHOC-KDF( PRK_4x3m, TH_3, ( ID_CRED_I, CRED_I, ? AD_3 ), length )\r\n```\r\n\r\nOLD\r\n```\r\nCompute an inner COSE_Encrypt0 as defined in Section 5.3 of {{I-D.ietf-cose-rfc8152bis-struct}}, with the EDHOC AEAD algorithm in the selected cipher suite, K_3m, IV_3m, and the following parameters:\r\n\r\n    protected = << ID_CRED_I >>\r\n        ID_CRED_I - identifier to facilitate retrieval of CRED_I, see {{id_cred}}\r\n\r\n    external_aad = << TH_3, CRED_I, ? AD_3 >>\r\n\r\n        CRED_I - bstr containing the credential of the Initiator, see {{id_cred}}.\r\n\r\n        AD_3 = bstr containing opaque protected auxiliary data\r\n\r\n    plaintext = h''\r\n\r\nCOSE constructs the input to the AEAD {{RFC5116}} as follows:\r\n\r\n    Key K = EDHOC-KDF( PRK_4x3m, TH_3, \"K_3m\", length )\r\n\r\n    Nonce N = EDHOC-KDF( PRK_4x3m, TH_3, \"IV_3m\", length )\r\n\r\n    Plaintext P = 0x (the empty string)\r\n\r\n    Associated data A =\r\n\r\n    [ \"Encrypt0\", << ID_CRED_I >>, << TH_3, CRED_I, ? AD_3 >> ]\r\n\r\nMAC_3 is the 'ciphertext' of the inner COSE_Encrypt0.\r\n```\r\n\r\n\r\n",
          "createdAt": "2021-05-19T04:52:00Z",
          "updatedAt": "2021-05-19T05:13:42Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "\"K_2m\", \"K_3m\", \"IV_2m\", \"IV_3m\" could then be removed from the specification.",
          "createdAt": "2021-05-19T04:55:38Z",
          "updatedAt": "2021-05-19T04:55:38Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a significant simplification that also saves memory. The CPU saving are likely minimal compared to the asymmetric operations. Additional benefits are that the MAC length becomes flexible. We could then define a full MAC length for the Signature modes. I don't see any disadvantages.\r\n\r\nI will make a PR during next week.",
          "createdAt": "2021-05-19T09:26:51Z",
          "updatedAt": "2021-05-19T09:26:51Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This is the PR: #123 ",
          "createdAt": "2021-05-26T12:07:16Z",
          "updatedAt": "2021-05-26T12:07:16Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "If we merge this PR we should remove the following sentence from 3.5.1.\r\n\"The MAC is implemented with an AEAD algorithm.\"",
          "createdAt": "2021-07-24T10:51:44Z",
          "updatedAt": "2021-07-24T10:51:44Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Made two new PRs and deleted the old ones. Began implementing #136 with a CBOR sequence. I then modified #136 to #137 where an array is used instead of a sequence. \r\n\r\n#137 is likely the better choice. I think somebody expressed that it was good if context is explicit. #137 also seems simpler.",
          "createdAt": "2021-07-26T12:59:12Z",
          "updatedAt": "2021-07-26T12:59:12Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking more maybe CBOR bstr for context is the best\r\n\r\n```\r\nEDHOC-Exporter(label, context, length)\r\n     = EDHOC-KDF(PRK_4x3m, TH_4, label, context, length) \r\n\r\ninfo = [\r\n   edhoc_aead_id : int / tstr,\r\n   transcript_hash : bstr,\r\n   label : tstr,\r\n   context : bstr,\r\n   length : uint\r\n]\r\n\r\n```     \r\nIf so, should the context for MAC_2 be ?\r\n\r\n```\r\nbytes .cborseq [ ID_CRED_I, CRED_I, ? AD_3 ]\r\nbytes .cbor [ ID_CRED_I, CRED_I, ? AD_3 ]\r\n\r\n```\r\nI don't think the following definition in the current draft is correct: \r\n\r\n` Key K = EDHOC-Exporter( \"EDHOC_message_4_Key\", h'', length )\r\n`\r\n\r\nThe exporter takes an byte string and calls the the EDHOC-KDF. The caller of the exporter does not need to do any CBOR encoding.",
          "createdAt": "2021-07-28T09:24:05Z",
          "updatedAt": "2021-07-28T09:24:05Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The last point, empty byte string representation, relates to #133.",
          "createdAt": "2021-07-28T11:13:07Z",
          "updatedAt": "2021-07-28T11:13:07Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The input to the exporter should likely be a byte string (not a CBOR encoded bstr)\r\nThe input to the KDF could be something different e.g. a sequence.\r\n```\r\n\r\nEDHOC-Exporter(label, context, length)\r\n     = EDHOC-KDF(PRK_4x3m, TH_4, label, context, length) \r\n\r\nwhere context is a bstr,\r\n\r\n\r\n\r\nEDHOC-KDF( PRK, transcript_hash, label, context_seq, length )\r\n      = Expand( PRK, info, length )\r\n\r\ninfo = [\r\n   edhoc_aead_id : int / tstr,\r\n   transcript_hash : bstr,\r\n   label : tstr,\r\n   length : uint\r\n   context_seq : * any,\r\n]\r\n\r\n\r\n\r\nMAC_3 = EDHOC-KDF( PRK_4x3m, TH_3, \"MAC_3\", (ID_CRED_I, CRED_I, ? AD_3 ), mac_length )\r\n\r\n```",
          "createdAt": "2021-07-28T17:06:33Z",
          "updatedAt": "2021-07-28T17:08:50Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe mac_length and AEAD should be decoupled. They are independent things with different purposes. Maybe the Static DH mac length should be added to the cipher suite instead.",
          "createdAt": "2021-07-29T17:16:44Z",
          "updatedAt": "2021-07-29T17:16:44Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments from Christian during IETF 111 is that sequence is better than array for EDHOC-KDF",
          "createdAt": "2021-07-29T19:46:15Z",
          "updatedAt": "2021-07-29T19:46:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on Christian comments I would say that the current plan is to merge #136 with the byte string change above for the exporter:\r\n- Exporter context is a byte string (not CBOR)\r\n- EDHOC-KDF context is a CBOR sequence",
          "createdAt": "2021-07-29T19:50:23Z",
          "updatedAt": "2021-07-29T19:50:23Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest merging #136 as is. That seems like the best and most flexible solution",
          "createdAt": "2021-08-02T08:06:42Z",
          "updatedAt": "2021-08-02T08:06:42Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We could make context a separate parameter without changing anything else in #136\r\n\r\nEDHOC-Exporter(label, context, length)\r\n     = EDHOC-KDF(PRK_4x3m, TH_4, label, context, length) \r\n\r\nCompute MAC_2 = EDHOC-KDF( PRK_3x2m, TH_2, \"MAC_2\", ( ID_CRED_R, CRED_R, ? AD_2 ), mac_length )\r\nMaster Secret = EDHOC-Exporter( \"OSCORE Master Secret\", , key_length )\r\n",
          "createdAt": "2021-08-03T10:59:20Z",
          "updatedAt": "2021-08-03T10:59:20Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The agreed solution with a sequnece that Christian preferred has been merged. Closing this",
          "createdAt": "2021-08-21T15:20:50Z",
          "updatedAt": "2021-08-21T15:20:50Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU4OTc3Njc4NTE=",
      "title": "Make C_1 mandatory",
      "url": "https://github.com/lake-wg/edhoc/issues/124",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Comment from >1 implementer to make the initial byte C_1 of message_1 mandatory rather than optional. This simplifies the disambiguation of messages significantly (relates to #39). The byte budget for message_1 is less severe than message_2 and can afford another byte.",
      "createdAt": "2021-05-21T07:23:08Z",
      "updatedAt": "2021-05-21T18:58:26Z",
      "closedAt": "2021-05-21T18:58:26Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "If #117 is merged, this issue applies instead to  draft-ietf-core-oscore-edhoc:\r\nhttps://github.com/core-wg/oscore-edhoc/pull/2\r\n",
          "createdAt": "2021-05-21T07:41:49Z",
          "updatedAt": "2021-05-21T07:41:49Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like something that should be discussed in #105. Close?",
          "createdAt": "2021-05-21T18:56:55Z",
          "updatedAt": "2021-05-21T18:56:55Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This is also discuss in #95 ",
          "createdAt": "2021-05-21T18:58:11Z",
          "updatedAt": "2021-05-21T18:58:11Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "MDU6SXNzdWU4OTc5MDA5ODA=",
      "title": "CRED_x in CWT format ",
      "url": "https://github.com/lake-wg/edhoc/issues/125",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the example of CRED_x in 3.3.3, consider to replace own construct with CWT:\r\n\r\nOLD:\r\n\r\n~~~~~~~~~~\r\nCRED_x = {\r\n  1:  1,\r\n -1:  4,\r\n -2:  h'b1a3e89460e88d3a8d54211dc95f0b90\r\n        3ff205eb71912d6db8f4af980d2db83a',\r\n \"subject name\" : \"42-50-31-FF-EF-37-32-39\"\r\n}\r\n~~~~~~~~~~\r\n\r\nNEW:\r\n~~~~~~~~~~\r\nCRED_x = {     /CWT/\r\n 2 : \"42-50-31-FF-EF-37-32-39\",    /sub/\r\n 8 : {    /cnf/\r\n       1 : {     /COSE_Key/\r\n              1:  1,\r\n             -1:  4,\r\n             -2:  h'b1a3e89460e88d3a8d54211dc95f0b90\r\n                      3ff205eb71912d6db8f4af980d2db83a',\r\n             }\r\n       }\r\n}\r\n~~~~~~~~~~~",
      "createdAt": "2021-05-21T10:13:32Z",
      "updatedAt": "2021-08-26T16:40:22Z",
      "closedAt": "2021-08-26T16:40:22Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "That is, a CWT without COSE signature/encrypt/MAC, i.e. an UCCS\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-rats-uccs",
          "createdAt": "2021-05-21T10:15:25Z",
          "updatedAt": "2021-07-15T07:40:50Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. I bit related to #115\r\n\r\nWith this change, I don't think EDHOC does maybe not need to support any \"raw\" COSE key. ",
          "createdAt": "2021-05-21T19:35:10Z",
          "updatedAt": "2021-05-21T19:35:10Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This change has now been done in the master branch, see a1b25ba9 and commits in its vicinity.\r\n\r\nCan we close the issue?",
          "createdAt": "2021-07-24T11:44:28Z",
          "updatedAt": "2021-07-24T11:44:28Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like this can be closed",
          "createdAt": "2021-08-26T16:40:22Z",
          "updatedAt": "2021-08-26T16:40:22Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWU4OTk2MDI1NDI=",
      "title": "IANA register for EAD types",
      "url": "https://github.com/lake-wg/edhoc/issues/126",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In PR #111 the type of external authorization data is defined in separate specification. For better interoperability EAD types should be registered in an IANA register. \r\n\r\nTemplate for new IANA subsection:\r\n\r\n~~~~~~~~~~~\r\n## EDHOC External Authorization Data {#iana-ead}\r\n\r\nIANA has created a new registry entitled \"EDHOC External Authorization Data\" \r\nunder the new heading \"EDHOC\". The registration procedure is \"Expert Review\". \r\nThe columns of the registry are Value, Description, and Reference, where Value is \r\nan integer and the other columns are text strings. \r\n~~~~~~~~~~~\r\n",
      "createdAt": "2021-05-24T12:09:54Z",
      "updatedAt": "2021-07-15T20:49:11Z",
      "closedAt": "2021-07-15T20:49:10Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes",
          "createdAt": "2021-06-02T10:36:09Z",
          "updatedAt": "2021-06-02T10:36:09Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Included in -08.",
          "createdAt": "2021-07-15T20:49:10Z",
          "updatedAt": "2021-07-15T20:49:10Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU5MDk1ODk4Njc=",
      "title": "Determining CRED_x from ID_CRED_x",
      "url": "https://github.com/lake-wg/edhoc/issues/128",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current draft (-07) describe the purpose of ID_CRED_x as something that facilitate the retrieval of the public authentication key:\r\n\r\n    \"ID_CRED_R is intended to facilitate for the Initiator to retrieve\r\n      the Responder's public authentication key.\"\r\n\r\nCan another purpose be to determine the format of CRED_R (in case it is not transported)? x5t, c5u etc. reveal not only how to retrieve the public key but also the expected format of the credential (X.509, C509). \r\n\r\n-07 says this is part of the applicability statement, but at least in some cases information about this is actually transported.",
      "createdAt": "2021-06-02T14:52:50Z",
      "updatedAt": "2021-07-19T05:42:59Z",
      "closedAt": "2021-07-19T05:42:59Z",
      "comments": []
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU5NDIwMzA3MzY=",
      "title": "Recommended transport of EDHOC",
      "url": "https://github.com/lake-wg/edhoc/issues/132",
      "state": "CLOSED",
      "author": "malishav",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PR #117 added a following statement recommending CoAP as a transport for EDHOC:\r\n\r\n> DELETED:  For example, if the key exchange is transported over CoAP, the CoAP Token can be used to correlate messages, see {{coap}}. \r\n\r\n> ADDED: The Initiator and the Responder need to have agreed on a transport to be used for EDHOC, see {{applicability}}. It is recommended to transport EDHOC in CoAP payloads, see {{coap}}.\r\n\r\nWhile doing the review of the PR, I commented:\r\n\r\n> How come it is \"recommended\" to transport EDHOC in CoAP? The fact that CoAP is the most frequent use case for transporting EDHOC does not make it a \"recommended\" transport IMO.",
      "createdAt": "2021-07-12T12:53:20Z",
      "updatedAt": "2021-07-19T05:31:03Z",
      "closedAt": "2021-07-19T05:31:03Z",
      "comments": []
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU5NDcyOTY3OTc=",
      "title": "\"Empty byte string\"",
      "url": "https://github.com/lake-wg/edhoc/issues/133",
      "state": "OPEN",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "gselander"
      ],
      "labels": [
        "Close?"
      ],
      "body": "Where necessary, clarify distinction between empty byte string (0x) and CBOR empty byte string (0xf6)",
      "createdAt": "2021-07-19T06:03:52Z",
      "updatedAt": "2021-09-11T10:11:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "If anything need to be done, lets fix it asap and close this issue. ",
          "createdAt": "2021-09-11T10:11:27Z",
          "updatedAt": "2021-09-11T10:11:27Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU5NDk5NTYzODA=",
      "title": "Detailing EDHOC error in CoAP error",
      "url": "https://github.com/lake-wg/edhoc/issues/134",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "New section A.3.1 (see below) has this requirement:\r\n\r\n\"EDHOC error messages sent as CoAP responses MUST be error\r\n   responses\"\r\n\r\n1. Does all CoAP error responses support payload? \r\n2. Should it not be stated that they MUST contain the EDHOC message as payload? \r\n3. Should Content-Format be included in those messages?\r\n\r\n\r\n\"  When using EDHOC over CoAP for establishing an OSCORE Security\r\n   Context, EDHOC error messages sent as CoAP responses MUST be error\r\n   responses, i.e., they MUST specify a CoAP error response code.  In\r\n   particular, it is RECOMMENDED that such error responses have response\r\n   code either 4.00 (Bad Request) in case of client error (e.g., due to\r\n   a malformed EDHOC message), or 5.00 (Internal Server Error) in case\r\n   of server error (e.g., due to failure in deriving EDHOC key\r\n   material).\"\r\n\r\n\r\n\r\n",
      "createdAt": "2021-07-21T17:48:18Z",
      "updatedAt": "2021-08-26T16:39:38Z",
      "closedAt": "2021-08-26T16:39:38Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics Maybe you have a proposal?",
          "createdAt": "2021-07-21T18:00:09Z",
          "updatedAt": "2021-07-21T18:00:09Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "> Does all CoAP error responses support payload?\r\n\r\nYes, see https://datatracker.ietf.org/doc/html/rfc7252/#section-5.9.2  and https://datatracker.ietf.org/doc/html/rfc7252/#section-5.9.3 . Then, if content-format is not specified, the possible payload is a diagnostic payload encoded in UTF-8 --- see https://datatracker.ietf.org/doc/html/rfc7252/#section-5.5.2 --- which leads to the following point.\r\n\r\n> Should it not be stated that they MUST contain the EDHOC message as payload?\r\n\r\nYes, for consistency with the text earlier in Appendix A.3, e.g., \"EDHOC message_2 or the EDHOC error message is sent from the server to the client in the payload of ...\".\r\n\r\n> Should Content-Format be included in those messages?\r\n\r\nActually yes, as an explicit hint to the client that the payload is not a generic diagnostic payload encoded in UTF-8, or any other payload originated by an error source different than EDHOC processing.\r\n\r\nIf this is phrased using \"MUST\", then the second from last paragraph in https://datatracker.ietf.org/doc/html/draft-ietf-core-oscore-edhoc-01#section-3.3  can be shortened, since that document would inherit also this behavior as already defined in the EDHOC document.",
          "createdAt": "2021-07-22T13:24:15Z",
          "updatedAt": "2021-07-22T13:24:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems to me that this can be closed now",
          "createdAt": "2021-08-21T15:19:37Z",
          "updatedAt": "2021-08-21T15:19:37Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWU5NTYxMzg3MTQ=",
      "title": "Nit on draft: Forward Secrecy. Lose the \"Perfect\" claim.",
      "url": "https://github.com/lake-wg/edhoc/issues/138",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Comment by Robert Moskowitz",
      "createdAt": "2021-07-29T19:22:09Z",
      "updatedAt": "2021-08-05T11:36:33Z",
      "closedAt": "2021-08-05T11:36:33Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the forward secrecy could use some more text. Right know we are using the definition according to the IETF security dictionary, but as the security dictionary states, a lot of different definitions is used. The draft that the KeyUpdate gives much better security than using a single key, but that the KeyUpdate method gives a lower security level than frequently running ephemeral diffie-hellman",
          "createdAt": "2021-07-29T19:36:00Z",
          "updatedAt": "2021-07-29T19:36:00Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWU5NTYxNDI4Njg=",
      "title": "Maybe align with https://datatracker.ietf.org/doc/draft-harkins-cfrg-dnhpke/",
      "url": "https://github.com/lake-wg/edhoc/issues/139",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The EDHOC compact representation was formalized after a comment in CFRG on HPKE. Now Dan Harkins has submitted a new draft. We should maybe consider aligning with this draft. Note that the draft is still an individual draft and will likely not be published before EDHOC. ",
      "createdAt": "2021-07-29T19:28:21Z",
      "updatedAt": "2021-07-29T19:28:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU5NTYxNDM5NTE=",
      "title": "IETF 111 comments on EAD",
      "url": "https://github.com/lake-wg/edhoc/issues/140",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Christian Ams\u00fcss\r\nquick question on EAD: it now says \"consideration [...] it does not violate the security properties of EDHOC\". how would it do that?\r\n21:24:13\r\n(not directly for mic because probably excessive)\r\n21:24:29\r\n(can also put that into a \"please elaborate\" issue if that's sutiable)\r\n\r\n\r\n\r\nRobert Moskowitz\r\nChange sec 3.8 title to: External Authorization Data (EAD)\r\n21:27:16\r\nProbably no need to add EAD to definitions section.",
      "createdAt": "2021-07-29T19:30:01Z",
      "updatedAt": "2021-08-05T06:56:54Z",
      "closedAt": "2021-08-05T06:56:54Z",
      "comments": []
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWU5NTYxNDUxMTI=",
      "title": "How can EAD violate security properties?",
      "url": "https://github.com/lake-wg/edhoc/issues/141",
      "state": "OPEN",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [
        "gselander"
      ],
      "labels": [
        "Close?"
      ],
      "body": "Quoting main branch:\r\n\r\n> The EAD fields [...] special considerations need to be made such that a) it does not violate security, privacy etc. requirements of the service which uses this data, and b) it does not violate the security properties of EDHOC.\r\n\r\nI see how an application developer would take a into account, but I think that for b, it'd help to give concrete pointers on what not to do. (Right now, other than \"putting anything in there that's picked out of the EDHOC engine\", I don't have any clue as to what could endanger EDHOC here).",
      "createdAt": "2021-07-29T19:31:44Z",
      "updatedAt": "2021-09-09T13:28:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be rephrased. The security/privacy requirements of the security application using EAD may be other than EDHOC. The text should make clear that: \r\n1. the content of EAD may impact the security properties provided by EDHOC\r\n2. the security properties of EDHOC carrying specific EAD types need to be matched against the requirements of the security application",
          "createdAt": "2021-08-10T07:21:39Z",
          "updatedAt": "2021-08-10T07:21:39Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this now or is more text needed?",
          "createdAt": "2021-08-26T16:38:11Z",
          "updatedAt": "2021-08-26T16:38:11Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU5NTYxNjE5Mjk=",
      "title": "is 101 pages too many words?",
      "url": "https://github.com/lake-wg/edhoc/issues/142",
      "state": "OPEN",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "At some point we should think about the length of the spec.",
      "createdAt": "2021-07-29T19:57:48Z",
      "updatedAt": "2021-09-11T10:10:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "As was mentioned in IETF 111 jabber, we have thought about moving out the test vectors.  That would remove 30+ pages in -08. Either to a file in the Github or to another draft. ",
          "createdAt": "2021-07-30T00:34:48Z",
          "updatedAt": "2021-07-30T00:34:48Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think breaking out the test vectors into a separate informational draft like RFC 8448 is a good idea.",
          "createdAt": "2021-07-30T11:32:51Z",
          "updatedAt": "2021-07-30T11:32:51Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 30/07/2021 12:33, John Mattsson wrote:\n> I think breaking out the test vectors into a separate informational draft like RFC 8448 is a good idea.\n> \n\nI'd say that's probably correct, but maybe best to wait\nuntil we think the test vectors are baked before doing\nthe split? Just to avoid two drafts that get out of whack.\n\nS.\n",
          "createdAt": "2021-07-30T11:49:47Z",
          "updatedAt": "2021-07-30T11:49:47Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "COLLABORATOR",
          "body": "sftcd ***@***.***> wrote:\n    > On 30/07/2021 12:33, John Mattsson wrote:\n    >> I think breaking out the test vectors into a separate informational draft like RFC 8448 is a good idea.\n    >>\n\n    > I'd say that's probably correct, but maybe best to wait\n    > until we think the test vectors are baked before doing\n    > the split? Just to avoid two drafts that get out of whack.\n\n+0.5.\n\nTwo drafts in the same github would solve that problem.\n\n--\n]               Never tell me the odds!                 | ipv6 mesh networks [\n]   Michael Richardson, Sandelman Software Works        |    IoT architect   [\n]     ***@***.***  http://www.sandelman.ca/        |   ruby on rails    [\n\n",
          "createdAt": "2021-07-31T00:01:07Z",
          "updatedAt": "2021-07-31T00:01:07Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "At a later stage I think we can go through the document and try to cut out some duplicate information.",
          "createdAt": "2021-08-05T07:00:39Z",
          "updatedAt": "2021-08-05T07:00:39Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Test vectors are now moved from Appendix D to a separate draft:\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-selander-lake-traces",
          "createdAt": "2021-09-10T14:41:23Z",
          "updatedAt": "2021-09-10T14:41:23Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume we upload draft-selander-lake-traces-00.md to GitHub next to draft-ietf-lake-edhoc.md as suggested by mcr",
          "createdAt": "2021-09-11T10:02:19Z",
          "updatedAt": "2021-09-11T10:02:19Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd Does this close this issue? There might be some trimming possible, but a lot of requests from people implementing have been more example and guidance related to COSE, CBOR and CDDL.\r\n\r\nWithout change log the document is 70 pages.",
          "createdAt": "2021-09-11T10:10:05Z",
          "updatedAt": "2021-09-11T10:10:05Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU5NTkwMzM5OTc=",
      "title": "CDDL section is outdated",
      "url": "https://github.com/lake-wg/edhoc/issues/144",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-03T11:48:37Z",
      "updatedAt": "2021-08-04T15:25:52Z",
      "closedAt": "2021-08-04T15:25:52Z",
      "comments": []
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU5NTk5NzA4MDk=",
      "title": "Describe in a sentence or two why psk is not supported",
      "url": "https://github.com/lake-wg/edhoc/issues/145",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We have gotten questions from other SDOs why PSK is not supported. There is an unfortunate myth that PSK is needed for small messages. When told that public keys with static DH gives the same size and much easier key management they agree that this was a good choice.",
      "createdAt": "2021-08-04T06:55:27Z",
      "updatedAt": "2021-08-04T07:11:01Z",
      "closedAt": "2021-08-04T07:11:01Z",
      "comments": []
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU5NTk5NzE2NzI=",
      "title": "Describe the nonce use in KeyUpdate with a few words",
      "url": "https://github.com/lake-wg/edhoc/issues/146",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-04T06:56:28Z",
      "updatedAt": "2021-08-05T07:13:17Z",
      "closedAt": "2021-08-05T07:13:17Z",
      "comments": []
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWU5NjA1ODU4NDg=",
      "title": "CRED_R may not be a bstr",
      "url": "https://github.com/lake-wg/edhoc/issues/147",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "CRED_R - bstr containing the credential\r\n\r\nThis is not true for C509 which is an CBOR array",
      "createdAt": "2021-08-04T14:58:00Z",
      "updatedAt": "2021-08-05T07:14:17Z",
      "closedAt": "2021-08-05T07:14:17Z",
      "comments": []
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWU5NjE1MTU2NjY=",
      "title": "EAD is underspecified",
      "url": "https://github.com/lake-wg/edhoc/issues/149",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nead = (\r\n  type : int,\r\n  1* ext_authz_data : any,\r\n)\r\n```\r\n\r\nWhat is type? Is that the the external security application or the content, i.e., the sequence of ext_authz_data?\r\n\r\nIf type is the external security application, is the same type supposed to be used in message_1, 2, 3, and 4?\r\n\r\nIf type referes to the ext_authz_data, would it be better with:\r\n\r\n`\r\nead = + ( type : int, ext_authz_data : any )\r\n`",
      "createdAt": "2021-08-05T07:08:40Z",
      "updatedAt": "2021-08-21T15:18:50Z",
      "closedAt": "2021-08-21T15:18:50Z",
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The intent with type is to identify the ext_authz_data object to allow an external security application to define processing with respect to well defined input and output. While defining type per message and per external security application would work, it would not enable reuse of already defined data structures; e.g. would not allow the use of a certain constrained voucher type in more than one message or external security application. \r\n\r\nA modular approach, as in ead = + ... above, does makes sense. For example, depending on if certificate enrollment is performed, a token may be passed with or without a csr in the same ead of one message. The former case can be realized with multiple types of ext_authz_data in one message.",
          "createdAt": "2021-08-09T20:02:47Z",
          "updatedAt": "2021-08-09T20:02:47Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps better use more intuitive notation:\r\n\r\nead = 1* ( type : int, ext_authz_data : any )",
          "createdAt": "2021-08-12T13:26:09Z",
          "updatedAt": "2021-08-12T13:26:09Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good to me. Now EAD is well-specified. I think we can close this unless there are any further comments.\r\n\r\nQuestion if we should have two CDDL indicators. Probably not\r\n\r\nCurrently the CDDL is:\r\n\r\n```\r\n? EAD_1 : ead\r\nead = 1* ( type : int, ext_authz_data : any )\r\n```\r\n\r\nThis can be written as\r\n\r\n```\r\nEAD_1 : ead\r\nead = * ( type : int, ext_authz_data : any )\r\n```\r\n\r\nor\r\n\r\n```\r\n* EAD_1 : ead\r\nead = ( type : int, ext_authz_data : any )\r\n\r\n```\r\n\r\n\r\n\r\n",
          "createdAt": "2021-08-17T13:45:12Z",
          "updatedAt": "2021-08-17T13:45:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "When I read these I make slightly different interpretations:\r\n\r\nThe current says EAD_1 is optional, i.e. need not be present.\r\nThe second says EAD_1 is a fixed field in the protocol but it may be empty.\r\nThe third says there may be zero or more EAD_1 fields.\r\n\r\nThe first is mostly inline with my intuition of EAD. I'm fine with the second. I'm not in favour of the third.\r\n\r\n",
          "createdAt": "2021-08-17T14:02:37Z",
          "updatedAt": "2021-08-17T14:02:37Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Lets keep it as is.",
          "createdAt": "2021-08-21T15:18:50Z",
          "updatedAt": "2021-08-21T15:18:50Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "MDU6SXNzdWU5ODM0NjQxMzM=",
      "title": "Simpler and shorter SUITES_I",
      "url": "https://github.com/lake-wg/edhoc/issues/151",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "The current definition of SUITES_I is that the Initiator can chose any truncation of the list of supported cipher suites as long as the selected cipher suite is included. This works and allows the Initiator to give the Responder information about the full list. This is however a bit complex and has led to misunderstandings of the test vectors where several people thought the test vectors were wrong.\r\n\r\ni.e. the following are all valid\r\n\r\n```\r\nSUITES_I = [6, 5, 6]\r\nSUITES_I = [6, 5, 6, 7]\r\nSUITES_I = [6, 5, 6, 7, 8]\r\n```\r\n\r\nI think we should simplify SUITES_I by mandating that the last suite in the list is the selected. This makes SUITES_I much easier to understand and lowers message size when an array is used. Giving the Responder info is not so important.\r\n\r\n`SUITES_I = [5, 6] `\r\n\r\nCDDL\r\n\r\n`SUITES_I : [ 2* suite ] / suite`",
      "createdAt": "2021-08-31T05:39:55Z",
      "updatedAt": "2021-09-09T07:39:41Z",
      "closedAt": "2021-09-09T07:39:41Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe a recommendation that SUITES_R SHOULD contain all cipher suites that R supports.",
          "createdAt": "2021-08-31T09:01:06Z",
          "updatedAt": "2021-08-31T09:01:06Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Currently\r\nSUITES_R : [ supported : 2* suite ] / suite\r\n\r\nWe may keep that, or remove \"supported\"\r\nSUITES_R : [ 2* suite ] / suite\r\n\r\nAlternatively, we may define\r\nSUITES_I : [ supported : 2* suite ] / suite\r\n\r\nAny preference?",
          "createdAt": "2021-08-31T09:49:23Z",
          "updatedAt": "2021-08-31T09:49:23Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "They should be the same:\r\n\r\n`suites = [ 2* suite ] / suite`\r\n\r\nor \r\n\r\n`suites = [ supported : 2* suite ] / suite`\r\n\r\n\r\nAnd then\r\n\r\n```\r\nSUITES_I : suites,\r\nSUITES_R : suites,\r\n```",
          "createdAt": "2021-08-31T11:03:48Z",
          "updatedAt": "2021-08-31T11:03:48Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be defined as a CDDL type.\r\n`\r\nsuites = [ 2* suite ] / suite`\r\n\r\nSee #155 \r\n",
          "createdAt": "2021-09-01T15:19:43Z",
          "updatedAt": "2021-09-01T15:19:43Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWU5ODM5NjQ4NzQ=",
      "title": "There are two different mac_length ",
      "url": "https://github.com/lake-wg/edhoc/issues/153",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "Current specification could give the impression that there is a single mac_length. But the mac length in message_2 and message_3 may be different.",
      "createdAt": "2021-08-31T15:00:31Z",
      "updatedAt": "2021-09-09T07:39:41Z",
      "closedAt": "2021-09-09T07:39:41Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "One fix is to update to\r\n\r\n```\r\nCompute MAC_2 = EDHOC-KDF( PRK_3e2m, TH_2, \"MAC_2\", ( ID_CRED_R,\r\n      CRED_R, ? EAD_2 ), mac_length_2 )\r\n\r\nCompute MAC_3 = EDHOC-KDF( PRK_4x3m, TH_3, \"MAC_3\", ( ID_CRED_I,\r\n      CRED_I, ? EAD_3 ), mac_length_3 )\r\n```",
          "createdAt": "2021-09-03T07:04:16Z",
          "updatedAt": "2021-09-03T07:04:16Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWU5ODUxMDkwMTQ=",
      "title": "Definition of info in the key derivation",
      "url": "https://github.com/lake-wg/edhoc/issues/154",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "The new definition of info in th ecurrent specification is.\r\n\r\n```\r\n   OKM = EDHOC-KDF( PRK, transcript_hash, label, context, length )\r\n       = Expand( PRK, info, length )\r\n\r\nwhere info is the CBOR encoding of\r\n\r\ninfo = [\r\n   edhoc_aead_id : int / tstr,\r\n   transcript_hash : bstr,\r\n   label : tstr,\r\n   * context : any,\r\n   length : uint,\r\n]\r\n```\r\n\r\nI noticed two problems with this while implementing.\r\n1. To create the array you need to parse context to see how many items it contains. \r\n2. Unless context is validated, length is not strictly defined (an attacker could create collisions)\r\n\r\nI suggest that info is changed to:\r\n\r\n```\r\ninfo = (\r\n   edhoc_aead_id : int / tstr,\r\n   transcript_hash : bstr,\r\n   label : tstr,\r\n   length : uint,\r\n   * context : any,\r\n)\r\n\r\n```\r\n\r\n",
      "createdAt": "2021-09-01T12:47:05Z",
      "updatedAt": "2021-09-09T07:39:41Z",
      "closedAt": "2021-09-09T07:39:41Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "In the exporter, the application using EDHOC could input a context (a encoded CBOR sequence) that is not valid CBOR. That is not a big problem, but might lead to security issues in the future, if is assumed that info is valid CBOR. Chri.stian prefered sequence to array. I don't think bstr wrapping the sequence has the same problems as array wrapping the sequence.\r\n\r\nArray wrapping the info sequence seems like an unesasary step. I suggest.\r\n\r\n```\r\ninfo = (\r\n   edhoc_aead_id : int / tstr,\r\n   transcript_hash : bstr,\r\n   label : tstr,\r\n   context : bsrt,\r\n   length : uint,\r\n)\r\n```\r\n\r\n",
          "createdAt": "2021-09-03T07:09:19Z",
          "updatedAt": "2021-09-03T07:09:19Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We have also gotten comments disliking the use of any",
          "createdAt": "2021-09-03T09:42:39Z",
          "updatedAt": "2021-09-03T09:42:39Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU5ODUyODI2MDU=",
      "title": "ERR_TYPE for ERR_CODE = 2 is a name instead of type.",
      "url": "https://github.com/lake-wg/edhoc/issues/155",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "SUITES_R is a name. The type needs to be defined and the table changed. This can be done in PR #152 \r\n\r\n`suites = [ 2* suite ] / suite,`\r\n\r\n```\r\n   +----------+---------------+----------------------------------------+\r\n   | ERR_CODE | ERR_INFO Type | Description                            |\r\n   +==========+===============+========================================+\r\n   |        0 | any           | Success                                |\r\n   +----------+---------------+----------------------------------------+\r\n   |        1 | tstr          | Unspecified                            |\r\n   +----------+---------------+----------------------------------------+\r\n   |        2 | suites        | Wrong selected cipher suite            |\r\n   +----------+---------------+----------------------------------------+\r\n```",
      "createdAt": "2021-09-01T15:17:41Z",
      "updatedAt": "2021-09-09T07:39:41Z",
      "closedAt": "2021-09-09T07:39:41Z",
      "comments": []
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU5ODY1ODE5NTQ=",
      "title": "CRED_x for 'kid' is not specified",
      "url": "https://github.com/lake-wg/edhoc/issues/156",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "-08 contained a definition of CRED_x including an example when kid is used. -09 removed that example and replaces it with a RPK by value example.\r\n\r\nNow it seems like the most important use case `ID_CRED_x = { 4 : key_id_x }` is not well specified. This is the use case that leads to message_2 being 45 bytes. ",
      "createdAt": "2021-09-02T11:28:01Z",
      "updatedAt": "2021-09-09T07:39:41Z",
      "closedAt": "2021-09-09T07:39:41Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "In addition the TOFU use case should likely also have a kid. Otherwise the UCCS has to be sent by value every time.\r\n\r\n```\r\n   {                                              /UCCS/\r\n     2 : \"42-50-31-FF-EF-37-32-39\",               /sub/\r\n     8 : {                                        /cnf/\r\n       1 : {                                      /COSE_Key/\r\n         1 : 1,                                   /kty/\r\n        -1 : 4,                                   /crv/\r\n        -2 : h'b1a3e89460e88d3a8d54211dc95f0b90   /x/\r\n               3ff205eb71912d6db8f4af980d2db83a'\r\n       }\r\n     }\r\n   }\r\n```\r\n",
          "createdAt": "2021-09-02T11:32:27Z",
          "updatedAt": "2021-09-02T11:33:21Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This is solved by just adding a 'kid' in the COSE_Key map",
          "createdAt": "2021-09-03T06:11:20Z",
          "updatedAt": "2021-09-03T06:11:20Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The document should say someting more about COSE_Key. If ID_CRED_x = { 4 : key_id_x } identifies a raw COSE_Key, is that an error or is CRED_x then the COSE_Key wrapped in a UCCS without any parameters like sub?\r\n\r\n```\r\n   COSE_Key is omitted from the list above because of limitations to\r\n   represent the identity (see Section 3.5.3) and because it can easily\r\n   be embedded in a UCCS.\r\n```",
          "createdAt": "2021-09-03T07:02:51Z",
          "updatedAt": "2021-09-03T07:02:51Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU5ODY2MTg1ODE=",
      "title": "The CWT Confirmation Method 'kid' should also be updated to bstr / int",
      "url": "https://github.com/lake-wg/edhoc/issues/157",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "https://www.iana.org/assignments/cwt/cwt.xhtml",
      "createdAt": "2021-09-02T12:01:01Z",
      "updatedAt": "2021-09-09T07:39:42Z",
      "closedAt": "2021-09-09T07:39:42Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The specification updating 'kid' to bstr / int should likely formally update draft-ietf-cose-rfc8152bis-struct and RFC8747\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-03T06:58:43Z",
          "updatedAt": "2021-09-03T06:58:43Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "In this mail [1] it is considered an option to make the update without formally updating draft-ietf-cose-rfc8152bis-struct. The same applies to RFC 8747.\r\n\r\n\r\n[1] https://mailarchive.ietf.org/arch/msg/lake/zLWEBG1fV6wI1WT6gaI3TpiYjS4/\r\n",
          "createdAt": "2021-09-03T10:29:16Z",
          "updatedAt": "2021-09-03T10:29:41Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 8747 defines 'kid' to be of type value \"binary string\" which is not the name of a CBOR type. Should presumably be \"byte string\", i.e. CBOR major type 2.",
          "createdAt": "2021-09-03T14:46:36Z",
          "updatedAt": "2021-09-03T14:46:36Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWU5ODY5MzU0ODQ=",
      "title": "Registration of a CoRE Resource Type",
      "url": "https://github.com/lake-wg/edhoc/issues/158",
      "state": "CLOSED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A new Resource Type (rt=) Link Target attribute like \"core.edhoc\" may be registered in the \"Resource Type (rt=) Link Target Attribute Values\" subregistry under the \"Constrained RESTful Environments (CoRE) Parameters\" registry.",
      "createdAt": "2021-09-02T16:24:35Z",
      "updatedAt": "2021-09-09T13:26:29Z",
      "closedAt": "2021-09-09T13:26:29Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems like a good idea.",
          "createdAt": "2021-09-03T06:55:56Z",
          "updatedAt": "2021-09-03T06:55:56Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Marco, do you want to provide a PR? Then we could merge that for -11",
          "createdAt": "2021-09-09T07:38:34Z",
          "updatedAt": "2021-09-09T07:38:34Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done, see https://github.com/lake-wg/edhoc/pull/164\r\n\r\nNote that the first commit is just about removing trailing whitespace to avoid compiling errors.\r\n\r\nThe content you need is in the commit https://github.com/lake-wg/edhoc/pull/164/commits/3b0f225aa1f35182126bb96abfd2e8be8c187e9f",
          "createdAt": "2021-09-09T10:33:43Z",
          "updatedAt": "2021-09-09T10:33:43Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good. I tried to align the whole IANA section with RFC 8126. Then I merged.",
          "createdAt": "2021-09-09T13:26:29Z",
          "updatedAt": "2021-09-09T13:26:29Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWU5ODc0MzI5MzY=",
      "title": "Should CWT and UCCS have different COSE header parameters?",
      "url": "https://github.com/lake-wg/edhoc/issues/159",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I don't think this has been discussed (but I might be wrong).\r\n\r\nThe draft currently specifies:\r\n\r\n```\r\n   +-----------+-------+----------------+------------------------------+\r\n   | Name      | Label | Value Type     | Description                  |\r\n   +===========+=======+================+==============================+\r\n   | cwt       |  TBD1 | COSE_Messages  | A CBOR Web Token (CWT) or an |\r\n   |           |       | / map          | Unprotected CWT Claims Set   |\r\n   +-----------+-------+----------------+------------------------------+\r\n```\r\n\r\nAlternative would be to define two different 'cwt' and 'uccs' COSE header parameters",
      "createdAt": "2021-09-03T06:10:18Z",
      "updatedAt": "2021-09-03T16:08:27Z",
      "closedAt": "2021-09-03T16:08:27Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "While there are similar in one way, they have very different security properties and use cases. I think a have a slight preference to standardize two parameters. ",
          "createdAt": "2021-09-03T06:55:08Z",
          "updatedAt": "2021-09-03T06:55:08Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I also tend to prefer two distinct parameters. That would also simplify the initial parsing of credentials, since a dedicated COSE header parameter (rather than the type of the CBOR item) tells you the exact credential format.\r\n\r\nThis applies also beyond EDHOC, in case these formats are generally used to upload/distribute public keys, e.g. in the ACE Group Manager for Group OSCORE [1]. In that particular case, the same exact format has to be used by all the members of a same group for their public keys. Thus, having two distinct parameters \"cwt\" and \"uccs\" prevents possible ambiguity/misunderstanding to handle if there is only one parameter meaning \"cwt or uccs\".\r\n\r\n[1] https://datatracker.ietf.org/doc/draft-ietf-ace-key-groupcomm-oscore/",
          "createdAt": "2021-09-03T09:00:08Z",
          "updatedAt": "2021-09-03T09:00:08Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWU5ODgyNDI0OTA=",
      "title": "Make it clear that ID_CRED_x are COSE header maps",
      "url": "https://github.com/lake-wg/edhoc/issues/161",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ID_CRED_x are COSE header maps and everything with them follows from COSE. The only thing EDHOC adds is to define the format of CRED_x.\r\n\r\nThis is not clear in the current version of the draft. The term \"COSE header map\" has disappeared and it is not clear that the quite long section on ID_CRED_x are just examples of COSE and not new specification.\r\n\r\nCDDL for ID_CRED_x should be added. They are of type header_map defined in the COSE RFC.\r\n",
      "createdAt": "2021-09-04T08:24:45Z",
      "updatedAt": "2021-09-10T09:23:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We should probably add CDDL for CRED_R as well. CRED_R is in general any as it needs to support any future header parameters COSE defined for header_map.\r\n\r\nFor the currently defined credentials\r\n\r\n```\r\nCRED_x = bstr / map / COSE_Messages / C509Certificate\r\n```\r\n\r\n```\r\nx509      bstr\r\nuccs      map\r\ncwt        COSE_Messages\r\nc509     C509Certificate\r\n```\r\n\r\nThe draft need to say something about tags. Is both tagged and untagged allowed in CRED_X?\r\n\r\nCOSE_Messages = COSE_Untagged_Message / COSE_Tagged_Message\r\n\r\n",
          "createdAt": "2021-09-04T08:47:12Z",
          "updatedAt": "2021-09-04T08:47:12Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The mapping from a a COSE header map to a credential or set of credentials is handled by COSE. Note that a COSE header map can contain several header parameters\r\n\r\n```\r\n{ x5u, x5t }\r\n{ kid, kid_context }\r\n{ crit [ c5u ] }\r\n{ kid, c5t }\r\n```\r\n\r\nEDHOC needs to provide a mapping from the credential or set of credentials (e.g. chain, bag, etc. ) to CRED_R. The mapping needs to be equal on both sides. We would like EDHOC to as automatically as posibly support new header parameters and credential types.\r\n\r\nCurrently the COSE header parameters can identify the following credentials.\r\n\r\nBy reference\r\n\r\n```\r\nCOSE_Key\r\nCOSE_Key in an UCCS\r\nCOSE_Key in an CWT\r\nx509 single certificate\r\nx509 chain or bag\r\nc509 single certificate\r\nc509 chain or bag\r\n```\r\n\r\nBy value\r\n\r\n```\r\nUCCS\r\nCWT\r\nx509 single certificate\r\nx509 chain or bag\r\nc509 single certificate\r\nc509 chain or bag\r\n```\r\n\r\nMost of the mapping to CRED_R is currently soft or not existing. It need to be specified exactly. If the parties to different mapping EDHOC will fail.\r\n\r\n- For x509 the solution is to wrap the end-entity DER certificate in a bstr.\r\n- For c509 the solution is to take the end-entity C509Certificate structure\r\n- CWT and UCCS can be tagged and untagged. This might be fine for \"by value\" but might create problems for \"by reference\" which is the main focus of EDHOC. Should EDHOC leave this to the application? Or do we need to handle situation where one of the parties have stored a CWT with an added tag.....\r\n- \"Raw\" COSE_Keys (not inside a CWT or UCSS). Are they supported or not or is UCCS only the way to go? Most if not all COSE implementations have support for raw COSE keys.\r\n- Raw COSE_Keys and UCCS where not really designed to be MACed. Can we expect that one of the parties to add things to the CBOR map?\r\n\r\n```\r\n       {                                      /COSE_Key/\r\n         1 : 1,                                   /kty/\r\n         2 : 0,                                   /kid/\r\n        -1 : 4,                                   /crv/\r\n        -2 : h'b1a3e89460e88d3a8d54211dc95f0b90   /x/\r\n               3ff205eb71912d6db8f4af980d2db83a',\r\n        -65537 : \"Note to self: This is the key to my connected toaster\"\r\n       }\r\n\r\n```\r\n\r\n\r\n",
          "createdAt": "2021-09-08T06:26:00Z",
          "updatedAt": "2021-09-08T06:30:48Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "While we have working interop for the many of the use cases. I think it is clear that ID_CRED_x and CRED_x need to be specified a bit more in detail.\r\n\r\nFor ID_CRED_x I think EDHOC should rely on COSE as much as possible. Formatting of CRED_x is outside of COSE and needs to be specified in EDHOC.\r\n\r\nMy suggestions: \r\n\r\n- I think ID_CRED_x and CRED_x should be defined with CDDL\r\n- I think EDHOC should specify that ID_CRED_x is a COSE header_map but acknoledge that some of the COSE header parameters do not make sense to use in EDHOC. This way EDHOC automatically support new COSE header parameters.\r\n- I think EDHOC should support all COSE header parameters that can be used to identity a cryptographic key.\r\n- In addition there is a need of a map between the object the key is stored in and CRED_x. I think this should maybe be done with a table. An IANA registry might not be wrong.\r\n\r\n```\r\nID_CRED_x = header_map\r\n\r\nCRED_x = any    (where any is determined by the key cryptographic key object)\r\n\r\n```\r\n```\r\n===========================================\r\nCredential type            CRED_x CDDL type\r\n-------------------------------------------\r\nCOSE_Key                   COSE_Key\r\nUCCS                       map\r\nCWT                        COSE_Untagged_Message\r\nX509                       bstr (end-entity)\r\nC509                       C509Certificate (end-entity)\r\n===========================================\r\n\r\n```\r\nThe table above use untagged CWS and UCSS. This avoids problems if of the parties tag their UCCS or CWT for storage. The three options are:\r\n\r\n1. Forcing untagged CRED_x.\r\n2. Forcing tagged CRED_x.\r\n3. Forcing I and R to agree on the format.\r\n\r\n3. does not seem optimal as the parties need to remember if the credential was tagged or untagged when they got it. The coice between 1. and 2. depends on what creates the least work for implementations.\r\n\r\nFurther discussion points are content and order, which the parties need to agree on.\r\n\r\n- EDHOC should state that the parties cannot add private headers to COSE_Key and UCCS\r\n\r\n- Regarding order, the choices are\r\n\r\n   a. force lexiographical order\r\n   b. force the parties to agree on the order.\r\n  \r\n   I don't really understand why the order is unspecified in the first place, but given that is is and that COSE assumes that entities can and will reorder it seems like forcing lexiographic order might be the best. That should probably be recommended in general.\r\n",
          "createdAt": "2021-09-09T08:57:49Z",
          "updatedAt": "2021-09-09T08:58:55Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some input on some of the points above:\r\n\r\n* I think it's good to exclude \"Raw\" COSE Keys altogether, like it recently seemed to be the plan.\r\n   - As a main limitation, they don't allow to express additional metadata, including peer identity and credential expiration, that might be important to have around as part of an authenticated credential. As another limitation, they can't currently be transported by value, because there is no COSE Header Parameter for that.\r\n   - On the other hand, it's pretty cheap and easy to build a UCCS around a COSE Key. If COSE Keys are already supported in one's implementation, the additional step to take for \"dressing-up\" a \"Raw\" COSE Key as a UCCS is really small (trivial?), and might of course be limited to including only the 'cnf' claim, with no further metadata if that's appropriate/desired. Hence I think it's worthwhile and justifiable to have UCCS as a better substitute without the limitations above.\r\n\r\n* For the inner COSE Key structure, I believe forcing the lexicographical order of its elements is best and most viable.\r\n\r\n* If I understand correctly, there is no need to integrity-protect also the possible CBOR tags. Then, I'd propose to generally admit both tagged and untagged objects. However, possible CBOR tags must be stripped away when building CRED_X --- Relates to https://github.com/lake-wg/edhoc/issues/162\r\n\r\n",
          "createdAt": "2021-09-10T07:18:14Z",
          "updatedAt": "2021-09-10T07:18:14Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Marco. My understandanding of the the current suggestion from Marco is:\r\n\r\n**COSE:** The COSE header parameters for CWT and ECCS allow bot tagged and untagged and do not enforce any specific order in the map.\r\n\r\n**EDHOC:** When CWT and UCCS is used in EDHOC, then CRED_x is the untagged CWT or UCCS sorted\r\nin lexigraphical order as defined by deterministic CBOR.\r\n\r\nThat works for me. ",
          "createdAt": "2021-09-10T07:49:52Z",
          "updatedAt": "2021-09-10T07:49:52Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "UCCS are great, they are clearly a more flexible format for RPKs than \"raw\" COSE_Keys. I think\r\nthe important thing is that EHDOC support UCCS as \"raw\" COSE_Keys has clear limitations. It\r\nwould be good to enourage use of UCCS, but from a design perspective it would be\r\nnice to say that EDHOC relies on COSE and support all credentials that can be identified\r\nwith COSE.\r\n\r\nIt is certainly trivial to dress up a COSE_Key as a UCCS.\r\n\r\n```\r\nNaked:     COSE_Key \r\nDressed:   { 8 : { 1 : COSE_Key } }\r\n```\r\n\r\nThis is done by prefixing the COSE_Key with 0xA108A101. I like the idea of dressing up\r\na COSE_Key as a UCCS. This needs to be specified a bit more in the document.",
          "createdAt": "2021-09-10T09:15:25Z",
          "updatedAt": "2021-09-10T09:15:25Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "So the current suggestion would be something like:\r\n\r\n```\r\n===========================================\r\nCredential type                       CRED_x CDDL type\r\n-------------------------------------------\r\nUCCS / COSE_Key                   map (UCCS map sorted in lexiographical order)\r\nCWT                                       COSE_Untagged_Message (Outer layer in lexiographical order)\r\nX509                                      bstr (end-entity)\r\nC509                                     C509Certificate (end-entity)\r\n===========================================\r\n```\r\n\r\nThe parties need to agree on the content in the CRED_x UCCS map.\r\n\r\nDo we need to specify lexiographical ordering for the CWT as well? If I understand correctly, some parts of the outher layer are formally unordered.\r\n\r\n",
          "createdAt": "2021-09-10T09:22:37Z",
          "updatedAt": "2021-09-10T09:23:13Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "MDU6SXNzdWU5OTA3NDcxNzI=",
      "title": "COSE CWT and UCCS header parameters - tagged, untagged, or both",
      "url": "https://github.com/lake-wg/edhoc/issues/162",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The IANA section currectly specified that CWT can be sent tagged or untagged while UCCS can only be sent untagged. That is probably not how it should be.",
      "createdAt": "2021-09-08T06:04:04Z",
      "updatedAt": "2021-09-10T07:50:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Only untagged:\r\n\r\n```\r\ncwt               COSE_Untagged_Message\r\nuccs             map\r\n\r\n```\r\n\r\nUntagged or tagged:\r\n\r\n```\r\ncwt               COSE_Messages\r\nuccs             #TBD601(map) / map\r\n\r\n```\r\n\r\nOnly tagged\r\n\r\n```\r\ncwt               COSE_Tagged_Message\r\nuccs             #TBD601(map)\r\n```\r\n",
          "createdAt": "2021-09-09T07:35:18Z",
          "updatedAt": "2021-09-09T07:35:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Tagged add bytes that are not required. The COSE header parameter alredady gives this information.\r\n\r\nExcept that I don't have a strong opinion between allowing both and only allowing untagged.\r\n\r\nNote that this is mostly a COSE question, rather than LAKE",
          "createdAt": "2021-09-09T07:36:54Z",
          "updatedAt": "2021-09-09T07:36:54Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The UCCS tag numer has not been assigned yet. \r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-rats-uccs\r\n\r\n",
          "createdAt": "2021-09-09T07:37:37Z",
          "updatedAt": "2021-09-09T07:37:37Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I understand correctly, there is no need to integrity-protect also the possible CBOR tags. Then, I'd propose to generally admit both tagged and untagged objects. However, possible CBOR tags must be stripped away when building CRED_X --- Relates to https://github.com/lake-wg/edhoc/issues/161",
          "createdAt": "2021-09-10T07:18:46Z",
          "updatedAt": "2021-09-10T07:18:46Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": ">If I understand correctly, there is no need to integrity-protect also the possible CBOR tags.\r\n\r\nThere is no need, but if used in the protected header as in EDHOC they will be integrity protected. That however not a problem as the protected header_map is sent on the wire, so both parties will have the same formatting.",
          "createdAt": "2021-09-10T07:43:05Z",
          "updatedAt": "2021-09-10T07:43:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Marco. My understandanding of the the current suggestion from Marco is:\r\n\r\n**COSE:** The COSE header parameters for CWT and ECCS allow bot tagged and untagged and do not enforce any specific order in the map.\r\n\r\n**EDHOC:** When CWT and UCCS is used in EDHOC, then CRED_x is the untagged CWT or UCCS sorted\r\nin lexigraphical order as defined by deterministic CBOR.\r\n\r\nThat works for me. ",
          "createdAt": "2021-09-10T07:48:42Z",
          "updatedAt": "2021-09-10T07:50:36Z"
        }
      ]
    },
    {
      "number": 163,
      "id": "MDU6SXNzdWU5OTA5OTU5MTg=",
      "title": "Align exporter labels",
      "url": "https://github.com/lake-wg/edhoc/issues/163",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The 4 labels use different styles. Should probably align them in -11.\r\n\r\n```\r\n   Label: EDHOC_message_4_Key\r\n   Label: EDHOC_message_4_Nonce\r\n   Label: OSCORE Master Secret\r\n   Label: OSCORE Master Salt\r\n\r\n```",
      "createdAt": "2021-09-08T10:43:56Z",
      "updatedAt": "2021-09-09T07:30:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "1. Should they be aligned?\r\n\r\n2. If yes, how should they be aligned?\r\n\r\n```\r\na)\r\nEDHOC message 4 Key\r\nOSCORE Master Secret\r\n\r\nb)\r\nEDHOC_message_4_Key\r\nOSCORE_Master_Secret\r\n```",
          "createdAt": "2021-09-09T07:29:52Z",
          "updatedAt": "2021-09-09T07:30:15Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWU5OTI5NjM2MTY=",
      "title": "Possible collision of credential identifiers after credential transport by value",
      "url": "https://github.com/lake-wg/edhoc/issues/165",
      "state": "OPEN",
      "author": "marco-tiloca-sics",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "Think of this scenario. An Initiator C1 offers its (self-generated) UCCS credential by value in ID_CRED_I with inner 'kid'=42, and EDHOC completes correctly by accepting the UCCS as Trust On First Use (TOFU). Later on, a different Initiator C2 also offers to the same Responder its (self-generated) UCCS credential by value in ID_CRED_I with inner 'kid'=42 again, and EDHOC completes correctly, again by accepting the UCCS as TOFU. You can think of the same scenario applied to two Responders' credential transported by value in ID_CRED_R just as well.\r\n\r\nIt's probably up to a peer's policies --- possibly reflected in the applicability statement for servers --- to determine whether it is fine or not to accept a UCCS/CWT credential that has a 'kid' equal to another credential already stored.\r\n\r\nIf the policy allows to accept multiple credentials with the same 'kid', later on in the following executions of EDHOC those will likely be referred by their 'kid' in ID_CRED_X, and something needs to be adapted in the EDHOC engine. That is, failing to verify an EDHOC message with one of those peer credential must not discontinue the protocol and send an Error Message right away. Instead, the next credential with that 'kid' should be tried. Only if the message processing fails with all of those credentials, an Error Message is sent.",
      "createdAt": "2021-09-10T07:24:48Z",
      "updatedAt": "2021-09-11T10:51:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Marco,\r\n\r\nI think this is a general problem not really related to CTW or UCSS by value. It exists as long as\r\nmore that one entity determines the kid values. I also think it is not really an EDHOC problem. For\r\nidentification of cryptogrphic keys EDHOC relies purely on COSE by using COSE header maps.\r\n\r\nCOSE writes:\r\n\r\n```\r\n      Applications MUST NOT assume\r\n      that 'kid' values are unique.  There may be more than one key with\r\n      the same 'kid' value, so all of the keys associated with this\r\n      'kid' may need to be checked.\r\n```\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-cose-rfc8152bis-struct-15\r\n\r\nI don't know if there is need for more guidance from a COSE perspective.\r\n\r\n\r\nIn EDHOC the following sentence should maybe be reformulated.\r\n\r\n```\r\n   It is RECOMMENDED that ID_CRED_x uniquely identify the public\r\n   authentication key as the recipient may otherwise have to try several\r\n   keys.\r\n```\r\n\r\nMight be good to remind readers that applications MUST NOT assume that 'kid' values are unique\r\n\r\n",
          "createdAt": "2021-09-10T08:16:37Z",
          "updatedAt": "2021-09-10T08:16:56Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics I made a commit with a reference to COSE and some rephrasing. If you are happy with that we can close this. Otherwise feel free to suggest improvements.",
          "createdAt": "2021-09-11T09:59:30Z",
          "updatedAt": "2021-09-11T09:59:30Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me, thanks! Just a small typo and editorial fix:\r\n\r\ns/as unique as possible to as the/as unique as possible, since the\r\n",
          "createdAt": "2021-09-11T10:51:00Z",
          "updatedAt": "2021-09-11T10:51:00Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "MDU6SXNzdWU5OTMxNTY1Njg=",
      "title": "Should EAD IANA registry contain CDDL",
      "url": "https://github.com/lake-wg/edhoc/issues/166",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Close?"
      ],
      "body": "EAD is currently an (int, any) pair where the specification registering ead is supposed to say what any is for each int. Shold this CDDL information be in the IANA table as well. That forces specification to do this and makes it easier to get an overview.\r\n\r\nI would say yes. COSE and CWT does this.",
      "createdAt": "2021-09-10T11:44:43Z",
      "updatedAt": "2021-09-11T06:56:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussing with G\u00f6ran this seems like a good thing to do. To make the ead terms work with \"value type\" I renamed them to ead_label and ead_value. This aligns with some of the COSE and CWT registries.\r\n\r\nThe change is merged to master and is planned for -11. \r\n",
          "createdAt": "2021-09-11T06:55:54Z",
          "updatedAt": "2021-09-11T06:55:54Z"
        }
      ]
    },
    {
      "number": 167,
      "id": "MDU6SXNzdWU5OTMyMDkxODM=",
      "title": "Registration procedures for the new EDHOC registries",
      "url": "https://github.com/lake-wg/edhoc/issues/167",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently a mixture of:\r\nThe registration procedure is \"Expert Review\".\r\nThe registration procedure is \"Specification Required\". \r\n",
      "createdAt": "2021-09-10T12:55:40Z",
      "updatedAt": "2021-09-11T07:49:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I changed EDHOC Error Code Registry to \"Expert Review\" to align with the others. It makes no sense that the Error registry has harder requirements than the methods or cipher suite registry,\r\n\r\nWe should maybe discuss Registration procedures for the new EDHOC registries at IETF 112. Right now they are all expert review without any differentiation between small and big numbers. We should discuss what is the right approach.\r\n",
          "createdAt": "2021-09-11T06:49:44Z",
          "updatedAt": "2021-09-11T07:49:38Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk0NjgzNDUy",
      "title": "new test vectors",
      "url": "https://github.com/lake-wg/edhoc/pull/14",
      "state": "MERGED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add test vectors for Static-Static DH - based on https://github.com/EricssonResearch/EDHOC/blob/4765c841ed14f2158edcd97940179e8f2dd06edb/Test%20Vectors/vectors.txt#L293",
      "createdAt": "2020-09-29T09:14:30Z",
      "updatedAt": "2020-10-20T05:27:35Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "0fd4d0274fa9591ddfb260cb524f82b0ed1941c3",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "test-vect",
      "headRefOid": "49d765dad938015647da31dc56b1ed058624b748",
      "closedAt": "2020-10-20T05:27:35Z",
      "mergedAt": "2020-10-20T05:27:35Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "2eaeba2228fef4a828bd979a5fe34df86efad36f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2NTk3ODQ1",
      "title": "Clarify hash computation in B.1",
      "url": "https://github.com/lake-wg/edhoc/pull/15",
      "state": "MERGED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #13",
      "createdAt": "2020-10-20T08:42:08Z",
      "updatedAt": "2021-08-19T14:55:04Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "c63851d87b7e73c8b5ab22feec4a9a23c81a903e",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "test-vect",
      "headRefOid": "60b68c09a1df0defc105c251f307b05f17135af0",
      "closedAt": "2020-10-20T15:50:40Z",
      "mergedAt": "2020-10-20T15:50:40Z",
      "mergedBy": "fpalombini",
      "mergeCommit": {
        "oid": "e26929e4d8abb2c37dfc209ad5d604110f64e59f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2OTU4NTgw",
      "title": "Add sections for cred_id encoding and bstr_identifier encoding",
      "url": "https://github.com/lake-wg/edhoc/pull/16",
      "state": "MERGED",
      "author": "fpalombini",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-20T16:56:12Z",
      "updatedAt": "2021-08-19T14:55:15Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "e26929e4d8abb2c37dfc209ad5d604110f64e59f",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "v-02-fp",
      "headRefOid": "fc77115f18753823d80fd320b3b17a8f5c8265ed",
      "closedAt": "2020-11-02T14:32:39Z",
      "mergedAt": "2020-11-02T14:32:39Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "7f978a4c206f7c0d0bc19f9baff99eab80393c5b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE5MTI5ODg0",
      "title": "Fix typo test case (authentication with DH keys)",
      "url": "https://github.com/lake-wg/edhoc/pull/27",
      "state": "MERGED",
      "author": "TimothyClaeys",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Description of the length for key K_2e has a typo. It states that the key should have the same length as the plaintext, which is 10 bytes long, not 80 bytes.",
      "createdAt": "2020-11-11T11:15:16Z",
      "updatedAt": "2020-11-28T08:32:27Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "1f853ac3dd5590ae1de2132c21812f4ef3807f18",
      "headRepository": "TimothyClaeys/edhoc",
      "headRefName": "pr_fix_typo_testcase",
      "headRefOid": "7905613dc0690733884d49adf61ee26c33121787",
      "closedAt": "2020-11-28T08:32:27Z",
      "mergedAt": "2020-11-28T08:32:27Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "589ad325c8c231479d73e86c2035c3467827ee2c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxMzg4OTU0",
      "title": "example applicability template",
      "url": "https://github.com/lake-wg/edhoc/pull/36",
      "state": "MERGED",
      "author": "mcr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "add an appendix as per discussion in meeting today.\r\nProbably the example should be retwigged (as it contains my obscure humour), and likely I've missed some of the detail that needs to be determined.",
      "createdAt": "2020-11-16T06:22:26Z",
      "updatedAt": "2020-12-09T15:21:17Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "39dcf90f303611c84cf818c0a4e46325677aa131",
      "headRepository": "mcr/edhoc",
      "headRefName": "example-applicability-template",
      "headRefOid": "a2b3afaa8fab1bf74d6046eb29c0a1dda328f30c",
      "closedAt": "2020-12-09T15:21:17Z",
      "mergedAt": "2020-12-09T15:21:17Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "2fe5b2b5a499cf928cf3e4d76a668c27a1f203d6"
      },
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I merge this and make updates to it on the master branch:\r\n",
          "createdAt": "2020-12-04T11:04:58Z",
          "updatedAt": "2020-12-09T15:20:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4NzIxMzQz",
      "title": "Update draft-ietf-lake-edhoc.md",
      "url": "https://github.com/lake-wg/edhoc/pull/37",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. Should be discussed in LAKE if this is the right approch\r\n2. Should be discussed what the best way is to calculate the hash chain The nonce is included to make sure that the hash chain does not have short cycles.\r\n3. It should be discussed if the nonce is provided by the application (OSCORE) or by EDHOC itself. If provided by OSCOREbis it could be a random string or a counter. If the nonce is provided by EDHOC it has to be a deterministic. E.g. a counter (or theoretically a LFSR....)",
      "createdAt": "2020-11-27T17:17:57Z",
      "updatedAt": "2021-08-19T14:55:14Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "6469cb8dd1865eb19ad049c28b3781688fcb1aef",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "emanjon-patch-FS",
      "headRefOid": "918487c90c807e63a3cda50769543bd3c1c4fb45",
      "closedAt": "2020-12-03T09:17:51Z",
      "mergedAt": "2020-12-03T09:17:51Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "daa5b14e18f1288d476482e6c376cf45e2f772ef"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI5MDc5NzU1",
      "title": "HPKE KEM (test)",
      "url": "https://github.com/lake-wg/edhoc/pull/38",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The change would mainly affect key derivation of PRKs",
      "createdAt": "2020-11-29T09:05:11Z",
      "updatedAt": "2021-08-19T14:55:12Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "589ad325c8c231479d73e86c2035c3467827ee2c",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "emanjon-patch-1-1",
      "headRefOid": "a4a5163af0aaa6307ee43d130231b49a65f53597",
      "closedAt": "2021-01-26T05:16:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "See #17",
          "createdAt": "2021-01-26T05:16:32Z",
          "updatedAt": "2021-01-26T05:16:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM2OTkxMjk3",
      "title": "Refactor of Section 3, 4.1, 4.2",
      "url": "https://github.com/lake-wg/edhoc/pull/41",
      "state": "MERGED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Targeting #40 ",
      "createdAt": "2020-12-11T15:09:26Z",
      "updatedAt": "2021-08-19T14:55:39Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "refactor-overview",
      "headRefOid": "f54e4ac7c7c3064b982fd91b26ccc7c8d7963afe",
      "closedAt": "2020-12-17T14:22:58Z",
      "mergedAt": "2020-12-17T14:22:58Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "9264c5d7ed521efb739c16afc014f4f0a87f8408"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzUxNzYy",
          "commit": {
            "abbreviatedOid": "021e752"
          },
          "author": "fpalombini",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great improvement in my opinion (I am thinking from the point of view of implementers/new readers)! Thanks @gselander !\r\n\r\nI haven't reviewed all the reference (those that have not been modified in the message formatting sections) to make sure they all point to the right thing.\r\n\r\nThe changes I suggest can be done in the next update, I'm ok with merging first.",
          "createdAt": "2020-12-16T14:41:37Z",
          "updatedAt": "2020-12-16T15:21:02Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "I don't think it helps readability to add all these details at this point in the document... the reader does not know what all the parameters above stand for, and without that I don't know what it adds to the understanding of the protocol.",
              "createdAt": "2020-12-16T14:41:38Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 70,
              "body": "Starting reading the next section, I see that it refers to this figure. Maybe all I am missing is a sentence saying \"The details of the parameters are specified in the following sub-sections\".",
              "createdAt": "2020-12-16T14:45:00Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 78,
              "body": "> see {{method-types}}\r\n\r\nThis points to the IANA registration... I'd rather have the important text here and the IANA registration section point here.",
              "createdAt": "2020-12-16T14:46:51Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 80,
              "body": "General comment: I have reviewed 2 sections and I have been jumping around non-stop already, I think there is too many pointers to other sections in general. For example, we don't need to point to message_1 formatting, I think... let's see if we can slim down the text (possibly for next update).",
              "createdAt": "2020-12-16T14:49:17Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 92,
              "body": "I would put this section after the Message Correlation section",
              "createdAt": "2020-12-16T14:56:28Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 145,
              "body": "Why not calling this section \"Authentication Credentials' Identifiers\"?",
              "createdAt": "2020-12-16T15:01:44Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 180,
              "body": "This feels somewhat out of place here... I don't have a good proposal on where to put this text, but as of now it does not read to me as a \"protocol element\", but either as considerations, or maybe should be under the \"Authentication Credentials\" as a subsection?",
              "createdAt": "2020-12-16T15:07:52Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 197,
              "body": "This section does not introduce the term SUITES_I present in the figure, which would make it compliant with the other sections",
              "createdAt": "2020-12-16T15:12:16Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 200,
              "body": "(Adding it here because I can't comment on l.508 - Communication/Negotiation of Protocol Features ) \r\n\r\nAgain this subsection does not seem to fit at the same level as the other \"Protocol Elements\". I would say this is either \"Features\" or an appendix, or maybe even as the first subsection of \"Message Formatting and Processing\"",
              "createdAt": "2020-12-16T15:15:20Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            },
            {
              "originalPosition": 218,
              "body": "I think we can add some high level general sentence about how ephemeral keys used in \"Ephemeral Public Keys\" section.\r\n\r\nThe key derivation section also belongs better in the \"Processing\" part of \"Message Formatting and Processing\" in my opinion (as a subsection)",
              "createdAt": "2020-12-16T15:18:45Z",
              "updatedAt": "2020-12-17T13:59:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5MzM3ODgx",
      "title": "Fixes typo in Section 4.4.3",
      "url": "https://github.com/lake-wg/edhoc/pull/46",
      "state": "MERGED",
      "author": "TimothyClaeys",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #45 ",
      "createdAt": "2020-12-14T10:27:01Z",
      "updatedAt": "2020-12-17T08:08:07Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "c73dc6affe2d7a47fa8eac97be4d4bbd8bd7c667",
      "headRepository": "TimothyClaeys/edhoc",
      "headRefName": "pr_fix_section4.4.3",
      "headRefOid": "8418a4d2086a659b3104857dc4d3421447a39d09",
      "closedAt": "2020-12-17T08:08:07Z",
      "mergedAt": "2020-12-17T08:08:07Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "cfe86335b6254b1191b97b99658342d2ad390d5f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxMDAzMTk5",
      "title": "Refactor of Section 1",
      "url": "https://github.com/lake-wg/edhoc/pull/49",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Targeting #48",
      "createdAt": "2020-12-16T09:00:55Z",
      "updatedAt": "2021-08-19T14:55:40Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "a09570b4fe83c35444ed8fb771d8c82b3ab71b9c",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "refactor-section1",
      "headRefOid": "f62ca88ee4ff5e8dd964d16e3d86107c36736c14",
      "closedAt": "2021-01-26T04:58:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR was essentially merged with 5f5bee3 - shortcut out of merge conflicts.",
          "createdAt": "2021-01-26T04:58:52Z",
          "updatedAt": "2021-01-26T04:58:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4OTg2NDc1",
      "title": "bstr / int",
      "url": "https://github.com/lake-wg/edhoc/pull/98",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "",
      "createdAt": "2021-04-20T04:53:48Z",
      "updatedAt": "2021-08-19T14:55:33Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "5e9c943432fe3ab08d9649aaa6ac6f84f09af4f0",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "bstr-/-int",
      "headRefOid": "a2152518780987fa53f8c9b66f647444532741c7",
      "closedAt": "2021-08-03T11:43:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this. My understanding is that the suggested content in this PR is already merged in -08 based on another PR.",
          "createdAt": "2021-08-03T11:43:20Z",
          "updatedAt": "2021-08-03T11:43:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwMTQyMTQ3",
      "title": "Computation of transcript hashes",
      "url": "https://github.com/lake-wg/edhoc/pull/102",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #96. I don't think we need to include names for the intermediary hashes.",
      "createdAt": "2021-04-21T12:13:31Z",
      "updatedAt": "2021-04-23T09:59:11Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "5e9c943432fe3ab08d9649aaa6ac6f84f09af4f0",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Computation-of-transcript-hashes",
      "headRefOid": "581f1998d84005e0a58295d088cc01ff278ff46a",
      "closedAt": "2021-04-23T09:59:00Z",
      "mergedAt": "2021-04-23T09:59:00Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "3fa8b1010ff08a0bbe70cfc8bbc8813604d3d75c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIyNzI4Nzgw",
      "title": "Changes to cipher suite algorithms",
      "url": "https://github.com/lake-wg/edhoc/pull/106",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#69",
      "createdAt": "2021-04-25T09:12:35Z",
      "updatedAt": "2021-05-05T10:44:23Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "3fa8b1010ff08a0bbe70cfc8bbc8813604d3d75c",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Changes-to-cipher-suite-algorithms",
      "headRefOid": "b77bfe86d71df7236727882d41d1fe5795fadef6",
      "closedAt": "2021-05-05T10:44:17Z",
      "mergedAt": "2021-05-05T10:44:17Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "55ad52b1b369568ded5c662c30e9899059493955"
      },
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Added clarification. Ready to merge?",
          "createdAt": "2021-05-04T14:53:05Z",
          "updatedAt": "2021-05-04T14:53:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ1Njc3MTQx",
          "commit": {
            "abbreviatedOid": "3c38cd1"
          },
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-27T10:08:17Z",
          "updatedAt": "2021-04-27T10:08:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@emanjon \"authentication key algorithm\" not defined or referenced",
              "createdAt": "2021-04-27T10:08:18Z",
              "updatedAt": "2021-05-05T10:43:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI3MDI5OTY1",
      "title": "Compact representation",
      "url": "https://github.com/lake-wg/edhoc/pull/108",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-30T06:12:35Z",
      "updatedAt": "2021-08-19T14:55:31Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "57ac5116f91b81a1e9ada0d157d896eca814d331",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Compact-representation",
      "headRefOid": "1a55529f8b1d1d6d7a42377b37622aba098cc54a",
      "closedAt": "2021-05-04T14:55:38Z",
      "mergedAt": "2021-05-04T14:55:37Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "e24d07a97ab1fb3263931ae1100e810e33293e1f"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "#107",
          "createdAt": "2021-04-30T06:47:36Z",
          "updatedAt": "2021-04-30T06:47:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI3MjcyMDIy",
      "title": "EDHOC error, availability, DoS",
      "url": "https://github.com/lake-wg/edhoc/pull/109",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-30T11:15:21Z",
      "updatedAt": "2021-08-19T14:55:30Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "57ac5116f91b81a1e9ada0d157d896eca814d331",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "EDHOC-error,-availability,-DoS",
      "headRefOid": "c167024ff3861b3a4568ce3dfd9578d93cefd2d1",
      "closedAt": "2021-05-21T07:52:24Z",
      "mergedAt": "2021-05-21T07:52:24Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "c069549e5faee4ff0783a2775435104b0eac68c9"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "#101",
          "createdAt": "2021-04-30T11:32:10Z",
          "updatedAt": "2021-04-30T11:32:10Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Looks good.",
          "createdAt": "2021-05-09T14:54:00Z",
          "updatedAt": "2021-05-09T14:54:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI5NjIwOTAw",
      "title": "\"external authorization data\" EAD",
      "url": "https://github.com/lake-wg/edhoc/pull/111",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-04T08:38:01Z",
      "updatedAt": "2021-08-19T14:55:26Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "6ae2bcd5dbdf2e7703330c08cb0875d5cd7e941c",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "\"external-authorization-data\"-EAD",
      "headRefOid": "82e1b51b9d614960c61b14b262dd42cce0b2df63",
      "closedAt": "2021-05-24T12:18:43Z",
      "mergedAt": "2021-05-24T12:18:43Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "c14434fe5237fd355da2dfdde8fe734388e23877"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The definition says array but the CDDL is a CBOR sequence. In this case it works to use a sequence.\r\n\r\nThe CDDL for message_1, 2 3 4 needs to be updated. Right now they say \r\n\r\n? EAD_1 : any,\r\n\r\n",
          "createdAt": "2021-05-06T15:22:33Z",
          "updatedAt": "2021-05-06T15:22:33Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Might also want to allow more that one CBOR item. The following would be quite general:\r\n\r\n```\r\nEAD = (\r\n  type : int,\r\n  + ext_authz_data,\r\n)\r\n\r\n? EAD_1 : EAD,\r\n```\r\n\r\nShould probably write that \"+ ext_authz_data,\" follows from \"type : int,\"",
          "createdAt": "2021-05-06T16:06:26Z",
          "updatedAt": "2021-05-06T16:07:02Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Looks good.",
          "createdAt": "2021-05-09T14:54:04Z",
          "updatedAt": "2021-05-09T14:54:04Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Was there any reason that this was not merged today. The new IANA registry for Aux Data should probably be another PR.",
          "createdAt": "2021-05-21T19:10:54Z",
          "updatedAt": "2021-05-21T19:10:54Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason for not merging this yet was to first conclude the discussion about CWT in EAD_2 and EAD_3 in #90.",
          "createdAt": "2021-05-24T06:58:54Z",
          "updatedAt": "2021-05-24T06:58:54Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "By moving out the IANA type to a separate issue #126 and waiting with the CWT related part of #90 we are ready to merge.",
          "createdAt": "2021-05-24T12:11:06Z",
          "updatedAt": "2021-05-24T12:11:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 113,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMwNDUzMDc2",
      "title": "Error codes and definitions.",
      "url": "https://github.com/lake-wg/edhoc/pull/113",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This should address all open issues regarding errors.\r\n- Align with very common standard that 0 means success and everything else means error\r\n- Specify that success is for internal use in the application, it therefore makes sense to use any and let the application define what to store.\r\n- No sense in forcign application to support 0, it is not needed for interoperability over the wire.",
      "createdAt": "2021-05-05T09:51:18Z",
      "updatedAt": "2021-08-19T14:55:25Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "e24d07a97ab1fb3263931ae1100e810e33293e1f",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Error-codes-and-definitions",
      "headRefOid": "0176883283dc57be1cc5ea13ec9bdc208bc10b55",
      "closedAt": "2021-05-21T07:54:36Z",
      "mergedAt": "2021-05-21T07:54:36Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "244f87acb47c204008abf92ab04604de32002f75"
      },
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I kept error codes positive as proposed by IOTOPS, but changed the more general error \"unspecified\" comes before the more specific \"wrong ciphersuite\" because \r\n1. that allows for more specific errors to follow in a structured way in the table\r\n2. that aligned better with the subsubsections describing the cipher suite negotiation.",
          "createdAt": "2021-05-06T08:54:13Z",
          "updatedAt": "2021-05-06T08:54:13Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "John and I are happy with this now. Unless there are any comments we will soon merge this.",
          "createdAt": "2021-05-06T08:56:41Z",
          "updatedAt": "2021-05-06T08:56:41Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Looks good.",
          "createdAt": "2021-05-09T14:54:08Z",
          "updatedAt": "2021-05-09T14:54:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMxNDQyNjk4",
      "title": "Exporter labels, IANA, context, requirements",
      "url": "https://github.com/lake-wg/edhoc/pull/114",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-06T13:29:46Z",
      "updatedAt": "2021-08-19T14:54:48Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "d87282c593d0f68abf3dbf7b99cfe45ef9ca2631",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Exporter-labels,-IANA,-context,-requirements",
      "headRefOid": "68d039d53074027ce92529c210f9ede5e8c99b79",
      "closedAt": "2021-05-21T08:01:12Z",
      "mergedAt": "2021-05-21T08:01:12Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "fa0abe787b8c7299078a897b205b2530930f14fa"
      },
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "(Last two commits on wrong branch.)",
          "createdAt": "2021-05-07T14:15:13Z",
          "updatedAt": "2021-05-07T14:15:13Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "The prototype of EDHOC-Exporter() has remained EDHOC-Exporter(label, length), while it should be EDHOC-Exporter(label, context, length) as per Alternative 3 discussed in issue https://github.com/lake-wg/edhoc/issues/97. Correct?",
          "createdAt": "2021-05-09T14:54:37Z",
          "updatedAt": "2021-05-09T14:54:37Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @marco-tiloca-sics, your comment is addressed in the latest commit. I merge this now.",
          "createdAt": "2021-05-21T08:01:03Z",
          "updatedAt": "2021-05-21T08:01:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQzOTMyMzcy",
      "title": "COSE header parameter for CWT",
      "url": "https://github.com/lake-wg/edhoc/pull/116",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-13T12:22:52Z",
      "updatedAt": "2021-08-19T14:53:32Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "7f1ef760e62fd56fd6ac16fdca36bcd16e98be8a",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "COSE-header-parameter-for-CWT",
      "headRefOid": "f16dfb937937cf91f0b5b70ebc0f7686b3f1fbc0",
      "closedAt": "2021-06-18T09:15:51Z",
      "mergedAt": "2021-06-18T09:15:51Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "dddde969ef78f466e930b49261825a92fc4ad000"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 117,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2MDc0NjE3",
      "title": "Move the prepended C_x from the messages to CoAP section",
      "url": "https://github.com/lake-wg/edhoc/pull/117",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "... and add an appendix telling other protocol binding authors to do as\r\nCoAP does.\r\n\r\nThis is an initial rough change, primarily guided by search for a few\r\nkeywords, so some spots that need changed wording may have been missed.\r\n\r\nThe test vectors were left unmodified. Some data structurs were modified\r\nminimally to be now empty; removing them completely can only be done\r\ninformed my their relevance to the transcripts.",
      "createdAt": "2021-05-17T18:21:30Z",
      "updatedAt": "2021-08-03T11:44:39Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "ba134c697b853d1780a30bd0dd27bc31d2b58a2e",
      "headRepository": "chrysn-pull-requests/edhoc",
      "headRefName": "initial-105",
      "headRefOid": "5390c73cd1002a8d83ff285da49558f39587f508",
      "closedAt": "2021-08-03T11:44:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "The stats (which seem to indicate that more text was added than removed) are skewed a bit by my aversion to long lines, the change log, and a few lines explaining why some empty data structures were left around for further editing. Compensating for those, the text was shortened by 11 lines or 116 words, and can possibly be shortened a bit more now that data_3 and data_4 are empty and might go away completely.",
          "createdAt": "2021-05-17T18:30:30Z",
          "updatedAt": "2021-05-17T18:30:30Z"
        },
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "Spelling out the changes from this PR a bit more explicitly, the messages now all have zeros in the place where they used to have corr (METHOD may be shifted down to by two bits, not done here yet), and crypto-operation-wise behave as if it were 3 (as data_n now do not contain their leading C_x any more even in the client-to-server direction).\r\n\r\nFor messages 3 and 4 this means that these are now always empty. Right now I left them as empty arrays, but for data_3 that means that one hashing step is really just a double hashing (`TH_3 = H( H(TH_2, CIPHERTEXT_2), data_3 )` where data_3 is always the empty bytestring) -- can that hashing operation be removed?",
          "createdAt": "2021-05-17T18:38:02Z",
          "updatedAt": "2021-05-17T18:38:02Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am having a hard time understanding how this change is intended to be implemented: EDHOC messages still include the mandatory connections identifiers; optional identifiers are moved and handled by the transport. Part of the logic seems to be within the EDHOC machinery, part of the logic within the transport handler. @chrysn please let me know if I am missing something.",
          "createdAt": "2021-06-04T08:59:15Z",
          "updatedAt": "2021-06-04T08:59:15Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@malishav Some reflections: \r\n\r\n> EDHOC messages still include the mandatory connections identifiers\r\n\r\nEDHOC messages still include the negotiation of connections identifiers but strictly speaking they are not used by EDHOC anymore.\r\n\r\n> Part of the logic seems to be within the EDHOC machinery, part of the logic within the transport handler.\r\n\r\nAlready with the previous version, in the case of CoAP, part of the logic was outside the EDHOC machinery and in the transport handler, like the use of the CoAP Token. Also, in case of OSCORE, part of the logic was outside the EDHOC machinery because EDHOC could not unilaterally decide on the values of connection identifiers without considering existing OSCORE Recipient Identifiers.\r\n\r\nIs this really so different?\r\n",
          "createdAt": "2021-06-11T14:18:43Z",
          "updatedAt": "2021-06-11T14:18:43Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "See #129",
          "createdAt": "2021-06-12T10:31:16Z",
          "updatedAt": "2021-06-12T10:31:16Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not arguing that this is impossible to implement, I am arguing that it is not the cleanest design. See my comment on #129  on how I think we could cleanly describe the separation of concerns.",
          "createdAt": "2021-06-24T14:49:36Z",
          "updatedAt": "2021-06-24T14:49:36Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this. My understanding is that the suggested content in this PR is already merged in -08 based on another PR.",
          "createdAt": "2021-08-03T11:44:39Z",
          "updatedAt": "2021-08-03T11:44:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2NzY1NDA1",
      "title": "move to \"main\" branch",
      "url": "https://github.com/lake-wg/edhoc/pull/119",
      "state": "MERGED",
      "author": "mcr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "git wants us to call our lead branches \"main\", and MT makefile now does that, so switch.\r\nto avoid warning \"rm -rf lib\", and run make after.\r\n",
      "createdAt": "2021-05-18T13:37:39Z",
      "updatedAt": "2021-08-19T14:55:41Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "ba134c697b853d1780a30bd0dd27bc31d2b58a2e",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "update-makefile-to-main",
      "headRefOid": "7162d6ac6087f4680fc0a2a07e470a0596a0a067",
      "closedAt": "2021-06-23T13:55:42Z",
      "mergedAt": "2021-06-23T13:55:42Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "4b73250d79333c6b12dbea0ac0bec39d66f4026b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3NjcwMzcz",
      "title": "Drop bstr_identifier, allow bstr / int in C_x instead",
      "url": "https://github.com/lake-wg/edhoc/pull/122",
      "state": "CLOSED",
      "author": "chrysn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "The largest fall-out of this will be in draft-ietf-core-oscore-edhoc\r\nsince https://github.com/lake-wg/edhoc/issues/75.\r\n\r\nClose: #79\r\n\r\n---\r\n\r\nAs with #117, the test vectors are untouched. (I don't expect actual change in the numbers, just in the text).\r\n\r\nThis is incomplete on its own due to the #75 changes; I'm opening a separate PR there.\r\n\r\nAnother piece of incompleteness is that this references (with a remark) the kid-int variant suggested in #79, without actually defining it. (But that would be merely an IANA item; the big question to COSE being whether we can up-spec kid to bstr / int in-place or really need kid-int).",
      "createdAt": "2021-05-19T13:31:08Z",
      "updatedAt": "2021-08-03T11:44:48Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "ba134c697b853d1780a30bd0dd27bc31d2b58a2e",
      "headRepository": "chrysn-pull-requests/edhoc",
      "headRefName": "initial-79",
      "headRefOid": "cdc99c5a2fe09ca52dba2fcfcbf6da0388c0cbeb",
      "closedAt": "2021-08-03T11:44:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #98",
          "createdAt": "2021-05-21T07:49:14Z",
          "updatedAt": "2021-05-21T07:49:14Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this. My understanding is that the suggested content in this PR is already merged in -08 based on another PR.",
          "createdAt": "2021-08-03T11:44:48Z",
          "updatedAt": "2021-08-03T11:44:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ5MTM3Njkw",
      "title": "Simplify MAC calculation",
      "url": "https://github.com/lake-wg/edhoc/pull/123",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-20T16:40:16Z",
      "updatedAt": "2021-08-19T14:54:37Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "9dbd704cf5d726aad834fa65d0f55cf37d03d0a7",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Simplify-MAC-calculation",
      "headRefOid": "bc2b8a7189f2a8b8e5963c15839fb677957e4e5d",
      "closedAt": "2021-07-26T12:11:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "Considering this PR on the MAC computation and the recent update to the Exporter interface, the EDHOC-KDF() interface in Section 4 \"Key Derivation\" now generally takes a CBOR sequence as third argument \"label\".\r\n\r\nIf I haven't missed anything in other PRs or commits, this should be reflected also in the definition of the 'info' array in that same section, which is still specifying its \"label\" element as a text string. Correct?",
          "createdAt": "2021-06-01T15:11:10Z",
          "updatedAt": "2021-06-01T15:11:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaces by #136 and #137",
          "createdAt": "2021-07-26T12:11:58Z",
          "updatedAt": "2021-07-26T12:11:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU5MzE1NTYy",
      "title": "cipher suites",
      "url": "https://github.com/lake-wg/edhoc/pull/127",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-01T20:18:24Z",
      "updatedAt": "2021-08-19T14:54:49Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "74c380616eb3401ac942f8e7ba6f79f5a6cb6769",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "cipher-suites",
      "headRefOid": "27aa3b76f37d67d5b9211ce00fd40bd8ba79c057",
      "closedAt": "2021-06-18T07:55:11Z",
      "mergedAt": "2021-06-18T07:55:11Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "b7ea1277a80fa8fd614a25df30eaeba446ada35a"
      },
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good. One inconsistency is that there is no cipher suite with AES-GCM and NIST curves, like (A128GCM, SHA-256, P-256, ES256, A128GCM, SHA-256).\r\n\r\nThis could be a new cipher suite 5. Then all non-CNSA suites would come in pairs.",
          "createdAt": "2021-06-02T06:00:58Z",
          "updatedAt": "2021-06-02T06:00:58Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looks good. One inconsistency is that there is no cipher suite with AES-GCM and NIST curves, like (A128GCM, SHA-256, P-256, ES256, A128GCM, SHA-256).\r\n> \r\n> This could be a new cipher suite 5. Then all non-CNSA suites would come in pairs.\r\n\r\nThat is very intentional. The GCM cipher suite uses X25519 for key exchange and ECDSA for authentication. This seems to be the dominant choice for HTTPS on the Web. Unless you are constrained you typically use X25519 for key exchange for speed and ECDSA for authentication as that is what the CAs support.\r\n\r\nFor an IoT device you probably want to have a single curve implemented. Also it might be much easier to switch to EdDSA as you might not have to rely on Global CAs and all other HTTPS nodes to support EdDSA. You can just deploy you own CWT server and make sure the nodes in you new IoT deployment support EdDSA.\r\n\r\nI have not heard any IoT people very interested in GCM. People seems far more interested in ChaCha20.",
          "createdAt": "2021-06-02T09:40:11Z",
          "updatedAt": "2021-06-02T09:40:11Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Ready to merge?",
          "createdAt": "2021-06-17T09:15:00Z",
          "updatedAt": "2021-06-17T09:15:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4ODI1MTgx",
      "title": "PR#117 rebased on master",
      "url": "https://github.com/lake-wg/edhoc/pull/129",
      "state": "MERGED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-12T09:35:58Z",
      "updatedAt": "2021-07-29T12:22:35Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "5fe30bf7b5311b318e3102d4bae4efbeb5dbe88d",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "gselander-pr-chrysn-pr-117",
      "headRefOid": "d6bfe77c35e877902f165332210cfde6c911568a",
      "closedAt": "2021-06-18T07:46:59Z",
      "mergedAt": "2021-06-18T07:46:59Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "f97a5c51af61ceea5c1066d051c1165f09324770"
      },
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Didn't manage to make a PR on #117, but this should just be rebasing on current master",
          "createdAt": "2021-06-12T09:38:03Z",
          "updatedAt": "2021-06-12T09:38:03Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I reviewed #117 and updated it with my proposed changes in the commit above. Pending resolution of comments in #117 and further quick comments I think we are ready to merge.",
          "createdAt": "2021-06-12T10:35:34Z",
          "updatedAt": "2021-06-12T10:35:34Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated the example message sizes, I think it makes most sense to describe EDHOC itselft without any transport parameters.\r\n\r\nTwo editorials\r\n\r\n\"may need ... no, they don't need anything special\"\r\n\r\n\"For use of EDHOC in the XX protocol\"\r\n\r\nOtherwise I think this is ready to merge",
          "createdAt": "2021-06-17T09:13:01Z",
          "updatedAt": "2021-06-17T09:13:01Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Christian had a comment that one of the hashes became useless. I am not sure it should be removed. New methods may specify things send in message_3.",
          "createdAt": "2021-06-17T09:14:31Z",
          "updatedAt": "2021-06-17T09:14:31Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's not do the editorials now, current text can be kept as placeholders. \r\n\r\nLet's remove data_3 and the iterated hash until there is a concrete method that needs it, but let's merge first to avoid further conflicts.",
          "createdAt": "2021-06-18T05:23:48Z",
          "updatedAt": "2021-06-18T05:23:48Z"
        },
        {
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In general, I think that this approach is a cleaner way to solve the issue than what we had with CORR. Still, as discussed in #117, in order to implement this, interaction between three different protocol implementations is needed: EDHOC to negotiate connection identifiers, OSCORE/application for uniqueness requirements and CoAP/transport layer to transport them. The text is not very clear on how this interaction happens. While this is an implementation decision, it would still be good to organize the text in such a way that a clean separation of concerns is described. \r\n\r\nOne way of doing this would be to split \"Connection Identifiers and Transport\" into two separate sections: \r\n* \"Connection Identifiers\", and \r\n* \"Transport\". \r\n\r\nI would further split the \"Connection Identifiers\" section into three subsections, e.g:\r\n \r\n1) \"CID Negotiation\", \r\n2) \"CID Selection\", and \r\n3) \"CID Transport\".\r\n\r\nThe goal is to describe a clear flow and who does what. For instance, EDHOC calls an OSCORE API which proposes the CID, EDHOC negotiates the CID by exchanging EDHOC messages, EDHOC sets the CIDs to the underlying transport as soon as the CIDs are available. Transport module decides when to send and when to omit the CIDs depending on its correlation properties. The text should be general of course to account for other applications and transports. Would that make sense?\r\n\r\nP.S. I am missing normative text in the CoAP transport case mandating the transport of connection identifiers for different messages (in Section 7.2 ?). Am I missing the reason why there is no normative text at all in Section 7?",
          "createdAt": "2021-06-24T14:46:13Z",
          "updatedAt": "2021-06-24T14:46:13Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "I forgot to respond to @malishav. The PR which was merged addressed much of these comments.\r\n* split \"Connection Identifiers and Transport\" into two separate sections\r\n* split the \"Connection Identifiers\" section into subsections \r\n    * CID Selection\r\n    * Use of CID in EDHOC\r\n    * Use of CID in OSCORE\r\n    * and expanded text about CID transport in the new Transport section\r\n\r\nThe second split was not exactly what was requested but it made more sense to me: The concept of \"CID negotation\" was redundant in the draft and replaced with \"CID Selection\" in a few occurences, wherefore a separate section of CID negotation was not needed. Having one section about CID Transport and then immediately followed by a section about Transport lead to duplicated text so I settled for a reference to the latter section. \r\n\r\nI did not include any text about OSCORE API which seemed too implementation specific. \r\n\r\nAbout normative text for CoAP transport of connection identifier, I don't know why that is needed. How EDHOC messages are transported is application dependent. If desirable an applicability statement can state that they use connection identifiers as described in A.3. I don't think adding normative text makes a difference. \r\n\r\nIf you think this is missing, or something else was missed in this comment, please make separate issues. Thanks.\r\n",
          "createdAt": "2021-07-29T12:22:35Z",
          "updatedAt": "2021-07-29T12:22:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkxNzcxOTUx",
          "commit": {
            "abbreviatedOid": "d6bfe77"
          },
          "author": "malishav",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A couple of editorial comments while going through the PR.",
          "createdAt": "2021-06-24T13:44:04Z",
          "updatedAt": "2021-06-24T13:55:58Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Proposal to rephrase for clarity to:\r\n\r\nIf EDHOC connection identifiers are used by an application protocol for which EDHOC established keys (such as OSCORE), then the selected connection identifiers SHALL adhere to the requirements for that protocol. For OSCORE, the choice of a connection identifier results in the endpoint selecting its Recipient ID (see Section 3.1 of {{RFC8613}}), for which the uniqueness requirements from Section 3.3 of {{RFC8613}} apply.",
              "createdAt": "2021-06-24T13:44:05Z",
              "updatedAt": "2021-06-24T13:55:58Z"
            },
            {
              "originalPosition": 113,
              "body": "How come it is \"recommended\" to transport EDHOC in CoAP? The fact that CoAP is the most frequent use case for transporting EDHOC does not make it a \"recommended\" transport IMO.",
              "createdAt": "2021-06-24T13:46:06Z",
              "updatedAt": "2021-06-24T13:55:58Z"
            },
            {
              "originalPosition": 326,
              "body": "s/enable/enables",
              "createdAt": "2021-06-24T13:50:20Z",
              "updatedAt": "2021-06-24T13:55:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE3OTk5ODk1",
          "commit": {
            "abbreviatedOid": "d9dd81f"
          },
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-29T11:53:49Z",
          "updatedAt": "2021-07-29T11:53:49Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Thanks, included (with minor modification) as you can see.",
              "createdAt": "2021-07-29T11:53:49Z",
              "updatedAt": "2021-07-29T11:53:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 130,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5MDA1Nzk3",
      "title": "Drop bstr_identifier rebased on PR #129",
      "url": "https://github.com/lake-wg/edhoc/pull/130",
      "state": "MERGED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rebase PR #98 and PR #122 on PR #129",
      "createdAt": "2021-06-13T07:17:41Z",
      "updatedAt": "2021-08-19T14:54:17Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "gselander-pr-chrysn-pr-117",
      "baseRefOid": "85d08a6739d51ae2a2c3778f222daf06c6f94966",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "gselander-bstr_identifier",
      "headRefOid": "066c587fc41c65c7c3edc66fd573f1609bb0bdbd",
      "closedAt": "2021-06-18T08:11:08Z",
      "mergedAt": "2021-06-18T08:11:08Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "a867fdaa142025010a43d7ff4f9e518b8bd6cc22"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks very good. I think it is ready to merge.",
          "createdAt": "2021-06-17T09:23:52Z",
          "updatedAt": "2021-06-17T09:23:52Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "kid2 in COSE Key Common Parameters is missing I think",
          "createdAt": "2021-06-17T10:55:11Z",
          "updatedAt": "2021-06-17T10:55:11Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Merge ignoring Travis issue.",
          "createdAt": "2021-06-18T08:10:54Z",
          "updatedAt": "2021-06-18T08:10:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0NjczMjY3OTI5",
      "title": "Revert \"Drop bstr_identifier rebased on PR #129\"",
      "url": "https://github.com/lake-wg/edhoc/pull/131",
      "state": "CLOSED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reverts lake-wg/edhoc#130",
      "createdAt": "2021-06-18T08:18:16Z",
      "updatedAt": "2021-08-19T14:55:07Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "gselander-pr-chrysn-pr-117",
      "baseRefOid": "a867fdaa142025010a43d7ff4f9e518b8bd6cc22",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "revert-130-gselander-bstr_identifier",
      "headRefOid": "6294571c29e6dfa6102521486cb6cdc1fd3f1dc3",
      "closedAt": "2021-06-18T08:41:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 135,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2OTQ5MjEy",
      "title": "Update draft-ietf-lake-edhoc.md",
      "url": "https://github.com/lake-wg/edhoc/pull/135",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-26T11:38:32Z",
      "updatedAt": "2021-08-19T14:53:35Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "Simplify-MAC-calculation",
      "baseRefOid": "bc2b8a7189f2a8b8e5963c15839fb677957e4e5d",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Simplify-MAC-calculation-dummy",
      "headRefOid": "ec37f6910be6cf227b447ab22f3a2fa533ab0b93",
      "closedAt": "2021-07-26T12:11:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaces by #136 and #137",
          "createdAt": "2021-07-26T12:11:48Z",
          "updatedAt": "2021-07-26T12:11:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2OTU1OTQ5",
      "title": "Simpler more secure MAC calculation (CBOR sequence)",
      "url": "https://github.com/lake-wg/edhoc/pull/136",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-26T11:49:46Z",
      "updatedAt": "2021-08-19T14:53:41Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "4ea461c5f637e3c1c4ae4a0cab032df1258df6f3",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Simpler-more-secure-MAC-calculation-(CBOR-sequence)",
      "headRefOid": "0180955e3ec3f2695913d64504365ec13707c3cf",
      "closedAt": "2021-08-11T12:26:21Z",
      "mergedAt": "2021-08-11T12:26:21Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "70045ab12c2ed62c9a33e9a61941bcf52f0b34a6"
      },
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "NONE",
          "body": "At first glance, I like this better than #137, as here I don't have to keep the number of elements in EAD_3 around. (I'll have to have processed them at some point, but that doesn't mean I'm keeping the count around).",
          "createdAt": "2021-07-29T19:43:45Z",
          "updatedAt": "2021-07-29T19:43:45Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on Christians comment. I would suggest that we merge this. I think allowing a CBOR sequence in the exporter migth also be a good idea. That allows external applications to input a CBOR sequence. The implementation allows a implementation to input tsrt, bsrt. That is just a special case when the CBOR sequence consist of a single bstr.",
          "createdAt": "2021-08-02T08:02:25Z",
          "updatedAt": "2021-08-02T08:02:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxMDQxNjg5",
          "commit": {
            "abbreviatedOid": "92a0e4a"
          },
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T10:34:51Z",
          "updatedAt": "2021-08-03T10:34:51Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Here the PRK should be PRK_3e2m.",
              "createdAt": "2021-08-03T10:34:51Z",
              "updatedAt": "2021-08-03T10:34:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxMDQzMTA4",
          "commit": {
            "abbreviatedOid": "92a0e4a"
          },
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T10:36:38Z",
          "updatedAt": "2021-08-03T10:36:38Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "It should be:\r\n\r\nIf the Initiator authenticates with a static Diffie-Hellman key (method equals 2 or 3) ... If the Initiator authenticates with a signature key (method equals 0 or 1)",
              "createdAt": "2021-08-03T10:36:38Z",
              "updatedAt": "2021-08-03T10:36:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxMDY5OTUy",
          "commit": {
            "abbreviatedOid": "bfa4b3f"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T11:10:45Z",
          "updatedAt": "2021-08-03T11:10:45Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "fixed",
              "createdAt": "2021-08-03T11:10:45Z",
              "updatedAt": "2021-08-03T11:10:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxMDc1NzMx",
          "commit": {
            "abbreviatedOid": "0866431"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T11:18:12Z",
          "updatedAt": "2021-08-03T11:18:13Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Fixed",
              "createdAt": "2021-08-03T11:18:13Z",
              "updatedAt": "2021-08-03T11:18:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2NDQ3OTc0",
          "commit": {
            "abbreviatedOid": "df11f8d"
          },
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-10T13:37:42Z",
          "updatedAt": "2021-08-10T13:37:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2OTcxNTE1",
      "title": "Simpler more secure MAC calculation (CBOR array)",
      "url": "https://github.com/lake-wg/edhoc/pull/137",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-26T12:11:04Z",
      "updatedAt": "2021-08-19T14:53:36Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "Simpler-more-secure-MAC-calculation-(CBOR-sequence)",
      "baseRefOid": "b681e6206bf9b76db521870eac4a9ee2055abf3c",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Simpler-more-secure-MAC-calculation-(CBOR-array)",
      "headRefOid": "0a218a287077f8264afd563517af24fa92e64722",
      "closedAt": "2021-08-03T11:40:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now a change bases on #136. The reader need to first look at #136 to understand the suggested changes to the main branch.\r\n\r\nThe diff gives a good overview of the difference between a sequence solution and a array solution.\r\n\r\nIf approved. #137 needs to be merged before #136. ",
          "createdAt": "2021-07-26T22:21:05Z",
          "updatedAt": "2021-07-26T22:21:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this, the plan is to merge #136",
          "createdAt": "2021-08-03T11:40:18Z",
          "updatedAt": "2021-08-03T11:40:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAwMTg3MDg5",
      "title": "Optimization of message_2 to 45 bytes",
      "url": "https://github.com/lake-wg/edhoc/pull/143",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-30T10:31:48Z",
      "updatedAt": "2021-08-19T14:53:37Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "dd1f4e9c78771c5b3a5ee0eba7e292c79d5c074a",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Optimization-of-message_2-to-45-bytes",
      "headRefOid": "1a2d0387961094e91f198781f6b0cb577509665b",
      "closedAt": "2021-08-11T12:18:50Z",
      "mergedAt": "2021-08-11T12:18:50Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "adc594b495659384b26012ddddea5ffb40b865e1"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "message_2 could be made 44 bytes by using the known length of SIGNATURE_OR_MAC_2",
          "createdAt": "2021-07-30T10:49:10Z",
          "updatedAt": "2021-07-30T10:49:10Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "I suggest to have C_R as the last element of the CBOR sequence (which shouldn't be a problem and still allows for a sequential sequence parsing), i.e.:\r\n\r\n```\r\n~~~~~~~~~~~ CDDL\r\ndata_2 = (\r\n  G_Y_CIPHERTEXT_2 : bstr,\r\n  C_R : bstr / int\r\n)\r\n~~~~~~~~~~~\r\n```\r\n\r\nWhen using CoAP (or other transports with the same correlation properties), this would preserve a current good pattern as useful for message recognition: if a response transporting an EDHOC message starts with a CBOR integer, then it's an EDHOC error message.\r\n\r\nIt would be good to preserve this, hence why keeping C_R at the end of the new message_2, since it can now be either a CBOR byte string or a CBOR integer.",
          "createdAt": "2021-07-30T13:06:43Z",
          "updatedAt": "2021-07-30T13:06:43Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging this now as there was no objection to:\r\nhttps://mailarchive.ietf.org/arch/msg/lake/wFREGTMBkR5LEcw3JAksJ782eCk/\r\n\r\nThis provides a solution to the concrete issue raised in #103.",
          "createdAt": "2021-08-11T12:16:50Z",
          "updatedAt": "2021-08-11T12:16:50Z"
        },
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "Mistake, I intended to merge, not close.",
          "createdAt": "2021-08-11T12:18:23Z",
          "updatedAt": "2021-08-11T12:18:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5MDc4NTAx",
          "commit": {
            "abbreviatedOid": "23fd42e"
          },
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-30T13:29:24Z",
          "updatedAt": "2021-07-30T13:29:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAzNjEzNTUz",
      "title": "CRED_x is not bstr",
      "url": "https://github.com/lake-wg/edhoc/pull/148",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#147 ",
      "createdAt": "2021-08-04T15:12:21Z",
      "updatedAt": "2021-08-05T07:14:24Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "972f839a39c59d348cff794a8bdc54082e9739a8",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "CRED_x-is-not-bstr-(e.g.-C509)",
      "headRefOid": "10a2f24bbedbb491fee51de50579330ab8519bdf",
      "closedAt": "2021-08-05T07:14:16Z",
      "mergedAt": "2021-08-05T07:14:16Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "4f889f23eadc50441219a26b2f716c9659d871fa"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0NTI5MTc4",
      "title": "RFC 7624 and Forward Secrecy",
      "url": "https://github.com/lake-wg/edhoc/pull/150",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-05T09:19:20Z",
      "updatedAt": "2021-08-05T11:36:36Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "1359ef4e328c7f09d89910c1198087291627f581",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "RFC-7624-and-Forward-Secrecy",
      "headRefOid": "dbbc13a6c198ccd6c385638a939d6deeff19eb02",
      "closedAt": "2021-08-05T11:36:32Z",
      "mergedAt": "2021-08-05T11:36:32Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "d34d56e95913c0be20e505af4701e10220e68f8a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIzMzYwNzQw",
      "title": "SUITES and kid (#151 #155 #156)",
      "url": "https://github.com/lake-wg/edhoc/pull/152",
      "state": "MERGED",
      "author": "gselander",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addressing #151",
      "createdAt": "2021-08-31T13:11:23Z",
      "updatedAt": "2021-09-03T16:09:15Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "efaa7ccba40adc3291c05faab884229ece009908",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "simplified-suites",
      "headRefOid": "d2b8b6cd912cf091de20ca237ccd1fa90fd14470",
      "closedAt": "2021-09-03T15:51:00Z",
      "mergedAt": "2021-09-03T15:51:00Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "1046f528d02dcfe159db834e87f30bedb062e27c"
      },
      "comments": [
        {
          "author": "gselander",
          "authorAssociation": "COLLABORATOR",
          "body": "@marco-tiloca-sics Please check if your comments are addressed.",
          "createdAt": "2021-09-03T15:34:26Z",
          "updatedAt": "2021-09-03T15:34:26Z"
        },
        {
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "body": "> @marco-tiloca-sics Please check if your comments are addressed.\r\n\r\nYes, especially in [1]. Thanks!\r\n\r\n[1] https://github.com/lake-wg/edhoc/pull/152/commits/1a44dfc8c2015278a3e4eb08399f0a153b8362c1",
          "createdAt": "2021-09-03T15:57:12Z",
          "updatedAt": "2021-09-03T15:57:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ1ODk0NDk4",
          "commit": {
            "abbreviatedOid": "c535701"
          },
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-03T09:11:52Z",
          "updatedAt": "2021-09-03T09:11:53Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "The paragraph before the CDDL notation mentions also one more error situation:\r\n\r\n> or if the Responder supports a cipher suite more preferred by the Initiator than the selected cipher suite\r\n\r\nThe handling of this case seems not present in this paragraph, which focuses on the case where the Responder does not support the selected cipher suite. I suppose the missing sentence is something like:\r\n\r\n\"If the Responder supports the selected cipher suite but it also supports a cipher suite more preferred by the Initiator than the selected cipher suite, then SUITES_R MUST include such more preferred cipher suite\".",
              "createdAt": "2021-09-03T09:11:52Z",
              "updatedAt": "2021-09-03T09:11:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ1ODk2OTUw",
          "commit": {
            "abbreviatedOid": "c535701"
          },
          "author": "marco-tiloca-sics",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-03T09:14:42Z",
          "updatedAt": "2021-09-03T09:14:42Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "> then SUITES_R MUST include the first supported cipher suite in SUITES_I\r\n\r\nThis probably means to include **only** that cipher suite, with SUITE_R simply as an integer. Correct?\r\n\r\nThe same applies to my comment above for SUITE_R including \"such more preferred cipher suite\".",
              "createdAt": "2021-09-03T09:14:42Z",
              "updatedAt": "2021-09-03T09:14:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 160,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI2NjY1Mzc1",
      "title": "mac_length and info (#153 and #154)",
      "url": "https://github.com/lake-wg/edhoc/pull/160",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-03T09:50:56Z",
      "updatedAt": "2021-09-03T16:09:14Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "536018de7873b25d1512f543cbdd4a704fafc991",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "mac_length-and-info-(#153-and-#154)",
      "headRefOid": "8e0ccec530d0a9c0aa2a761bc8409f5390a0b45b",
      "closedAt": "2021-09-03T15:24:46Z",
      "mergedAt": "2021-09-03T15:24:46Z",
      "mergedBy": "gselander",
      "mergeCommit": {
        "oid": "efaa7ccba40adc3291c05faab884229ece009908"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMwNDQzOTA3",
      "title": "Core resource type",
      "url": "https://github.com/lake-wg/edhoc/pull/164",
      "state": "MERGED",
      "author": "marco-tiloca-sics",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-09T10:31:14Z",
      "updatedAt": "2021-09-09T13:24:00Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "eb3ad1450181a8938771ae6f031fc8ab86e4a48f",
      "headRepository": "marco-tiloca-sics/edhoc",
      "headRefName": "core-resource-type",
      "headRefOid": "49d5d0490b99181c31b14b7a6ed0e86dd7a3220d",
      "closedAt": "2021-09-09T13:24:00Z",
      "mergedAt": "2021-09-09T13:24:00Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "7702ed137f46af09a0e2f08508d787ecaf70e588"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxNzk2Njg2",
      "title": "Small restructure of 3.3 and 3.4",
      "url": "https://github.com/lake-wg/edhoc/pull/168",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There was quite a lot of overlap between 3.3.2 and 3.4. Tried to integrate 3.3.2 in 3.4 to avoid that.",
      "createdAt": "2021-09-10T22:34:10Z",
      "updatedAt": "2021-09-10T22:34:10Z",
      "baseRepository": "lake-wg/edhoc",
      "baseRefName": "master",
      "baseRefOid": "8b05f6f41a547e7dab86d30dd7a07f9a7d576cc5",
      "headRepository": "lake-wg/edhoc",
      "headRefName": "Small-restructure-of-3.3-and-3.4",
      "headRefOid": "ae7fc4d2d54addb3f4956a7c2c1471c773913197",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}